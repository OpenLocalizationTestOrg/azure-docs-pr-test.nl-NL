---
title: Ontwerphandleiding voor Azure Storage-tabel | Microsoft Docs
description: Ontwerp schaalbare en zodat tabellen in de Azure-tabelopslag
services: cosmos-db
documentationcenter: na
author: mimig1
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: cosmos-db
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: mimig
ms.openlocfilehash: fd34fb135c76eed4041c29e00e98dde330dfe3f3
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/29/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="c0985-103">Ontwerphandleiding voor Azure Storage-tabel: Het ontwerpen van schaalbare en de zodat tabellen</span><span class="sxs-lookup"><span data-stu-id="c0985-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="c0985-104">Ontwerp schaalbare en zodat tabellen, moet u rekening houden met een aantal factoren, zoals prestaties, schaalbaarheid en kosten.</span><span class="sxs-lookup"><span data-stu-id="c0985-104">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="c0985-105">Als u eerder schema's voor relationele databases hebt ontworpen, deze overwegingen u bekend zijn, maar er zijn een aantal overeenkomsten tussen de Azure Table storage servicemodel en relationele modellen, maar er zijn ook veel belangrijke verschillen.</span><span class="sxs-lookup"><span data-stu-id="c0985-105">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="c0985-106">Deze verschillen worden doorgaans leiden tot zeer verschillende ontwerpen die lijkt erg intuïtief of onjuiste naar iemand bekend bent met relationele databases, maar maak die zinvol als u voor een NoSQL-sleutel/waarde-archief zoals de Azure Table-service ontwerpt.</span><span class="sxs-lookup"><span data-stu-id="c0985-106">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</span></span> <span data-ttu-id="c0985-107">Veel van de verschillen in het ontwerp worden doorgevoerd in het feit dat de tabel-service is ontworpen ter ondersteuning van cloud-toepassingen met miljarden entiteiten (rijen in een relationele database-terminologie) van gegevens of voor gegevenssets die zeer hoge transactie volumes moet ondersteunen: daarom moet u anders nadenken over hoe u uw gegevens opslaat en u begrijpt hoe de tabelservice werkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-107">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</span></span> <span data-ttu-id="c0985-108">Uw oplossing voor het schalen van veel meer (en, tegen lagere kosten) kunt inschakelen door een goed ontworpen NoSQL-gegevensarchief dan een oplossing die gebruikmaakt van een relationele database.</span><span class="sxs-lookup"><span data-stu-id="c0985-108">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="c0985-109">Deze handleiding helpt u met deze onderwerpen.</span><span class="sxs-lookup"><span data-stu-id="c0985-109">This guide helps you with these topics.</span></span>  

## <a name="about-the-azure-table-service"></a><span data-ttu-id="c0985-110">Over de Azure Table-service</span><span class="sxs-lookup"><span data-stu-id="c0985-110">About the Azure Table service</span></span>
<span data-ttu-id="c0985-111">Deze sectie worden enkele van de belangrijkste functies van de tabel-service die vooral relevant voor ontwerpen voor prestaties en schaalbaarheid zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-111">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</span></span> <span data-ttu-id="c0985-112">Als u niet bekend met Azure Storage en de tabelservice bent, eerst lezen [Inleiding tot Microsoft Azure Storage](../storage/common/storage-introduction.md) en [aan de slag met Azure Table Storage met .NET](table-storage-how-to-use-dotnet.md) voordat de rest van dit artikel wordt gelezen.</span><span class="sxs-lookup"><span data-stu-id="c0985-112">If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](../storage/common/storage-introduction.md) and [Get started with Azure Table Storage using .NET](table-storage-how-to-use-dotnet.md) before reading the remainder of this article.</span></span> <span data-ttu-id="c0985-113">Hoewel deze handleiding voor de tabel-service is, wordt het betekenen dat sommige bespreking van de Azure-wachtrij en de Blob-services, en hoe u ze samen met de tabel-service in een oplossing mogelijk gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-113">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</span></span>  

<span data-ttu-id="c0985-114">Wat is de tabel-service?</span><span class="sxs-lookup"><span data-stu-id="c0985-114">What is the Table service?</span></span> <span data-ttu-id="c0985-115">Als u van de naam verwacht, wordt in de tabel-service tabelvorm gebruikt voor het opslaan van gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-115">As you might expect from the name, the Table service uses a tabular format to store data.</span></span> <span data-ttu-id="c0985-116">Elke rij van de tabel een entiteit vertegenwoordigt in de standaard terminologie en de kolommen opslaan van de verschillende eigenschappen van die entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-116">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</span></span> <span data-ttu-id="c0985-117">Elke entiteit heeft een paar sleutels om uniek te identificeren en een timestamp-kolom die de tabel-service gebruikt om bij te houden als de entiteit voor het laatst is bijgewerkt (dit gebeurt automatisch en u kunt handmatig de tijdstempel niet overschrijven met een willekeurige waarde).</span><span class="sxs-lookup"><span data-stu-id="c0985-117">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</span></span> <span data-ttu-id="c0985-118">De tabel-service gebruikt deze tijdstempel laatst is gewijzigd (LMT) voor het beheren van optimistische gelijktijdigheid.</span><span class="sxs-lookup"><span data-stu-id="c0985-118">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="c0985-119">De tabel service REST-API-bewerkingen ook retourneren een **ETag** waarde die deze is afgeleid van de laatste wijziging tijdstempel (LMT).</span><span class="sxs-lookup"><span data-stu-id="c0985-119">The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT).</span></span> <span data-ttu-id="c0985-120">In dit document gebruiken we de termen ETag en LMT door elkaar omdat ze naar de onderliggende gegevens verwijzen.</span><span class="sxs-lookup"><span data-stu-id="c0985-120">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</span></span>  
> 
> 

<span data-ttu-id="c0985-121">Het volgende voorbeeld ziet een eenvoudige tabelontwerp voor het opslaan van entiteiten werknemer en afdeling.</span><span class="sxs-lookup"><span data-stu-id="c0985-121">The following example shows a simple table design to store employee and department entities.</span></span> <span data-ttu-id="c0985-122">Veel van de voorbeelden die verderop in deze handleiding zijn gebaseerd op dit eenvoudige ontwerp.</span><span class="sxs-lookup"><span data-stu-id="c0985-122">Many of the examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="c0985-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="c0985-123">PartitionKey</span></span></th>
<th><span data-ttu-id="c0985-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="c0985-124">RowKey</span></span></th>
<th><span data-ttu-id="c0985-125">tijdstempel</span><span class="sxs-lookup"><span data-stu-id="c0985-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="c0985-126">Marketing</span></span></td>
<td><span data-ttu-id="c0985-127">00001</span><span class="sxs-lookup"><span data-stu-id="c0985-127">00001</span></span></td>
<td><span data-ttu-id="c0985-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="c0985-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-129">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-129">FirstName</span></span></th>
<th><span data-ttu-id="c0985-130">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-130">LastName</span></span></th>
<th><span data-ttu-id="c0985-131">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-131">Age</span></span></th>
<th><span data-ttu-id="c0985-132">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-133">Jan</span><span class="sxs-lookup"><span data-stu-id="c0985-133">Don</span></span></td>
<td><span data-ttu-id="c0985-134">Hall</span><span class="sxs-lookup"><span data-stu-id="c0985-134">Hall</span></span></td>
<td><span data-ttu-id="c0985-135">34</span><span class="sxs-lookup"><span data-stu-id="c0985-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="c0985-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="c0985-136">Marketing</span></span></td>
<td><span data-ttu-id="c0985-137">00002</span><span class="sxs-lookup"><span data-stu-id="c0985-137">00002</span></span></td>
<td><span data-ttu-id="c0985-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="c0985-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-139">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-139">FirstName</span></span></th>
<th><span data-ttu-id="c0985-140">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-140">LastName</span></span></th>
<th><span data-ttu-id="c0985-141">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-141">Age</span></span></th>
<th><span data-ttu-id="c0985-142">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-143">Jun</span><span class="sxs-lookup"><span data-stu-id="c0985-143">Jun</span></span></td>
<td><span data-ttu-id="c0985-144">CaO</span><span class="sxs-lookup"><span data-stu-id="c0985-144">Cao</span></span></td>
<td><span data-ttu-id="c0985-145">47</span><span class="sxs-lookup"><span data-stu-id="c0985-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="c0985-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="c0985-146">Marketing</span></span></td>
<td><span data-ttu-id="c0985-147">Afdeling</span><span class="sxs-lookup"><span data-stu-id="c0985-147">Department</span></span></td>
<td><span data-ttu-id="c0985-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="c0985-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-149">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="c0985-149">DepartmentName</span></span></th>
<th><span data-ttu-id="c0985-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="c0985-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="c0985-151">Marketing</span></span></td>
<td><span data-ttu-id="c0985-152">153</span><span class="sxs-lookup"><span data-stu-id="c0985-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="c0985-153">Verkoop</span><span class="sxs-lookup"><span data-stu-id="c0985-153">Sales</span></span></td>
<td><span data-ttu-id="c0985-154">00010</span><span class="sxs-lookup"><span data-stu-id="c0985-154">00010</span></span></td>
<td><span data-ttu-id="c0985-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="c0985-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-156">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-156">FirstName</span></span></th>
<th><span data-ttu-id="c0985-157">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-157">LastName</span></span></th>
<th><span data-ttu-id="c0985-158">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-158">Age</span></span></th>
<th><span data-ttu-id="c0985-159">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-160">Ken</span><span class="sxs-lookup"><span data-stu-id="c0985-160">Ken</span></span></td>
<td><span data-ttu-id="c0985-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="c0985-161">Kwok</span></span></td>
<td><span data-ttu-id="c0985-162">23</span><span class="sxs-lookup"><span data-stu-id="c0985-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="c0985-163">Tot nu toe lijkt dit erg op een tabel in een relationele database met de belangrijkste verschillen, wordt de verplichte kolommen en de mogelijkheid voor het opslaan van meerdere Entiteitstypen in dezelfde tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-163">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</span></span> <span data-ttu-id="c0985-164">Bovendien elk van de gebruiker gedefinieerde eigenschappen zoals **FirstName** of **leeftijd** heeft een gegevenstype, zoals geheel getal of tekenreeks, net zoals een kolom in een relationele database.</span><span class="sxs-lookup"><span data-stu-id="c0985-164">In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="c0985-165">Hoewel in tegenstelling tot in een relationele database, de schema-minder aard van de tabel-service betekent dat een eigenschap moet niet hetzelfde gegevenstype voor elke entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-165">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</span></span> <span data-ttu-id="c0985-166">Complexe gegevenstypen opslaan in één eigenschap, moet u een zoals JSON of XML-serialisatie-indeling.</span><span class="sxs-lookup"><span data-stu-id="c0985-166">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="c0985-167">Zie voor meer informatie over de tabel-service, zoals ondersteunde gegevenstypen, ondersteunde datumbereiken, naamgevingsregels en beperkingen voor [inzicht in de tabel Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-167">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="c0985-168">Zoals u ziet, uw keuze van **PartitionKey** en **RowKey** is van cruciaal belang goede tabelontwerp.</span><span class="sxs-lookup"><span data-stu-id="c0985-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design.</span></span> <span data-ttu-id="c0985-169">Elke entiteit die is opgeslagen in een tabel moet een unieke combinatie van **PartitionKey** en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="c0985-170">Als u met de sleutels in een relationele database, de **PartitionKey** en **RowKey** waarden worden geïndexeerd voor het maken van een geclusterde index waarmee u snel te zoeken; echter, de tabel-service maakt geen secundaire indexen zodat deze de slechts twee geïndexeerde eigenschappen (enkele van de patronen die verderop tonen hoe u deze duidelijk beperking kunt omzeilen).</span><span class="sxs-lookup"><span data-stu-id="c0985-170">As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="c0985-171">Een tabel bestaat uit een of meer partities en zoals u ziet, worden veel van de ontwerpbeslissingen die u aanbrengt rond het kiezen van een geschikte **PartitionKey** en **RowKey** optimaliseren van uw oplossing.</span><span class="sxs-lookup"><span data-stu-id="c0985-171">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution.</span></span> <span data-ttu-id="c0985-172">Een oplossing kan bestaan uit slechts één tabel die de entiteiten die zijn onderverdeeld in partities bevat, maar doorgaans een oplossing heeft meerdere tabellen.</span><span class="sxs-lookup"><span data-stu-id="c0985-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="c0985-173">Tabellen kunt u logisch ordenen van uw entiteiten, helpen bij het beheren van toegang tot de gegevens met behulp van toegangsbeheerlijsten en u kunt een hele tabel met een één opslag-bewerking neerzetten.</span><span class="sxs-lookup"><span data-stu-id="c0985-173">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="c0985-174">Tabelpartities</span><span class="sxs-lookup"><span data-stu-id="c0985-174">Table partitions</span></span>
<span data-ttu-id="c0985-175">De accountnaam, de tabelnaam en **PartitionKey** samen bepalen de partitie in de storage-service waar de entiteit in de tabelservice worden opgeslagen.</span><span class="sxs-lookup"><span data-stu-id="c0985-175">The account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity.</span></span> <span data-ttu-id="c0985-176">Onderdeel van het adresseringsschema voor entiteiten zijn, partities een bereik voor transacties definiëren (Zie [entiteit groepstransacties](#entity-group-transactions) hieronder), en de basis vormen van de manier waarop de tabelservice schaalt.</span><span class="sxs-lookup"><span data-stu-id="c0985-176">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales.</span></span> <span data-ttu-id="c0985-177">Zie voor meer informatie over partities [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="c0985-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span></span>  

<span data-ttu-id="c0985-178">Een afzonderlijke knooppunten services in de tabel-service, een of meer partities en de service kan worden geschaald voltooien door dynamisch taakverdeling partities over knooppunten.</span><span class="sxs-lookup"><span data-stu-id="c0985-178">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="c0985-179">Als een knooppunt belast wordt, de tabelservice kunt *splitsen* het bereik van de partities onderhouden door dat knooppunt op verschillende knooppunten; wanneer verkeer subsidies, de service kan *samenvoegen* de partitie kan variëren van stille knooppunten back naar één knooppunt.</span><span class="sxs-lookup"><span data-stu-id="c0985-179">If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="c0985-180">Zie het artikel voor meer informatie over de interne details van de tabel-service en met name hoe de service partities beheert, [Microsoft Azure Storage: een maximaal beschikbare Cloudopslagservice met sterke consistentie](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-180">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="c0985-181">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-181">Entity Group Transactions</span></span>
<span data-ttu-id="c0985-182">Entiteit groepstransacties (EGTs) zijn in de tabel-service de enige ingebouwde mechanisme voor het uitvoeren van atomaire updates tussen meerdere entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-182">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="c0985-183">EGTs worden ook aangeduid als *batch transacties* in sommige documentatie.</span><span class="sxs-lookup"><span data-stu-id="c0985-183">EGTs are also referred to as *batch transactions* in some documentation.</span></span> <span data-ttu-id="c0985-184">EGTs werkt alleen voor entiteiten die zijn opgeslagen in dezelfde partitie (share dezelfde partitiesleutel in een bepaalde tabel), dus telkens wanneer u atomic transactionele gedrag tussen meerdere entiteiten moet, u ervoor zorgen moet dat deze entiteiten in dezelfde partitie zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-184">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</span></span> <span data-ttu-id="c0985-185">Dit is vaak een reden voor meerdere tabellen niet gebruiken voor andere entiteitstypen en meerdere Entiteitstypen houden in dezelfde tabel (en de partitie).</span><span class="sxs-lookup"><span data-stu-id="c0985-185">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="c0985-186">Een enkele EGT kan werken op maximaal 100 entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="c0985-187">Als u meerdere gelijktijdige EGTs voor de verwerking is het belangrijk om ervoor te zorgen dat die EGTs worden niet uitgevoerd op de entiteiten die voor EGTs gelden anders verwerken vertraging verzenden.</span><span class="sxs-lookup"><span data-stu-id="c0985-187">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="c0985-188">EGTs ook leiden tot een mogelijke waarde om te beoordelen in uw ontwerp: de schaalbaarheid van uw toepassing met behulp van meer partities wordt verhoogd omdat Azure heeft meer mogelijkheden voor aanvragen voor taakverdeling over de knooppunten, maar dit kan de mogelijkheid van uw toepassing uit te voeren atomische transacties sterke consistentie voor uw gegevens beperken.</span><span class="sxs-lookup"><span data-stu-id="c0985-188">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="c0985-189">Bovendien, er zijn specifieke schaalbaarheidsdoelen op het niveau van een partitie die de doorvoer van transacties die u voor één knooppunt verwachten kunt kan beperken: Zie voor meer informatie over de schaalbaarheidsdoelen voor Azure storage-accounts en de tabelservice [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="c0985-189">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span></span> <span data-ttu-id="c0985-190">Latere secties van deze handleiding worden verschillende ontwerp strategieën die u helpen beheren zoals deze verschillen en bespreken het beste de partitiesleutel op basis van de specifieke vereisten van uw clienttoepassing kiezen.</span><span class="sxs-lookup"><span data-stu-id="c0985-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="c0985-191">Overwegingen voor capaciteitsplanning</span><span class="sxs-lookup"><span data-stu-id="c0985-191">Capacity considerations</span></span>
<span data-ttu-id="c0985-192">De volgende tabel bevat enkele van de belangrijkste waarden moet denken bij het ontwerpen van een oplossing voor tabel-service:</span><span class="sxs-lookup"><span data-stu-id="c0985-192">The following table includes some of the key values to be aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="c0985-193">Totale capaciteit van een Azure storage-account</span><span class="sxs-lookup"><span data-stu-id="c0985-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="c0985-194">500 TB</span><span class="sxs-lookup"><span data-stu-id="c0985-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="c0985-195">Aantal tabellen in een Azure storage-account</span><span class="sxs-lookup"><span data-stu-id="c0985-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="c0985-196">Alleen beperkt door de capaciteit van het storage-account</span><span class="sxs-lookup"><span data-stu-id="c0985-196">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="c0985-197">Aantal partities in een tabel</span><span class="sxs-lookup"><span data-stu-id="c0985-197">Number of partitions in a table</span></span> |<span data-ttu-id="c0985-198">Alleen beperkt door de capaciteit van het storage-account</span><span class="sxs-lookup"><span data-stu-id="c0985-198">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="c0985-199">Aantal entiteiten in een partitie</span><span class="sxs-lookup"><span data-stu-id="c0985-199">Number of entities in a partition</span></span> |<span data-ttu-id="c0985-200">Alleen beperkt door de capaciteit van het storage-account</span><span class="sxs-lookup"><span data-stu-id="c0985-200">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="c0985-201">Grootte van een afzonderlijke entiteit</span><span class="sxs-lookup"><span data-stu-id="c0985-201">Size of an individual entity</span></span> |<span data-ttu-id="c0985-202">Maximaal 1 MB van maximaal 255 eigenschappen (inclusief de **PartitionKey**, **RowKey**, en **tijdstempel**)</span><span class="sxs-lookup"><span data-stu-id="c0985-202">Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="c0985-203">Grootte van de **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="c0985-203">Size of the **PartitionKey**</span></span> |<span data-ttu-id="c0985-204">Een tekenreeks maximaal 1 KB groot</span><span class="sxs-lookup"><span data-stu-id="c0985-204">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="c0985-205">Grootte van de **RowKey**</span><span class="sxs-lookup"><span data-stu-id="c0985-205">Size of the **RowKey**</span></span> |<span data-ttu-id="c0985-206">Een tekenreeks maximaal 1 KB groot</span><span class="sxs-lookup"><span data-stu-id="c0985-206">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="c0985-207">Grootte van een entiteit groep-transactie</span><span class="sxs-lookup"><span data-stu-id="c0985-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="c0985-208">Een transactie kan maximaal 100 entiteiten bevatten en de lading moet minder dan 4 MB groot.</span><span class="sxs-lookup"><span data-stu-id="c0985-208">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</span></span> <span data-ttu-id="c0985-209">Een EGT kan slechts eenmaal bijwerken een entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="c0985-210">Zie voor meer informatie [inzicht in de tabel Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-210">For more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="c0985-211">Kosten overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-211">Cost considerations</span></span>
<span data-ttu-id="c0985-212">Tabelopslag relatief goedkope is, maar moet u kosten maakt een schatting voor capaciteitsgebruik en het aantal transacties opnemen als onderdeel van de evaluatie van een oplossing die gebruikmaakt van de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</span></span> <span data-ttu-id="c0985-213">In veel scenario's voor het opslaan van gedenormaliseerd of dubbele gegevens om te verbeteren is de prestaties of de schaalbaarheid van uw oplossing echter een geldige benadering te laten worden.</span><span class="sxs-lookup"><span data-stu-id="c0985-213">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</span></span> <span data-ttu-id="c0985-214">Zie voor meer informatie over prijzen [prijzen voor Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="c0985-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="c0985-215">Richtlijnen voor het tabelontwerp van de</span><span class="sxs-lookup"><span data-stu-id="c0985-215">Guidelines for table design</span></span>
<span data-ttu-id="c0985-216">Deze lijsten geven een overzicht van enkele van de belangrijkste richtlijnen die u rekening houden moet bij het ontwerpen van uw tabellen en deze handleiding los deze allemaal in meer detail later in.</span><span class="sxs-lookup"><span data-stu-id="c0985-216">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="c0985-217">Deze richtlijnen zijn heel verschillend van de richtlijnen die u doorgaans als voor het ontwerp van relationele database volgt.</span><span class="sxs-lookup"><span data-stu-id="c0985-217">These guidelines are very different from the guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="c0985-218">Ontwerpen van uw oplossing tabel-service worden *lezen* efficiënt:</span><span class="sxs-lookup"><span data-stu-id="c0985-218">Designing your Table service solution to be *read* efficient:</span></span>

* <span data-ttu-id="c0985-219">***Ontwerpen voor het uitvoeren van toepassingen waarin lezen veel query's.***</span><span class="sxs-lookup"><span data-stu-id="c0985-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="c0985-220">Tijdens het ontwerpen van uw tabellen nadenken over de query's (met name de latentie gevoelig die) die zal worden uitgevoerd voordat u nadenken over hoe u uw entiteiten wordt bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-220">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="c0985-221">Dit leidt meestal tot een efficiënte en zodat oplossing.</span><span class="sxs-lookup"><span data-stu-id="c0985-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="c0985-222">***Geef zowel PartitionKey en RowKey in uw query's.***</span><span class="sxs-lookup"><span data-stu-id="c0985-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="c0985-223">*Query's wijst* zoals dit zijn de meest efficiënt query's een tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-223">*Point queries* such as these are the most efficient table service queries.</span></span>  
* <span data-ttu-id="c0985-224">***Houd rekening met dubbele exemplaren van entiteiten opslaan.***</span><span class="sxs-lookup"><span data-stu-id="c0985-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="c0985-225">Tabelopslag goedkope is dus overwegen bij het opslaan van dezelfde entiteit meerdere keren (met verschillende sleutels) om in te schakelen efficiënter query's.</span><span class="sxs-lookup"><span data-stu-id="c0985-225">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</span></span>  
* <span data-ttu-id="c0985-226">***U kunt uw gegevens denormalizing.***</span><span class="sxs-lookup"><span data-stu-id="c0985-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="c0985-227">Tabelopslag goedkope is dus Overweeg denormalizing van uw gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="c0985-228">Samenvatting entiteiten bijvoorbeeld opslaan zodat query's voor statistische gegevens alleen hoeft toegang tot één entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-228">For example, store summary entities so that queries for aggregate data only need to access a single entity.</span></span>  
* <span data-ttu-id="c0985-229">***Gebruik de samengestelde sleutel komt.***</span><span class="sxs-lookup"><span data-stu-id="c0985-229">***Use compound key values.***</span></span> <span data-ttu-id="c0985-230">De enige sleutels die u hebt zijn **PartitionKey** en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-230">The only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="c0985-231">Samengestelde sleutel komt bijvoorbeeld gebruiken om in te schakelen alternatieve sleutelhash Toegangspaden naar entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-231">For example, use compound key values to enable alternate keyed access paths to entities.</span></span>  
* <span data-ttu-id="c0985-232">***Query-projectie gebruiken.***</span><span class="sxs-lookup"><span data-stu-id="c0985-232">***Use query projection.***</span></span> <span data-ttu-id="c0985-233">U kunt verminderen de hoeveelheid gegevens die u via het netwerk overdragen met behulp van query's die alleen de velden die u moet selecteren.</span><span class="sxs-lookup"><span data-stu-id="c0985-233">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</span></span>  

<span data-ttu-id="c0985-234">Ontwerpen van uw oplossing tabel-service worden *schrijven* efficiënt:</span><span class="sxs-lookup"><span data-stu-id="c0985-234">Designing your Table service solution to be *write* efficient:</span></span>  

* <span data-ttu-id="c0985-235">***Maak geen hot partities.***</span><span class="sxs-lookup"><span data-stu-id="c0985-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="c0985-236">De optie sleutels waarmee u uw aanvragen verdeeld over meerdere partities op elk moment.</span><span class="sxs-lookup"><span data-stu-id="c0985-236">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="c0985-237">***Vermijd pieken in het verkeer.***</span><span class="sxs-lookup"><span data-stu-id="c0985-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="c0985-238">Het verkeer via een redelijke periode vloeiend en pieken in het verkeer worden vermeden.</span><span class="sxs-lookup"><span data-stu-id="c0985-238">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="c0985-239">***Niet per se een afzonderlijke tabel voor elk type entiteit maken.***</span><span class="sxs-lookup"><span data-stu-id="c0985-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="c0985-240">Wanneer u atomische transacties op Entiteitstypen vereisen, slaat u deze meerdere Entiteitstypen in dezelfde partitie in dezelfde tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-240">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</span></span>
* <span data-ttu-id="c0985-241">***U kunt de maximale doorvoer die moeten worden gerealiseerd.***</span><span class="sxs-lookup"><span data-stu-id="c0985-241">***Consider the maximum throughput you must achieve.***</span></span> <span data-ttu-id="c0985-242">U moet rekening houden met de schaalbaarheidsdoelen voor de tabel-service en ervoor te zorgen dat uw ontwerp leidt niet tot u ze overschrijden.</span><span class="sxs-lookup"><span data-stu-id="c0985-242">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</span></span>  

<span data-ttu-id="c0985-243">Als u deze handleiding leest, ziet u voorbeelden die al deze principes in de praktijk geplaatst.</span><span class="sxs-lookup"><span data-stu-id="c0985-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="c0985-244">Ontwerp voor het uitvoeren van query 's</span><span class="sxs-lookup"><span data-stu-id="c0985-244">Design for querying</span></span>
<span data-ttu-id="c0985-245">Oplossingen voor tabel-service kunnen worden gelezen intensief schrijven intensief of een combinatie van beide.</span><span class="sxs-lookup"><span data-stu-id="c0985-245">Table service solutions may be read intensive, write intensive, or a mix of the two.</span></span> <span data-ttu-id="c0985-246">Deze sectie richt zich op de zaken op moet letten tijdens het ontwerpen van de service voor ondersteuning voor leesbewerkingen efficiënt uw tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-246">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</span></span> <span data-ttu-id="c0985-247">Een ontwerp dat ondersteunt lees-en schrijfopdrachten efficiënt is meestal ook efficiënt voor schrijfbewerkingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="c0985-248">Er zijn echter aanvullende overwegingen op moet letten bij het ontwerpen van ondersteuning voor schrijfbewerkingen, die wordt besproken in de volgende sectie [ontwerp voor wijziging van gegevens](#design-for-data-modification).</span><span class="sxs-lookup"><span data-stu-id="c0985-248">However, there are additional considerations to bear in mind when designing to support write operations, discussed in the next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="c0985-249">Een goed uitgangspunt voor het ontwerpen van uw tabel-service-oplossing kunt u gegevens efficiënt te lezen is vragen "welke query mijn toepassing moeten worden uitgevoerd voor het ophalen van de benodigde gegevens uit de tabelservice?"</span><span class="sxs-lookup"><span data-stu-id="c0985-249">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="c0985-250">Met de tabel-service is het belangrijk dat u het ontwerp van de juiste vooraf omdat het is moeilijk en kostbaar later wijzigen.</span><span class="sxs-lookup"><span data-stu-id="c0985-250">With the Table service, it's important to get the design correct up front because it's difficult and expensive to change it later.</span></span> <span data-ttu-id="c0985-251">Bijvoorbeeld in een relationele database is het vaak mogelijk prestaties om problemen te verhelpen door indexen toe te voegen aan een bestaande database: dit kan niet worden gebruikt met de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-251">For example, in a relational database it's often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</span></span>  
> 
> 

<span data-ttu-id="c0985-252">Deze sectie legt de nadruk op de belangrijkste die u houden moet bij het ontwerpen van uw tabellen voor het uitvoeren van query's.</span><span class="sxs-lookup"><span data-stu-id="c0985-252">This section focuses on the key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="c0985-253">De onderwerpen in deze sectie beschreven, zijn onder andere:</span><span class="sxs-lookup"><span data-stu-id="c0985-253">The topics covered in this section include:</span></span>

* [<span data-ttu-id="c0985-254">Hoe uw keuze van PartitionKey en RowKey van invloed is op prestaties van query 's</span><span class="sxs-lookup"><span data-stu-id="c0985-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="c0985-255">Een juiste PartitionKey kiezen</span><span class="sxs-lookup"><span data-stu-id="c0985-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="c0985-256">Optimaliseren van query's voor de tabel-service</span><span class="sxs-lookup"><span data-stu-id="c0985-256">Optimizing queries for the Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="c0985-257">Sorteren van gegevens in de tabel-service</span><span class="sxs-lookup"><span data-stu-id="c0985-257">Sorting data in the Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="c0985-258">Hoe uw keuze van PartitionKey en RowKey van invloed is op prestaties van query 's</span><span class="sxs-lookup"><span data-stu-id="c0985-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="c0985-259">De volgende voorbeelden wordt ervan uitgegaan dat de tabelservice werknemer entiteiten met de volgende structuur wordt opgeslagen (de meeste van de voorbeelden weglaten de **tijdstempel** eigenschap voor de duidelijkheid):</span><span class="sxs-lookup"><span data-stu-id="c0985-259">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="c0985-260">*Kolomnaam*</span><span class="sxs-lookup"><span data-stu-id="c0985-260">*Column name*</span></span> | <span data-ttu-id="c0985-261">*Gegevenstype*</span><span class="sxs-lookup"><span data-stu-id="c0985-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="c0985-262">**PartitionKey** (naam van de afdeling)</span><span class="sxs-lookup"><span data-stu-id="c0985-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="c0985-263">Tekenreeks</span><span class="sxs-lookup"><span data-stu-id="c0985-263">String</span></span> |
| <span data-ttu-id="c0985-264">**RowKey** (werknemer-Id)</span><span class="sxs-lookup"><span data-stu-id="c0985-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="c0985-265">Tekenreeks</span><span class="sxs-lookup"><span data-stu-id="c0985-265">String</span></span> |
| <span data-ttu-id="c0985-266">**Voornaam**</span><span class="sxs-lookup"><span data-stu-id="c0985-266">**FirstName**</span></span> |<span data-ttu-id="c0985-267">Tekenreeks</span><span class="sxs-lookup"><span data-stu-id="c0985-267">String</span></span> |
| <span data-ttu-id="c0985-268">**Achternaam**</span><span class="sxs-lookup"><span data-stu-id="c0985-268">**LastName**</span></span> |<span data-ttu-id="c0985-269">Tekenreeks</span><span class="sxs-lookup"><span data-stu-id="c0985-269">String</span></span> |
| <span data-ttu-id="c0985-270">**Leeftijd**</span><span class="sxs-lookup"><span data-stu-id="c0985-270">**Age**</span></span> |<span data-ttu-id="c0985-271">Geheel getal</span><span class="sxs-lookup"><span data-stu-id="c0985-271">Integer</span></span> |
| <span data-ttu-id="c0985-272">**EmailAddress**</span><span class="sxs-lookup"><span data-stu-id="c0985-272">**EmailAddress**</span></span> |<span data-ttu-id="c0985-273">Tekenreeks</span><span class="sxs-lookup"><span data-stu-id="c0985-273">String</span></span> |

<span data-ttu-id="c0985-274">De vorige sectie [overzicht van de service Azure Table](#overview) beschrijft een aantal van de belangrijkste functies van de service Azure Table waarvoor een directe invloed op ontwerpen voor query.</span><span class="sxs-lookup"><span data-stu-id="c0985-274">The earlier section [Azure Table service overview](#overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="c0985-275">Deze leiden tot de volgende algemene richtlijnen voor het ontwerpen van query's tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-275">These result in the following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="c0985-276">De filtersyntaxis gebruikt in de volgende voorbeelden wordt uit de tabelservice REST API, Zie voor meer informatie [Query entiteiten](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-276">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="c0985-277">Een ***punt Query*** is het meest efficiënt lookup te gebruiken en wordt aanbevolen voor grote zoekopdrachten of zoekacties laagste latentie vereisen moet worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="c0985-277">A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="c0985-278">Dergelijke query kunt de indexen gebruiken een afzonderlijke entiteit zeer efficiënt vinden door op te geven van zowel de **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-278">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-279">Bijvoorbeeld: $filter = (PartitionKey eq 'Sales') en (RowKey eq '2')</span><span class="sxs-lookup"><span data-stu-id="c0985-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="c0985-280">Tweede in de rij is een ***Bereikquery*** die gebruikmaakt van de **PartitionKey** en filters op een reeks **RowKey** waarden te retourneren van meer dan één entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-280">Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity.</span></span> <span data-ttu-id="c0985-281">De **PartitionKey** waarde identificeert een specifieke partitie en de **RowKey** waarden een subset van de entiteiten in de betreffende partitie identificeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-281">The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition.</span></span> <span data-ttu-id="c0985-282">Bijvoorbeeld: $filter = PartitionKey eq 'Verkoop en de RowKey ge' en RowKey lt t '</span><span class="sxs-lookup"><span data-stu-id="c0985-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="c0985-283">Derde beste is een ***partitie scannen*** die gebruikmaakt van de **PartitionKey** en filters op een andere niet-sleutelkenmerk eigenschap en die mogelijk meer dan één entiteit geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-283">Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="c0985-284">De **PartitionKey** waarde identificeert een specifieke partitie en de eigenschap waarden selecteren voor een subset van de entiteiten in de betreffende partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-284">The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition.</span></span> <span data-ttu-id="c0985-285">Bijvoorbeeld: $filter = PartitionKey eq 'Verkoop' en LastName eq 'Smith'</span><span class="sxs-lookup"><span data-stu-id="c0985-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="c0985-286">Een ***tabel scannen*** omvat niet de **PartitionKey** en zeer inefficiënte omdat alle van de partities die gezamenlijk uw tabel voor de overeenkomende entiteiten op zijn beurt wordt doorzocht.</span><span class="sxs-lookup"><span data-stu-id="c0985-286">A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="c0985-287">Wordt uitgevoerd om een tabelscan ongeacht of het filter gebruikt de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-287">It will perform a table scan regardless of whether or not your filter uses the **RowKey**.</span></span> <span data-ttu-id="c0985-288">Bijvoorbeeld: $filter = LastName eq 'Jones'</span><span class="sxs-lookup"><span data-stu-id="c0985-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="c0985-289">Query's die meerdere entiteiten retourneren retourneren ze gesorteerd **PartitionKey** en **RowKey** volgorde.</span><span class="sxs-lookup"><span data-stu-id="c0985-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="c0985-290">Om te voorkomen de entiteiten in de client te sorteren, kies een **RowKey** de meest voorkomende sorteervolgorde te definiëren.</span><span class="sxs-lookup"><span data-stu-id="c0985-290">To avoid resorting the entities in the client, choose a **RowKey** that defines the most common sort order.</span></span>  

<span data-ttu-id="c0985-291">Houd er rekening mee dat als u met een '**of**' om op te geven van een filter op basis van **RowKey** waarden resulteert in een partitie scan en wordt niet behandeld als een bereikquery.</span><span class="sxs-lookup"><span data-stu-id="c0985-291">Note that using an "**or**" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="c0985-292">U moet daarom query's die worden gebruikt, zoals filters: $filter = PartitionKey eq 'Sales' (RowKey eq '121' of een RowKey eq '322')</span><span class="sxs-lookup"><span data-stu-id="c0985-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="c0985-293">Zie voor voorbeelden van clientcode die gebruikmaken van de Storage-clientbibliotheek efficiënt query's uitvoeren:</span><span class="sxs-lookup"><span data-stu-id="c0985-293">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</span></span>  

* [<span data-ttu-id="c0985-294">Uitvoeren van een punt-query met behulp van de Storage-clientbibliotheek</span><span class="sxs-lookup"><span data-stu-id="c0985-294">Executing a point query using the Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="c0985-295">Bij het ophalen van meerdere entiteiten met behulp van LINQ</span><span class="sxs-lookup"><span data-stu-id="c0985-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="c0985-296">Projectie-serverzijde</span><span class="sxs-lookup"><span data-stu-id="c0985-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="c0985-297">Voor voorbeelden van clientcode dat meerdere Entiteitstypen die zijn opgeslagen in dezelfde tabel kan verwerken, Zie:</span><span class="sxs-lookup"><span data-stu-id="c0985-297">For examples of client-side code that can handle multiple entity types stored in the same table, see:</span></span>  

* [<span data-ttu-id="c0985-298">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="c0985-299">Een juiste PartitionKey kiezen</span><span class="sxs-lookup"><span data-stu-id="c0985-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="c0985-300">Uw keuze van **PartitionKey** moet worden verdeeld moet maakt het gebruik van EGTs (consistentie te garanderen) de vereiste voor de distributie van de entiteiten over meerdere partities (zodat een schaalbare oplossing).</span><span class="sxs-lookup"><span data-stu-id="c0985-300">Your choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</span></span>  

<span data-ttu-id="c0985-301">Op één extreme u alle entiteiten in uw kan opslaan in een enkele partitie, maar dit kan de schaalbaarheid van uw oplossing beperken en zou voorkomen dat de tabelservice kunnen verdelen aanvragen.</span><span class="sxs-lookup"><span data-stu-id="c0985-301">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</span></span> <span data-ttu-id="c0985-302">Het andere uiterste, kunt u één entiteit per partitie, die wel uiterst schaalbare en waardoor de tabelservice op aanvragen voor taakverdeling, maar dat zou voorkomen dat u entiteitstransacties opslaan.</span><span class="sxs-lookup"><span data-stu-id="c0985-302">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="c0985-303">Een ideaal **PartitionKey** is een die u kunt gebruiken efficiënt query's en met voldoende partities om te controleren of uw oplossing schaalbaar is.</span><span class="sxs-lookup"><span data-stu-id="c0985-303">An ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</span></span> <span data-ttu-id="c0985-304">Normaal gesproken zult u merken dat uw entiteiten een geschikte eigenschap die de entiteiten over voldoende partities verdeelt hebben.</span><span class="sxs-lookup"><span data-stu-id="c0985-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="c0985-305">Bijvoorbeeld in een systeem dat wordt informatie over gebruikers- of werknemers opgeslagen, gebruikers-id is mogelijk een goede PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="c0985-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="c0985-306">Mogelijk hebt u verschillende entiteiten die een opgegeven gebruikers-id als de partitiesleutel gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-306">You may have several entities that use a given UserID as the partition key.</span></span> <span data-ttu-id="c0985-307">Elke entiteit die gegevens over een gebruiker opslaat in een enkele partitie worden gegroepeerd en dus deze entiteiten zijn toegankelijk via entiteit groepstransacties, terwijl u nog steeds zeer schaalbaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="c0985-308">Er zijn aanvullende overwegingen bij de keuze van **PartitionKey** die betrekking hebben op hoe u wilt invoegen, bijwerken en verwijderen van entiteiten: Zie de sectie [ontwerp voor wijziging van gegevens](#design-for-data-modification) hieronder.</span><span class="sxs-lookup"><span data-stu-id="c0985-308">There are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-the-table-service"></a><span data-ttu-id="c0985-309">Optimaliseren van query's voor de tabel-service</span><span class="sxs-lookup"><span data-stu-id="c0985-309">Optimizing queries for the Table service</span></span>
<span data-ttu-id="c0985-310">De tabelservice indexeert automatisch de entiteiten met behulp van de **PartitionKey** en **RowKey** waarden in een enkele geclusterde index, daarom de reden dat wijst u query's zijn het meest efficiënt te gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-310">The Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use.</span></span> <span data-ttu-id="c0985-311">Er zijn echter geen indexen dan die op de geclusterde index op de **PartitionKey** en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-311">However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="c0985-312">Veel ontwerpen moeten voldoen aan de vereisten voor het opzoeken van de entiteiten die zijn gebaseerd op meerdere criteria inschakelen.</span><span class="sxs-lookup"><span data-stu-id="c0985-312">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="c0985-313">Bijvoorbeeld zoeken naar werknemer entiteiten op basis van e-mailadres werknemer-id of achternaam op.</span><span class="sxs-lookup"><span data-stu-id="c0985-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="c0985-314">De volgende patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) deze typen vereiste op te lossen en beschrijven manieren van het feit dat de tabel-service biedt geen secundaire indexen te omzeilen:</span><span class="sxs-lookup"><span data-stu-id="c0985-314">The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="c0985-315">[Intra-partitie secundaire index patroon](#intra-partition-secondary-index-pattern) -opslaan meerdere exemplaren van elke entiteit met behulp van verschillende **RowKey** waarden (in dezelfde partitie) inschakelen snel en efficiënt zoekacties en alternatieve sorteervolgorde met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="c0985-316">[Secundaire tussen partitioneren van index patroon](#inter-partition-secondary-index-pattern) : opslaan van meerdere exemplaren van elke entiteit die gebruikmaken van verschillende waarden voor de RowKey in afzonderlijke partities of in afzonderlijke tabellen waarmee snel en efficiënt zoekacties en alternatieve sorteren orders met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="c0985-317">[Index entiteiten patroon](#index-entities-pattern) -onderhouden index entiteiten zodat efficiënte zoekopdrachten die lijsten van entiteiten retourneren.</span><span class="sxs-lookup"><span data-stu-id="c0985-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-the-table-service"></a><span data-ttu-id="c0985-318">Sorteren van gegevens in de tabel-service</span><span class="sxs-lookup"><span data-stu-id="c0985-318">Sorting data in the Table service</span></span>
<span data-ttu-id="c0985-319">De tabel-service retourneert entiteiten in oplopende volgorde op basis van gesorteerd **PartitionKey** en vervolgens op **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-319">The Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="c0985-320">Deze sleutels worden tekenreekswaarden en om ervoor te zorgen dat numerieke waarden correct sorteren, moet u deze converteren naar een vaste lengte en ze worden opgevuld met nullen.</span><span class="sxs-lookup"><span data-stu-id="c0985-320">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</span></span> <span data-ttu-id="c0985-321">Bijvoorbeeld, als de waarde van de werknemer-id die u gebruikt als de **RowKey** is een geheel getal, moet u de werknemer-id converteren **123** naar **00000123**.</span><span class="sxs-lookup"><span data-stu-id="c0985-321">For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.</span></span>  

<span data-ttu-id="c0985-322">Veel toepassingen hebben vereisten voor het gebruik van gegevens in verschillende volgorden gesorteerd: werknemers bijvoorbeeld sorteren op naam of door datum.</span><span class="sxs-lookup"><span data-stu-id="c0985-322">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="c0985-323">De volgende patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) hoe de sorteervolgorde voor uw entiteiten alternatieve adres:</span><span class="sxs-lookup"><span data-stu-id="c0985-323">The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:</span></span>  

* <span data-ttu-id="c0985-324">[Intra-partitie secundaire index patroon](#intra-partition-secondary-index-pattern) : opslaan van meerdere exemplaren van elke entiteit die gebruikmaken van verschillende RowKey waarden (in dezelfde partitie) waarmee snel en efficiënt zoekacties en alternatieve sorteren orders met behulp van verschillende RowKey waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="c0985-325">[Secundaire tussen partitioneren van index patroon](#inter-partition-secondary-index-pattern) : opslaan van meerdere exemplaren van elke entiteit met verschillende waarden voor de RowKey in afzonderlijke partities in afzonderlijke tabellen inschakelen snel en efficiënt zoekacties en alternatieve sorteren bestellingen met behulp van verschillende RowKey waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="c0985-326">[Logboek tail patroon](#log-tail-pattern) -ophalen van de  *n*  entiteiten die onlangs zijn toegevoegd aan een partitie met behulp van een **RowKey** waarde die in omgekeerde datum en tijd volgorde worden gesorteerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-326">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="c0985-327">Ontwerp voor wijziging van gegevens</span><span class="sxs-lookup"><span data-stu-id="c0985-327">Design for data modification</span></span>
<span data-ttu-id="c0985-328">Deze sectie richt zich op de ontwerpoverwegingen voor het optimaliseren van toevoegingen, updates, en worden verwijderd.</span><span class="sxs-lookup"><span data-stu-id="c0985-328">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="c0985-329">In sommige gevallen moet u de verhouding tussen ontwerpen die optimaliseren voor een query op modellen die voor wijziging van gegevens, optimaliseren net als in ontwerpen voor relationele databases (Hoewel de technieken voor het beheren van de ontwerp-en nadelen andere in een relationele database) evalueren.</span><span class="sxs-lookup"><span data-stu-id="c0985-329">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</span></span> <span data-ttu-id="c0985-330">De sectie [ontwerppatronen voor tabel](#table-design-patterns) beschrijft een aantal gedetailleerde ontwerppatronen voor de tabel-service en worden enkele deze verschillen.</span><span class="sxs-lookup"><span data-stu-id="c0985-330">The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="c0985-331">In de praktijk vindt u veel ontwerpen die zijn geoptimaliseerd voor het uitvoeren van query's entiteiten ook geschikt voor entiteiten wijzigen.</span><span class="sxs-lookup"><span data-stu-id="c0985-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="c0985-332">Optimaliseren van de prestaties van invoegen, bijwerken en verwijderen van bewerkingen</span><span class="sxs-lookup"><span data-stu-id="c0985-332">Optimizing the performance of insert, update, and delete operations</span></span>
<span data-ttu-id="c0985-333">Als u wilt bijwerken of verwijderen van een entiteit, moet u kunnen worden geïdentificeerd met behulp van de **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-333">To update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-334">In dit opzicht van uw keuze **PartitionKey** en **RowKey** voor entiteiten wijzigen dezelfde criteria voor uw keuze volgen moet voor de ondersteuning van punt query's omdat u wilt identificeren entiteiten zo efficiënt mogelijk.</span><span class="sxs-lookup"><span data-stu-id="c0985-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</span></span> <span data-ttu-id="c0985-335">U niet wilt dat een entiteit Zoek om te detecteren met behulp van een inefficiënte partitie of tabel scan de **PartitionKey** en **RowKey** waarden die u wilt bijwerken of verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-335">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.</span></span>  

<span data-ttu-id="c0985-336">De volgende patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) adres optimaliseert de prestaties of de insert, update en verwijderbewerkingen:</span><span class="sxs-lookup"><span data-stu-id="c0985-336">The following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="c0985-337">[Hoog volume patroon verwijderen](#high-volume-delete-pattern) -de verwijdering van een groot aantal entiteiten inschakelen door het opslaan van alle entiteiten voor gelijktijdige verwijdering in hun eigen afzonderlijke tabel; u de entiteiten verwijderen door de tabel verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  
* <span data-ttu-id="c0985-338">[Patroon van de reeks gegevens](#data-series-pattern) -Store voltooid gegevensreeksen in één entiteit om te beperken het aantal aanvragen die u aanbrengt.</span><span class="sxs-lookup"><span data-stu-id="c0985-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  
* <span data-ttu-id="c0985-339">[Wide entiteiten patroon](#wide-entities-pattern) -gebruik van meerdere fysieke entiteiten voor het opslaan van logische entiteiten met meer dan 252 eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c0985-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="c0985-340">[Grote entiteiten patroon](#large-entities-pattern) -blob storage gebruiken voor het opslaan van grote eigenschapswaarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-340">[Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="c0985-341">Uw opgeslagen entiteiten consistent te houden</span><span class="sxs-lookup"><span data-stu-id="c0985-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="c0985-342">De andere belangrijke factoren die van invloed is op uw keuze van sleutels voor het optimaliseren van gegevenswijzigingen is hoe u de consistentie met behulp van atomische transacties.</span><span class="sxs-lookup"><span data-stu-id="c0985-342">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</span></span> <span data-ttu-id="c0985-343">U kunt alleen een EGT bewerkingen uitvoeren op entiteiten die zijn opgeslagen in dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-343">You can only use an EGT to operate on entities stored in the same partition.</span></span>  

<span data-ttu-id="c0985-344">De volgende patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) adres consistentie beheren:</span><span class="sxs-lookup"><span data-stu-id="c0985-344">The following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="c0985-345">[Intra-partitie secundaire index patroon](#intra-partition-secondary-index-pattern) -opslaan meerdere exemplaren van elke entiteit met behulp van verschillende **RowKey** waarden (in dezelfde partitie) inschakelen snel en efficiënt zoekacties en alternatieve sorteervolgorde met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="c0985-346">[Secundaire tussen partitioneren van index patroon](#inter-partition-secondary-index-pattern) : opslaan van meerdere exemplaren van elke entiteit die gebruikmaken van verschillende waarden voor de RowKey in afzonderlijke partities of in afzonderlijke tabellen waarmee snel en efficiënt zoekacties en alternatieve sorteren orders met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="c0985-347">[Uiteindelijk consistent transacties patroon](#eventually-consistent-transactions-pattern) -uiteindelijk consistent gedrag over grenzen van partities of opslag system grenzen inschakelen met behulp van Azure wachtrijen.</span><span class="sxs-lookup"><span data-stu-id="c0985-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="c0985-348">[Index entiteiten patroon](#index-entities-pattern) -onderhouden index entiteiten zodat efficiënte zoekopdrachten die lijsten van entiteiten retourneren.</span><span class="sxs-lookup"><span data-stu-id="c0985-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="c0985-349">[Denormalization patroon](#denormalization-pattern) -combineren van de bijbehorende gegevens samen in één entiteit waarmee u kunt alle gegevens die u nodig hebt met een query één punt ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  
* <span data-ttu-id="c0985-350">[Patroon van de reeks gegevens](#data-series-pattern) -Store voltooid gegevensreeksen in één entiteit om te beperken het aantal aanvragen die u aanbrengt.</span><span class="sxs-lookup"><span data-stu-id="c0985-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

<span data-ttu-id="c0985-351">Zie de sectie voor informatie over entiteit groepstransacties [entiteit groepstransacties](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="c0985-351">For information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="c0985-352">Uw ontwerp voor efficiënte wijzigingen gezorgd vereenvoudigt efficiënt query 's</span><span class="sxs-lookup"><span data-stu-id="c0985-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="c0985-353">Een ontwerp voor een efficiënte query resulteert in efficiënt wijzigingen, maar u moet altijd in veel gevallen evalueren of dit het geval is voor uw specifieke scenario.</span><span class="sxs-lookup"><span data-stu-id="c0985-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</span></span> <span data-ttu-id="c0985-354">Sommige van de patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) expliciet evalueren verschillen tussen het uitvoeren van query's en entiteiten wijzigen en u moet altijd rekening gehouden met het nummer van elk type bewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-354">Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</span></span>  

<span data-ttu-id="c0985-355">De volgende patronen in de sectie [ontwerppatronen voor tabel](#table-design-patterns) adres verschillen tussen ontwerpen voor efficiënt query's en ontwerpen voor wijziging van efficiënte gegevens:</span><span class="sxs-lookup"><span data-stu-id="c0985-355">The following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="c0985-356">[Samengestelde sleutelpatroon](#compound-key-pattern) -gebruik samengestelde **RowKey** waarden om in te schakelen van een client voor het opzoeken van gerelateerde gegevens met een query één punt.</span><span class="sxs-lookup"><span data-stu-id="c0985-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  
* <span data-ttu-id="c0985-357">[Logboek tail patroon](#log-tail-pattern) -ophalen van de  *n*  entiteiten die onlangs zijn toegevoegd aan een partitie met behulp van een **RowKey** waarde die in omgekeerde datum en tijd volgorde worden gesorteerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-357">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="c0985-358">Versleuteling van tabelgegevens</span><span class="sxs-lookup"><span data-stu-id="c0985-358">Encrypting Table Data</span></span>
<span data-ttu-id="c0985-359">De .NET Azure Storage-clientbibliotheek biedt ondersteuning voor versleuteling van entiteitseigenschappen tekenreeks voor invoegen en vervang bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-359">The .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="c0985-360">De versleutelde tekenreeksen worden opgeslagen op de service als binaire eigenschappen en ze worden geconverteerd naar tekenreeksen na de decodering.</span><span class="sxs-lookup"><span data-stu-id="c0985-360">The encrypted strings are stored on the service as binary properties, and they are converted back to strings after decryption.</span></span>    

<span data-ttu-id="c0985-361">Gebruikers moeten de eigenschappen moeten worden gecodeerd opgeven voor tabellen, naast het coderingsbeleid.</span><span class="sxs-lookup"><span data-stu-id="c0985-361">For tables, in addition to the encryption policy, users must specify the properties to be encrypted.</span></span> <span data-ttu-id="c0985-362">Dit kan worden gedaan door een kenmerk [EncryptProperty] (voor POCO-entiteiten die zijn afgeleid van TableEntity) of een omzetter versleuteling in de aanvraag-opties.</span><span class="sxs-lookup"><span data-stu-id="c0985-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="c0985-363">Een oplossing versleuteling is een gemachtigde die ervoor zorgt dat een partitiesleutel, rijsleutel en de naam van eigenschap retourneert een Booleaanse waarde die aangeeft of de eigenschap die moet worden versleuteld.</span><span class="sxs-lookup"><span data-stu-id="c0985-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="c0985-364">Tijdens het versleutelen gebruik de clientbibliotheek van deze informatie om te bepalen of een eigenschap tijdens het schrijven naar de kabel moet worden versleuteld.</span><span class="sxs-lookup"><span data-stu-id="c0985-364">During encryption, the client library will use this information to decide whether a property should be encrypted while writing to the wire.</span></span> <span data-ttu-id="c0985-365">De gemachtigde biedt ook de mogelijkheid van logica over hoe eigenschappen zijn gecodeerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-365">The delegate also provides for the possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="c0985-366">(Bijvoorbeeld als X, vervolgens versleutelen eigenschap A; anders versleutelen eigenschappen A en B.) Houd er rekening mee dat het is niet nodig om deze informatie tijdens het lezen of het uitvoeren van query's entiteiten te geven.</span><span class="sxs-lookup"><span data-stu-id="c0985-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary to provide this information while reading or querying entities.</span></span>

<span data-ttu-id="c0985-367">Houd er rekening mee dat samenvoegen wordt momenteel niet ondersteund.</span><span class="sxs-lookup"><span data-stu-id="c0985-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="c0985-368">Omdat een subset van eigenschappen mogelijk zijn versleuteld eerder met een andere sleutel, leidt gewoon de nieuwe eigenschappen samenvoegen en bijwerken van de metagegevens tot verlies van gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-368">Since a subset of properties may have been encrypted previously using a different key, simply merging the new properties and updating the metadata will result in data loss.</span></span> <span data-ttu-id="c0985-369">Samenvoegen van een vereist extra service aanroepen om te lezen van de vooraf bestaande entiteit van de service of met een nieuwe sleutel per eigenschap, die beide zijn niet geschikt voor betere prestaties.</span><span class="sxs-lookup"><span data-stu-id="c0985-369">Merging either requires making extra service calls to read the pre-existing entity from the service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="c0985-370">Zie voor meer informatie over het coderen van tabelgegevens [Client-Side-versleuteling en Azure Key Vault voor Microsoft Azure Storage](../storage/common/storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="c0985-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](../storage/common/storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="c0985-371">Modellering van relaties</span><span class="sxs-lookup"><span data-stu-id="c0985-371">Modelling relationships</span></span>
<span data-ttu-id="c0985-372">Ontwikkelen van domeinmodellen is een belangrijke stap in het ontwerp van complexe systemen.</span><span class="sxs-lookup"><span data-stu-id="c0985-372">Building domain models is a key step in the design of complex systems.</span></span> <span data-ttu-id="c0985-373">U kunt gewoonlijk modellen proces gebruiken om entiteiten en de relaties tussen deze als een manier om te begrijpen van het domein voor bedrijven en informeren over het ontwerp van uw systeem te identificeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-373">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</span></span> <span data-ttu-id="c0985-374">Deze sectie richt zich op hoe Vertaal enkele van de algemene relatietypen gevonden in domeinmodellen ontwerpen voor de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-374">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</span></span> <span data-ttu-id="c0985-375">Het proces van toewijzing van een logische gegevensmodel aan een fysieke basis NoSQL-gegevensmodel is heel verschillend van die gebruikt bij het ontwerpen van een relationele database.</span><span class="sxs-lookup"><span data-stu-id="c0985-375">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="c0985-376">Relationele databases ontwerp neemt doorgaans een gegevens-normalisatie-proces geoptimaliseerd voor het minimaliseren van redundantie – en een declaratieve opvragen capaciteit die isoleert hoe de uitvoering van hoe u de database werkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="c0985-377">Een-op-veel-relaties</span><span class="sxs-lookup"><span data-stu-id="c0985-377">One-to-many relationships</span></span>
<span data-ttu-id="c0985-378">Een-op-veel-relaties tussen bedrijven domeinobjecten heel vaak gebeuren: één afdeling heeft bijvoorbeeld veel werknemers.</span><span class="sxs-lookup"><span data-stu-id="c0985-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="c0985-379">Er zijn verschillende manieren voor het implementeren van een-op-veel-relaties in de tabelservice elke met de voor- en nadelen die relevant voor een bepaald scenario zijn mogelijk.</span><span class="sxs-lookup"><span data-stu-id="c0985-379">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</span></span>  

<span data-ttu-id="c0985-380">Bekijk het voorbeeld van een grote onderneming met meerdere nationale met tienduizenden afdelingen en werknemer entiteiten waar elke afdeling heeft veel werknemers en elke werknemer die gekoppeld is aan een bepaalde afdeling.</span><span class="sxs-lookup"><span data-stu-id="c0985-380">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="c0985-381">Een aanpak is het opslaan van afzonderlijke afdeling en entiteiten van de werknemer zoals deze:</span><span class="sxs-lookup"><span data-stu-id="c0985-381">One approach is to store separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="c0985-382">Dit voorbeeld ziet u een impliciete een-op-veel-relatie tussen de typen op basis van de **PartitionKey** waarde.</span><span class="sxs-lookup"><span data-stu-id="c0985-382">This example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value.</span></span> <span data-ttu-id="c0985-383">Elke afdeling kan veel werknemers hebben.</span><span class="sxs-lookup"><span data-stu-id="c0985-383">Each department can have many employees.</span></span>  

<span data-ttu-id="c0985-384">In dit voorbeeld toont ook een entiteit afdeling en de gerelateerde werknemer entiteiten in dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-384">This example also shows a department entity and its related employee entities in the same partition.</span></span> <span data-ttu-id="c0985-385">U kunt verschillende partities, tabellen of zelfs storage-accounts gebruiken voor de verschillende entiteittypen.</span><span class="sxs-lookup"><span data-stu-id="c0985-385">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</span></span>  

<span data-ttu-id="c0985-386">Er is een alternatieve methode denormalize van uw gegevens en store-alleen werknemer entiteiten met gedenormaliseerd afdelingsgegevens zoals weergegeven in het volgende voorbeeld.</span><span class="sxs-lookup"><span data-stu-id="c0985-386">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</span></span> <span data-ttu-id="c0985-387">In dit specifieke scenario gedenormaliseerd hiervan mogelijk niet het beste als er een vereiste kunnen de details van een afdelingsmanager niet wijzigen omdat hiervoor moet u elke werknemer van de afdeling bijwerken.</span><span class="sxs-lookup"><span data-stu-id="c0985-387">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</span></span>  

![][2]

<span data-ttu-id="c0985-388">Zie voor meer informatie de [Denormalization patroon](#denormalization-pattern) verderop in deze handleiding.</span><span class="sxs-lookup"><span data-stu-id="c0985-388">For more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="c0985-389">De volgende tabel geeft een overzicht van de voordelen en nadelen van elk van de methoden die hierboven worden beschreven voor het opslaan van de werknemer en afdeling entiteiten met een-op-veel-relatie een.</span><span class="sxs-lookup"><span data-stu-id="c0985-389">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="c0985-390">U moet ook overwegen hoe vaak verwacht u dat kunt u verschillende bewerkingen uitvoeren: kan het zijn aanvaardbaar is voor een ontwerp waarin een dure bewerking als die voor deze bewerking alleen zelden gebeurt hebben.</span><span class="sxs-lookup"><span data-stu-id="c0985-390">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="c0985-391">Benadering</span><span class="sxs-lookup"><span data-stu-id="c0985-391">Approach</span></span></th>
<th><span data-ttu-id="c0985-392">Professionals</span><span class="sxs-lookup"><span data-stu-id="c0985-392">Pros</span></span></th>
<th><span data-ttu-id="c0985-393">Nadelen</span><span class="sxs-lookup"><span data-stu-id="c0985-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-394">Afzonderlijke Entiteitstypen, dezelfde partitie, dezelfde tabel</span><span class="sxs-lookup"><span data-stu-id="c0985-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="c0985-395">U kunt een entiteit afdeling bijwerken met één bewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="c0985-396">U kunt een EGT om consistentie te behouden als u een vereiste voor het wijzigen van een entiteit afdeling hebt wanneer u update, invoegen, verwijderen een werknemer entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-396">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="c0985-397">Bijvoorbeeld als u een aantal afdelingen medewerkers voor elke afdeling onderhouden.</span><span class="sxs-lookup"><span data-stu-id="c0985-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="c0985-398">Mogelijk moet u een entiteit van de afdeling voor sommige activiteiten van de client en een werknemer worden opgehaald.</span><span class="sxs-lookup"><span data-stu-id="c0985-398">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="c0985-399">Opslagbewerkingen gebeuren op dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-399">Storage operations happen in the same partition.</span></span> <span data-ttu-id="c0985-400">Hoge transactie volumes, kan dit resulteren in een hotspot.</span><span class="sxs-lookup"><span data-stu-id="c0985-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="c0985-401">U kunt een werknemer niet verplaatsen naar een nieuwe afdeling met behulp van een EGT.</span><span class="sxs-lookup"><span data-stu-id="c0985-401">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="c0985-402">Afzonderlijke Entiteitstypen, verschillende partities of tabellen of storage-accounts</span><span class="sxs-lookup"><span data-stu-id="c0985-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="c0985-403">U kunt een entiteit van de afdeling of de werknemer entiteit bijwerken met één bewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="c0985-404">Op hoog transactie volumes, kan dit helpen de werklast verdeeld over meer partities.</span><span class="sxs-lookup"><span data-stu-id="c0985-404">At high transaction volumes, this may help spread the load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="c0985-405">Mogelijk moet u een entiteit van de afdeling voor sommige activiteiten van de client en een werknemer worden opgehaald.</span><span class="sxs-lookup"><span data-stu-id="c0985-405">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="c0985-406">U kunt EGTs niet gebruiken om consistentie te behouden wanneer u update, invoegen, verwijderen van een werknemer en update een afdeling.</span><span class="sxs-lookup"><span data-stu-id="c0985-406">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="c0985-407">Een aantal werknemers in een entiteit afdeling bijvoorbeeld wordt bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="c0985-408">U kunt een werknemer niet verplaatsen naar een nieuwe afdeling met behulp van een EGT.</span><span class="sxs-lookup"><span data-stu-id="c0985-408">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="c0985-409">Denormalize in één entiteitstype</span><span class="sxs-lookup"><span data-stu-id="c0985-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="c0985-410">U kunt alle informatie die u nodig hebt met één aanvraag ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-410">You can retrieve all the information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="c0985-411">Het is mogelijk dure om consistentie te behouden als u bijwerken afdelingsgegevens wilt (dit vereist bij te werken van alle werknemers in een afdeling).</span><span class="sxs-lookup"><span data-stu-id="c0985-411">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="c0985-412">Hoe u kiezen tussen deze opties en welke van de voor- en nadelen zijn de meest significante, is afhankelijk van uw specifieke toepassingsscenario's.</span><span class="sxs-lookup"><span data-stu-id="c0985-412">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="c0985-413">Bijvoorbeeld, hoe vaak u Wijzig afdeling entiteiten; moeten alle werknemers-query's de afdelingen aanvullende informatie; hoe sluiten weet u de limieten voor schaalbaarheid van de partities of uw storage-account?</span><span class="sxs-lookup"><span data-stu-id="c0985-413">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="c0985-414">-Op-een-relaties</span><span class="sxs-lookup"><span data-stu-id="c0985-414">One-to-one relationships</span></span>
<span data-ttu-id="c0985-415">Domeinmodellen kunnen-op-een-relaties tussen entiteiten bevatten.</span><span class="sxs-lookup"><span data-stu-id="c0985-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="c0985-416">Als u nodig hebt voor het implementeren van een-op-een relatie in de tabel-service, moet u ook het koppelen van de twee gerelateerde entiteiten wanneer moet u beide ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-416">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</span></span> <span data-ttu-id="c0985-417">Deze koppeling kan impliciete, op basis van een overeenkomst in de sleutelwaarden of expliciete worden door het opslaan van een koppeling in de vorm van **PartitionKey** en **RowKey** waarden in elke entiteit naar de gerelateerde entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-417">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity.</span></span> <span data-ttu-id="c0985-418">Zie de sectie voor een bespreking van of moet u de gerelateerde entiteiten opslaan op dezelfde partitie [een-op-veel relaties](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="c0985-418">For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="c0985-419">Houd er rekening mee dat er zijn ook overwegingen bij de implementatie die kunnen leiden bij de implementatie-op-een-relaties in de tabel-service:</span><span class="sxs-lookup"><span data-stu-id="c0985-419">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</span></span>  

* <span data-ttu-id="c0985-420">Verwerking van grote entiteiten (Zie voor meer informatie [grote entiteiten patroon](#large-entities-pattern)).</span><span class="sxs-lookup"><span data-stu-id="c0985-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="c0985-421">Toegangsbeheer implementeren (Zie voor meer informatie [beheren van toegang met Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span><span class="sxs-lookup"><span data-stu-id="c0985-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-the-client"></a><span data-ttu-id="c0985-422">Deelnemen aan de client</span><span class="sxs-lookup"><span data-stu-id="c0985-422">Join in the client</span></span>
<span data-ttu-id="c0985-423">Hoewel er manieren om relaties in de tabel-service, moet u niet vergeet dat de twee belangrijkste redenen voor het gebruik van de tabelservice schaalbaarheid en prestaties zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-423">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</span></span> <span data-ttu-id="c0985-424">Als u dat u veel-relaties die een bedreiging vormen van de prestaties en schaalbaarheid van uw oplossing zijn modellering vindt, vraagt u uzelf als het is nodig om alle gegevensrelaties in uw tabelontwerp samen te stellen.</span><span class="sxs-lookup"><span data-stu-id="c0985-424">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</span></span> <span data-ttu-id="c0985-425">U kunt mogelijk het ontwerp te vereenvoudigen en verbeteren van de schaalbaarheid en prestaties van uw oplossing als u toestaat dat de clienttoepassing alle benodigde joins uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-425">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="c0985-426">Bijvoorbeeld, als er kleine tabellen die gegevens bevatten die niet vaak veranderen, kunt vervolgens u deze gegevens eenmaal ophalen en cache te plaatsen op de client.</span><span class="sxs-lookup"><span data-stu-id="c0985-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</span></span> <span data-ttu-id="c0985-427">Dit kunt voorkomen dat herhaalde interactie om op te halen van dezelfde gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-427">This can avoid repeated roundtrips to retrieve the same data.</span></span> <span data-ttu-id="c0985-428">In de voorbeelden die we in deze handleiding hebt bekeken, heeft de reeks afdelingen in een kleine organisatie waarschijnlijk klein en wijzig zelden waardoor het een goede kandidaat voor de gegevens eenmaal in client-toepassing kan worden gedownload en cache als opzoeken van gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-428">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="c0985-429">Relaties voor overname</span><span class="sxs-lookup"><span data-stu-id="c0985-429">Inheritance relationships</span></span>
<span data-ttu-id="c0985-430">Als u de clienttoepassing gebruikmaakt van een set klassen die deel uitmaken van een overnamerelatie bedrijfsentiteiten vertegenwoordigt, kunt u eenvoudig deze entiteiten in de tabel-service behouden.</span><span class="sxs-lookup"><span data-stu-id="c0985-430">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</span></span> <span data-ttu-id="c0985-431">Bijvoorbeeld, u wellicht de volgende set van klassen die zijn gedefinieerd in uw clienttoepassing waar **persoon** is een abstracte klasse.</span><span class="sxs-lookup"><span data-stu-id="c0985-431">For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="c0985-432">U kunt deze persistent maken exemplaren van de twee concrete klassen in de tabel-service met één personentabel met entiteiten in die zijn opgemaakt als volgt:</span><span class="sxs-lookup"><span data-stu-id="c0985-432">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="c0985-433">Zie de sectie voor meer informatie over het werken met meerdere Entiteitstypen in dezelfde tabel in de clientcode [werken met heterogene Entiteitstypen](#working-with-heterogeneous-entity-types) verderop in deze handleiding.</span><span class="sxs-lookup"><span data-stu-id="c0985-433">For more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="c0985-434">Dit vindt u voorbeelden van het herkennen van het entiteitstype in de clientcode.</span><span class="sxs-lookup"><span data-stu-id="c0985-434">This provides examples of how to recognize the entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="c0985-435">Ontwerppatronen voor tabel</span><span class="sxs-lookup"><span data-stu-id="c0985-435">Table Design Patterns</span></span>
<span data-ttu-id="c0985-436">U hebt gezien gedetailleerde discussies over het optimaliseren van uw tabelontwerp voor beide entiteitsgegevens op te halen met behulp van query's en voor het invoegen, bijwerken en verwijderen van entiteitsgegevens in de vorige secties.</span><span class="sxs-lookup"><span data-stu-id="c0985-436">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="c0985-437">Deze sectie beschrijft een aantal patronen geschikt voor gebruik met oplossingen voor tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="c0985-438">Bovendien ziet u hoe u enkele van de problemen en een afweging maken wat eerder in deze handleiding worden gegenereerd op vrijwel kunt oplossen.</span><span class="sxs-lookup"><span data-stu-id="c0985-438">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="c0985-439">Het volgende diagram geeft een overzicht van de relaties tussen de verschillende patronen:</span><span class="sxs-lookup"><span data-stu-id="c0985-439">The following diagram summarizes the relationships between the different patterns:</span></span>  

![][5]

<span data-ttu-id="c0985-440">De kaart patroon hierboven licht sommige relaties tussen patronen (blauw) en anti patronen (oranje) die in deze handleiding worden beschreven.</span><span class="sxs-lookup"><span data-stu-id="c0985-440">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="c0985-441">Er zijn natuurlijk veel andere patronen die moeten overwogen worden.</span><span class="sxs-lookup"><span data-stu-id="c0985-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="c0985-442">Bijvoorbeeld, een van de belangrijkste scenario's voor tabel-Service is met de [gematerialiseerd weergave patroon](https://msdn.microsoft.com/library/azure/dn589782.aspx) van de [opdracht Query verantwoordelijkheid scheiding (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) patroon.</span><span class="sxs-lookup"><span data-stu-id="c0985-442">For example, one of the key scenarios for Table Service is to use the [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="c0985-443">Intra-partitie secundaire index patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="c0985-444">Opslaan van meerdere exemplaren van elke entiteit met behulp van verschillende **RowKey** waarden (in dezelfde partitie) inschakelen snel en efficiënt zoekacties en alternatieve sorteervolgorde met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-444">Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="c0985-445">Updates tussen kopieën consistent kunnen worden gehouden met behulp van EGT.</span><span class="sxs-lookup"><span data-stu-id="c0985-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-446">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-446">Context and problem</span></span>
<span data-ttu-id="c0985-447">De tabelservice indexeert automatisch entiteiten met behulp van de **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-447">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-448">Dit kan een clienttoepassing voor het ophalen van een entiteit efficiënt gebruik maakt van deze waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-448">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="c0985-449">Bijvoorbeeld, met de structuur van de tabel hieronder wordt weergegeven, een clienttoepassing kunt gebruiken een punt-query voor een afzonderlijke werknemer entiteit ophalen met de afdelingsnaam van de en de werknemer-id (de **PartitionKey** en **RowKey** waarden).</span><span class="sxs-lookup"><span data-stu-id="c0985-449">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="c0985-450">Een client kan ook gesorteerd op werknemer-id binnen elke afdeling entiteiten ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="c0985-451">Als u ook kunnen wilt vinden van een werknemer entiteit op basis van de waarde van een andere eigenschap, zoals e-mailadres, moet u een minder efficiënte partitie scan te vinden.</span><span class="sxs-lookup"><span data-stu-id="c0985-451">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="c0985-452">Dit is omdat de tabelservice geen secundaire indexen biedt.</span><span class="sxs-lookup"><span data-stu-id="c0985-452">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="c0985-453">Er is bovendien geen optie voor het aanvragen van een lijst met werknemers gesorteerd in een andere volgorde dan **RowKey** volgorde.</span><span class="sxs-lookup"><span data-stu-id="c0985-453">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-454">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-454">Solution</span></span>
<span data-ttu-id="c0985-455">U kunt het ontbreken van een secundaire indexen omzeilen, kunt u meerdere exemplaren van elke entiteit bij elk exemplaar met een andere opslaan **RowKey** waarde.</span><span class="sxs-lookup"><span data-stu-id="c0985-455">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="c0985-456">Als u een entiteit met de onderstaande structuren opslaat, kunt u efficiënt werknemer entiteiten op basis van e-adres of de werknemer-id ophalen. Het voorvoegsel waarden voor de **RowKey**, 'empid_' en 'email_', kunt u zoeken naar één werknemer of een bereik van werknemers met behulp van een bereik van e-mailadressen of werknemer-id's.</span><span class="sxs-lookup"><span data-stu-id="c0985-456">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **RowKey**, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="c0985-457">De volgende twee filtercriteria (één opzoeken op basis van de werknemer-id en een opzoeken op basis van e-mailadres) Geef beide punt query's:</span><span class="sxs-lookup"><span data-stu-id="c0985-457">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="c0985-458">$filter = (PartitionKey eq 'Sales') en (RowKey eq 'empid_000223')</span><span class="sxs-lookup"><span data-stu-id="c0985-458">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="c0985-459">$filter = (PartitionKey eq 'Sales') en (RowKey eq 'email_jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="c0985-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="c0985-460">Als u een query voor een bereik van de werknemer entiteiten uitvoert, kunt u een bereik gesorteerd in volgorde van de werknemer-id of een bereik in e-mailadres volgorde gesorteerd op basis van een query uitvoert voor entiteiten met het juiste voorvoegsel op in de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-460">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="c0985-461">Alle medewerkers vinden in de afdeling verkoop met een werknemer-id in het bereik 000100-000199 gebruik: $filter = (PartitionKey eq 'Sales') en (RowKey ge 'empid_000100') en (RowKey RP 'empid_000199')</span><span class="sxs-lookup"><span data-stu-id="c0985-461">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="c0985-462">Alle medewerkers van de verkoopafdeling vinden met een e-mailadres begint met de letter "a" gebruik: $filter = (PartitionKey eq 'Sales') en (RowKey ge 'email_a') en (RowKey lt 'email_b')</span><span class="sxs-lookup"><span data-stu-id="c0985-462">To find all the employees in the Sales department with an email address starting with the letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="c0985-463">Opmerking: de filtersyntaxis gebruikt in de bovenstaande voorbeelden uit de tabelservice REST API, Zie voor meer informatie is [Query entiteiten](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-463">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-464">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-464">Issues and considerations</span></span>
<span data-ttu-id="c0985-465">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-465">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-466">Table storage is relatief goedkope gebruiken zodat de overhead van de kosten voor het opslaan van dubbele gegevens mag geen groot belang.</span><span class="sxs-lookup"><span data-stu-id="c0985-466">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="c0985-467">U moet echter altijd de kosten van het ontwerp op basis van de verwachte opslagvereisten geëvalueerd en alleen toevoegen dubbele entiteiten ter ondersteuning van de query's die de clienttoepassing wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-467">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="c0985-468">Omdat de secundaire index entiteiten worden opgeslagen in dezelfde partitie als de oorspronkelijke entiteiten, moet u ervoor zorgen dat u de schaalbaarheidsdoelen voor een afzonderlijke partitie niet overschrijden.</span><span class="sxs-lookup"><span data-stu-id="c0985-468">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="c0985-469">U kunt uw dubbele entiteiten consistent zijn met elkaar houden met behulp van EGTs moment bijwerken van de twee kopieën van de entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-469">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</span></span> <span data-ttu-id="c0985-470">Dit betekent dat alle exemplaren van een entiteit in dezelfde partitie moeten worden opgeslagen.</span><span class="sxs-lookup"><span data-stu-id="c0985-470">This implies that you should store all copies of an entity in the same partition.</span></span> <span data-ttu-id="c0985-471">Zie voor meer informatie de sectie [entiteitstransacties met behulp van](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="c0985-471">For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="c0985-472">De waarde voor de **RowKey** moet uniek zijn voor elke entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-472">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="c0985-473">Overweeg het gebruik van de samengestelde sleutel komt.</span><span class="sxs-lookup"><span data-stu-id="c0985-473">Consider using compound key values.</span></span>  
* <span data-ttu-id="c0985-474">Opvulling numerieke waarden in de **RowKey** (bijvoorbeeld de werknemer-id 000223), kunt sorteren en filteren op basis van hoofdletters en de ondergrenzen corrigeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-474">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="c0985-475">U hoeft hoeft niet te dupliceren van de eigenschappen van de entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-475">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="c0985-476">Bijvoorbeeld, als de query's die lookup de entiteiten die u het e-adres in de **RowKey** nooit moet de leeftijd van de werknemer, deze entiteiten kunnen de volgende structuur:</span><span class="sxs-lookup"><span data-stu-id="c0985-476">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>

![][8]

* <span data-ttu-id="c0985-477">Is het doorgaans beter dubbele gegevens opslaan en ervoor te zorgen dat u alle gegevens die u nodig hebt met een enkele query kunt ophalen dan het gebruik van een query naar een entiteit en een andere voor het opzoeken van de vereiste gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-477">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-478">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-478">When to use this pattern</span></span>
<span data-ttu-id="c0985-479">Gebruik dit patroon wanneer uw clienttoepassing moet met een aantal verschillende sleutels wanneer de client hoeft op te halen van entiteiten in een andere sorteervolgorde entiteiten ophalen en waar u elke entiteit met een aantal unieke waarden kunt identificeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-479">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="c0985-480">U moet echter zeker van te zijn dat de limieten voor schaalbaarheid van partitie niet te overschrijden wanneer u de entiteit zoekacties met behulp van de verschillende uitvoert **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-480">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-481">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-481">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-482">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-482">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-483">Secundaire tussen partitioneren van index patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-483">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="c0985-484">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-484">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="c0985-485">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-485">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="c0985-486">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-486">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="c0985-487">Secundaire tussen partitioneren van index patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-487">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="c0985-488">Opslaan van meerdere exemplaren van elke entiteit met behulp van verschillende **RowKey** waarden in afzonderlijke partities of in afzonderlijke tabellen inschakelen snel en efficiënt zoekacties en alternatieve sorteervolgorde met behulp van verschillende **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-488">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-489">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-489">Context and problem</span></span>
<span data-ttu-id="c0985-490">De tabelservice indexeert automatisch entiteiten met behulp van de **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-490">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-491">Dit kan een clienttoepassing voor het ophalen van een entiteit efficiënt gebruik maakt van deze waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-491">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="c0985-492">Bijvoorbeeld, met de structuur van de tabel hieronder wordt weergegeven, een clienttoepassing kunt gebruiken een punt-query voor een afzonderlijke werknemer entiteit ophalen met de afdelingsnaam van de en de werknemer-id (de **PartitionKey** en **RowKey** waarden).</span><span class="sxs-lookup"><span data-stu-id="c0985-492">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="c0985-493">Een client kan ook gesorteerd op werknemer-id binnen elke afdeling entiteiten ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-493">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="c0985-494">Als u ook kunnen wilt vinden van een werknemer entiteit op basis van de waarde van een andere eigenschap, zoals e-mailadres, moet u een minder efficiënte partitie scan te vinden.</span><span class="sxs-lookup"><span data-stu-id="c0985-494">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="c0985-495">Dit is omdat de tabelservice geen secundaire indexen biedt.</span><span class="sxs-lookup"><span data-stu-id="c0985-495">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="c0985-496">Er is bovendien geen optie voor het aanvragen van een lijst met werknemers gesorteerd in een andere volgorde dan **RowKey** volgorde.</span><span class="sxs-lookup"><span data-stu-id="c0985-496">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="c0985-497">U bent anticiperen op een zeer groot aantal transacties tegen deze entiteiten en wilt de risico's van de tabelservice beperking van de client.</span><span class="sxs-lookup"><span data-stu-id="c0985-497">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-498">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-498">Solution</span></span>
<span data-ttu-id="c0985-499">U kunt het ontbreken van een secundaire indexen omzeilen, kunt u meerdere exemplaren van elke entiteit met het gebruik van elk exemplaar andere opslaan **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-499">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-500">Als u een entiteit met de onderstaande structuren opslaat, kunt u efficiënt werknemer entiteiten op basis van e-adres of de werknemer-id ophalen. Het voorvoegsel waarden voor de **PartitionKey**, 'empid_' en 'email_' kunt u bepalen welke index die u wilt gebruiken voor een query.</span><span class="sxs-lookup"><span data-stu-id="c0985-500">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **PartitionKey**, "empid_" and "email_" enable you to identify which index you want to use for a query.</span></span>  

![][10]

<span data-ttu-id="c0985-501">De volgende twee filtercriteria (één opzoeken op basis van de werknemer-id en een opzoeken op basis van e-mailadres) Geef beide punt query's:</span><span class="sxs-lookup"><span data-stu-id="c0985-501">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="c0985-502">$filter = (PartitionKey eq ' empid_Sales') en (RowKey eq '000223')</span><span class="sxs-lookup"><span data-stu-id="c0985-502">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="c0985-503">$filter = (PartitionKey eq ' email_Sales') en (RowKey eq 'jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="c0985-503">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="c0985-504">Als u een query voor een bereik van de werknemer entiteiten uitvoert, kunt u een bereik gesorteerd in volgorde van de werknemer-id of een bereik in e-mailadres volgorde gesorteerd op basis van een query uitvoert voor entiteiten met het juiste voorvoegsel op in de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-504">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="c0985-505">Alle medewerkers vinden in de afdeling verkoop met een werknemer-id in het bereik **000100** naar **000199** in gebruik door werknemers-id volgorde gesorteerd: $filter = (PartitionKey eq ' empid_Sales') en (RowKey ge '000100') en (RowKey RP '000199')</span><span class="sxs-lookup"><span data-stu-id="c0985-505">To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="c0985-506">Alle medewerkers vinden in de afdeling verkoop met een e-mailadres dat met "a" gesorteerde e-mailadres volgorde gebruikt begint: $filter = (PartitionKey eq ' email_Sales') en (RowKey ge "a") en (RowKey lt "b")</span><span class="sxs-lookup"><span data-stu-id="c0985-506">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="c0985-507">Opmerking: de filtersyntaxis gebruikt in de bovenstaande voorbeelden uit de tabelservice REST API, Zie voor meer informatie is [Query entiteiten](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-507">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-508">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-508">Issues and considerations</span></span>
<span data-ttu-id="c0985-509">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-509">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-510">U uw dubbele entiteiten uiteindelijk consistent is met elkaar kunt houden met behulp van de [uiteindelijk consistent transacties patroon](#eventually-consistent-transactions-pattern) onderhouden van de primaire en secundaire index-entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-510">You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.</span></span>  
* <span data-ttu-id="c0985-511">Table storage is relatief goedkope gebruiken zodat de overhead van de kosten voor het opslaan van dubbele gegevens mag geen groot belang.</span><span class="sxs-lookup"><span data-stu-id="c0985-511">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="c0985-512">U moet echter altijd de kosten van het ontwerp op basis van de verwachte opslagvereisten geëvalueerd en alleen toevoegen dubbele entiteiten ter ondersteuning van de query's die de clienttoepassing wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-512">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="c0985-513">De waarde voor de **RowKey** moet uniek zijn voor elke entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-513">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="c0985-514">Overweeg het gebruik van de samengestelde sleutel komt.</span><span class="sxs-lookup"><span data-stu-id="c0985-514">Consider using compound key values.</span></span>  
* <span data-ttu-id="c0985-515">Opvulling numerieke waarden in de **RowKey** (bijvoorbeeld de werknemer-id 000223), kunt sorteren en filteren op basis van hoofdletters en de ondergrenzen corrigeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-515">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="c0985-516">U hoeft hoeft niet te dupliceren van de eigenschappen van de entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-516">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="c0985-517">Bijvoorbeeld, als de query's die lookup de entiteiten die u het e-adres in de **RowKey** nooit moet de leeftijd van de werknemer, deze entiteiten kunnen de volgende structuur:</span><span class="sxs-lookup"><span data-stu-id="c0985-517">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="c0985-518">Is het doorgaans beter dubbele gegevens opslaan en ervoor te zorgen dat u alle gegevens die u nodig hebt met één query dan te gebruiken één query vinden van een entiteit met behulp van de secundaire index en een andere lookup de vereiste gegevens in de primaire index kunt ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-518">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-519">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-519">When to use this pattern</span></span>
<span data-ttu-id="c0985-520">Gebruik dit patroon wanneer uw clienttoepassing moet met een aantal verschillende sleutels wanneer de client hoeft op te halen van entiteiten in een andere sorteervolgorde entiteiten ophalen en waar u elke entiteit met een aantal unieke waarden kunt identificeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-520">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="c0985-521">Dit patroon gebruiken wanneer u voorkomen dat de partitie-limieten voor schaalbaarheid dan wilt wanneer u de entiteit zoekacties met behulp van de verschillende uitvoert **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-521">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-522">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-522">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-523">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-523">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-524">Uiteindelijk consistent transacties patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-524">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="c0985-525">Intra-partitie secundaire index patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-525">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="c0985-526">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-526">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="c0985-527">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-527">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="c0985-528">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-528">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="c0985-529">Uiteindelijk consistent transacties patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-529">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="c0985-530">Uiteindelijk consistent gedrag over grenzen van partities of opslag system grenzen inschakelen met behulp van Azure wachtrijen.</span><span class="sxs-lookup"><span data-stu-id="c0985-530">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-531">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-531">Context and problem</span></span>
<span data-ttu-id="c0985-532">EGTs inschakelen atomische transacties tussen meerdere entiteiten die dezelfde partitiesleutel delen.</span><span class="sxs-lookup"><span data-stu-id="c0985-532">EGTs enable atomic transactions across multiple entities that share the same partition key.</span></span> <span data-ttu-id="c0985-533">Voor betere prestaties en schaalbaarheid u besluiten voor het opslaan van entiteiten met vereisten voor consistentie in afzonderlijke partities of in een afzonderlijke opslagsysteem: in een dergelijk scenario u EGTs niet gebruiken voor het handhaven van de consistentie.</span><span class="sxs-lookup"><span data-stu-id="c0985-533">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</span></span> <span data-ttu-id="c0985-534">Zo mogelijk een vereiste uiteindelijke consistentie tussen onderhouden:</span><span class="sxs-lookup"><span data-stu-id="c0985-534">For example, you might have a requirement to maintain eventual consistency between:</span></span>  

* <span data-ttu-id="c0985-535">Entiteiten in opgeslagen in twee verschillende partities in dezelfde tabel in verschillende tabellen in verschillende opslagaccounts.</span><span class="sxs-lookup"><span data-stu-id="c0985-535">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="c0985-536">Een entiteit die is opgeslagen in de tabel-service en een blob die is opgeslagen in de Blob-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-536">An entity stored in the Table service and a blob stored in the Blob service.</span></span>  
* <span data-ttu-id="c0985-537">Een entiteit in de tabel-service en een bestand opgeslagen in een bestandssysteem.</span><span class="sxs-lookup"><span data-stu-id="c0985-537">An entity stored in the Table service and a file in a file system.</span></span>  
* <span data-ttu-id="c0985-538">Een entiteit store in de tabel-service nog geïndexeerd met de Azure Search-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-538">An entity store in the Table service yet indexed using the Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-539">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-539">Solution</span></span>
<span data-ttu-id="c0985-540">U kunt een oplossing die zorgt voor uiteindelijke consistentie tussen twee of meer partities of opslagsystemen implementeren met behulp van Azure wachtrijen.</span><span class="sxs-lookup"><span data-stu-id="c0985-540">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="c0985-541">Ter illustratie van deze benadering wordt ervan uitgegaan dat u hebt een vereiste kunnen archiveren oude werknemer entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-541">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</span></span> <span data-ttu-id="c0985-542">Oude werknemer entiteiten zelden worden opgevraagd en van alle activiteiten die betrekking op de huidige werknemers hebben moeten worden uitgesloten.</span><span class="sxs-lookup"><span data-stu-id="c0985-542">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="c0985-543">Voor het implementeren van deze vereiste actieve werknemers op te slaan de **huidige** tabel en oude werknemers in de **archief** tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-543">To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table.</span></span> <span data-ttu-id="c0985-544">Een werknemer archiveren, moet u verwijderen van de entiteit van de **huidige** tabel en het toevoegen van de entiteit de **archief** tabel, maar u een EGT niet gebruiken voor het uitvoeren van deze twee bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-544">Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations.</span></span> <span data-ttu-id="c0985-545">Om te voorkomen dat het risico dat een fout een entiteit veroorzaakt moet worden weergegeven in beide of geen van beide tabellen, moet de archiveringsbewerking uiteindelijk consistent is.</span><span class="sxs-lookup"><span data-stu-id="c0985-545">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</span></span> <span data-ttu-id="c0985-546">Het volgende diagram van de takenreeks bevat de stappen in deze bewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-546">The following sequence diagram outlines the steps in this operation.</span></span> <span data-ttu-id="c0985-547">Meer details wordt uitzondering paden in de volgende tekst geleverd.</span><span class="sxs-lookup"><span data-stu-id="c0985-547">More detail is provided for exception paths in the text following.</span></span>  

![][12]

<span data-ttu-id="c0985-548">Een client initieert de archiveringsbewerking door het plaatsen van een bericht op een Azure-wachtrij in dit voorbeeld voor het archiveren van de werknemer #456.</span><span class="sxs-lookup"><span data-stu-id="c0985-548">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</span></span> <span data-ttu-id="c0985-549">Een werkrol, peilt de wachtrij voor nieuwe berichten; Wanneer er een is gevonden, leest het bericht en wordt een verborgen kopie in de wachtrij.</span><span class="sxs-lookup"><span data-stu-id="c0985-549">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</span></span> <span data-ttu-id="c0985-550">De werkrol een kopie van de entiteit van de volgende haalt de **huidige** tabel, voegt u een kopie in het **archief** tabel en verwijdert u vervolgens de oorspronkelijke uit de **huidige** tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-550">The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table.</span></span> <span data-ttu-id="c0985-551">Ten slotte, als er geen fouten uit de vorige stap zijn, de werkrol verborgen wordt het bericht verwijderd uit de wachtrij.</span><span class="sxs-lookup"><span data-stu-id="c0985-551">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</span></span>  

<span data-ttu-id="c0985-552">In dit voorbeeld voegt stap 4 van de werknemer in het **archief** tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-552">In this example, step 4 inserts the employee into the **Archive** table.</span></span> <span data-ttu-id="c0985-553">Dit kan de werknemer toevoegen aan een blob in de Blob-service of een bestand in een bestandssysteem.</span><span class="sxs-lookup"><span data-stu-id="c0985-553">It could add the employee to a blob in the Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="c0985-554">Herstellen van fouten</span><span class="sxs-lookup"><span data-stu-id="c0985-554">Recovering from failures</span></span>
<span data-ttu-id="c0985-555">Het is belangrijk dat de bewerkingen in stappen **4** en **5** moet *idempotent* voor het geval de werkrol opnieuw opstarten van de archiveringsbewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-555">It is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation.</span></span> <span data-ttu-id="c0985-556">Als u de tabelservice voor stap **4** moet u een bewerking "invoegen of vervangen"; voor de stap **5** moet u een ' verwijderen als bestaat ' bewerking in de clientbibliotheek die u gebruikt.</span><span class="sxs-lookup"><span data-stu-id="c0985-556">If you are using the Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in the client library you are using.</span></span> <span data-ttu-id="c0985-557">Als u een andere opslagsysteem gebruikt, moet u een geschikte idempotent-bewerking.</span><span class="sxs-lookup"><span data-stu-id="c0985-557">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="c0985-558">Als de werkrol nooit stap voltooit **6**, en vervolgens verschijnt het bericht opnieuw na een time-out voor de wachtrij gereed is voor de werkrol proberen te deze opnieuw te verwerken.</span><span class="sxs-lookup"><span data-stu-id="c0985-558">If the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</span></span> <span data-ttu-id="c0985-559">De werkrol kunt controleren hoe vaak een bericht in de wachtrij is gelezen en, indien nodig, markeren is een 'poison'-bericht voor onderzoek door ze naar een afzonderlijke wachtrij.</span><span class="sxs-lookup"><span data-stu-id="c0985-559">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</span></span> <span data-ttu-id="c0985-560">Zie voor meer informatie over het lezen van berichten in wachtrij plaatsen en het controleren van de wachtrij halen telling [berichten ophalen](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-560">For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="c0985-561">Er zijn fouten van de tabel en Queue-services zijn tijdelijke fouten en uw clienttoepassing bevatten geschikte Pogingslogica om deze te verwerken.</span><span class="sxs-lookup"><span data-stu-id="c0985-561">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-562">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-562">Issues and considerations</span></span>
<span data-ttu-id="c0985-563">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-563">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-564">Deze oplossing biedt geen voor het isoleren van de transactie.</span><span class="sxs-lookup"><span data-stu-id="c0985-564">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="c0985-565">Bijvoorbeeld, een client kan lezen de **huidige** en **archief** tabellen wanneer de werkrol werd tussen stappen **4** en **5**, en een inconsistente weergave van de gegevens ziet.</span><span class="sxs-lookup"><span data-stu-id="c0985-565">For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data.</span></span> <span data-ttu-id="c0985-566">Houd er rekening mee dat de gegevens zal consistent uiteindelijk.</span><span class="sxs-lookup"><span data-stu-id="c0985-566">Note that the data will be consistent eventually.</span></span>  
* <span data-ttu-id="c0985-567">U moet ervoor dat de stappen 4 en 5 idempotent zijn om de uiteindelijke consistentie te garanderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-567">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</span></span>  
* <span data-ttu-id="c0985-568">U kunt de oplossing met behulp van meerdere wachtrijen en rolinstanties worker schalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-568">You can scale the solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-569">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-569">When to use this pattern</span></span>
<span data-ttu-id="c0985-570">Gebruik dit patroon als u wilt garanderen uiteindelijke consistentie tussen entiteiten die aanwezig zijn in verschillende partities of tabellen.</span><span class="sxs-lookup"><span data-stu-id="c0985-570">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="c0985-571">U kunt dit patroon om ervoor te zorgen uiteindelijke consistentie voor bewerkingen in de tabel-service en de Blob-service en andere Azure Storage gegevensbronnen zoals database of het bestandssysteem uitbreiden.</span><span class="sxs-lookup"><span data-stu-id="c0985-571">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-572">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-572">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-573">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-573">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-574">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-574">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="c0985-575">Samenvoegen of vervangen</span><span class="sxs-lookup"><span data-stu-id="c0985-575">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="c0985-576">Als de transactie-isolatieniveau is belangrijk dat uw oplossing, kunt u overwegen opnieuw ontwerpen van uw tabellen zodat u EGTs gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-576">If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="c0985-577">Index entiteiten patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-577">Index Entities Pattern</span></span>
<span data-ttu-id="c0985-578">Onderhouden index entiteiten zodat efficiënte zoekopdrachten die lijsten van entiteiten retourneren.</span><span class="sxs-lookup"><span data-stu-id="c0985-578">Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-579">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-579">Context and problem</span></span>
<span data-ttu-id="c0985-580">De tabelservice indexeert automatisch entiteiten met behulp van de **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-580">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-581">Hierdoor wordt een clienttoepassing voor het ophalen van een entiteit efficiënt gebruik maakt van een punt-query.</span><span class="sxs-lookup"><span data-stu-id="c0985-581">This enables a client application to retrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="c0985-582">Bijvoorbeeld, met behulp van de structuur van de tabel hieronder wordt weergegeven, een clienttoepassing kunt efficiënt een afzonderlijke werknemer entiteit ophalen met behulp van de naam van de afdeling en de werknemer-id (de **PartitionKey** en **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="c0985-582">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="c0985-583">Als u ook kunnen wilt ophalen van een lijst van de werknemer entiteiten op basis van de waarde van een andere niet-unieke eigenschap, zoals hun achternaam, moet u een minder efficiënte partitie scan om te zoeken naar overeenkomsten in plaats van een index met ze rechtstreeks opzoeken.</span><span class="sxs-lookup"><span data-stu-id="c0985-583">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</span></span> <span data-ttu-id="c0985-584">Dit is omdat de tabelservice geen secundaire indexen biedt.</span><span class="sxs-lookup"><span data-stu-id="c0985-584">This is because the table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-585">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-585">Solution</span></span>
<span data-ttu-id="c0985-586">Als u wilt zoeken op naam inschakelen met de structuur van de entiteit hierboven weergegeven, moet u een lijst met werknemer-id's onderhouden.</span><span class="sxs-lookup"><span data-stu-id="c0985-586">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="c0985-587">Als u wilt ophalen van de werknemer entiteiten met een bepaalde achternaam, zoals Peeters, moet u eerst de lijst met werknemer-id vinden voor werknemers met Jones als hun achternaam en vervolgens deze werknemer entiteiten worden opgehaald.</span><span class="sxs-lookup"><span data-stu-id="c0985-587">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="c0985-588">Er zijn drie manieren voor het opslaan van de lijsten met werknemer-id's:</span><span class="sxs-lookup"><span data-stu-id="c0985-588">There are three main options for storing the lists of employee ids:</span></span>  

* <span data-ttu-id="c0985-589">Blob storage gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-589">Use blob storage.</span></span>  
* <span data-ttu-id="c0985-590">Index entiteiten in dezelfde partitie als de werknemer-entiteiten maken.</span><span class="sxs-lookup"><span data-stu-id="c0985-590">Create index entities in the same partition as the employee entities.</span></span>  
* <span data-ttu-id="c0985-591">Maak index entiteiten in een afzonderlijke partitie of de tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-591">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="c0985-592"><u>Optie #1: Gebruik blob storage</u></span><span class="sxs-lookup"><span data-stu-id="c0985-592"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="c0985-593">Voor de eerste optie, u een blob voor elke unieke achternaam en in elke blob-store een lijst maken van de **PartitionKey** (afdeling) en **RowKey** (werknemer-id) waarden voor werknemers die die achternaam hebben.</span><span class="sxs-lookup"><span data-stu-id="c0985-593">For the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="c0985-594">Bij het toevoegen of verwijderen van een werknemer moet u ervoor zorgen dat de inhoud van de relevante blob uiteindelijk consistent is met de werknemer entiteiten is.</span><span class="sxs-lookup"><span data-stu-id="c0985-594">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</span></span>  

<span data-ttu-id="c0985-595"><u>Optie #2:</u> index entiteiten in dezelfde partitie maken</span><span class="sxs-lookup"><span data-stu-id="c0985-595"><u>Option #2:</u> Create index entities in the same partition</span></span>  

<span data-ttu-id="c0985-596">Gebruik voor de tweede optie, index-entiteiten die de volgende gegevens worden opgeslagen:</span><span class="sxs-lookup"><span data-stu-id="c0985-596">For the second option, use index entities that store the following data:</span></span>  

![][14]

<span data-ttu-id="c0985-597">De **EmployeeIDs** eigenschap bevat een lijst van de werknemer-id's voor werknemers met de achternaam opgeslagen in de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-597">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="c0985-598">De volgende stappen wordt beschreven hoe die u volgen moet wanneer u een nieuwe werknemer toevoegen wilt als u de tweede optie.</span><span class="sxs-lookup"><span data-stu-id="c0985-598">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</span></span> <span data-ttu-id="c0985-599">In dit voorbeeld toevoegen we een werknemer met Id 000152 en een achternaam Jones van de verkoopafdeling:</span><span class="sxs-lookup"><span data-stu-id="c0985-599">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="c0985-600">Ophalen van de entiteit index met een **PartitionKey** waarde 'Verkoop' en de **RowKey** waarde "Jones."</span><span class="sxs-lookup"><span data-stu-id="c0985-600">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span> <span data-ttu-id="c0985-601">Sla de ETag van deze entiteit moet worden gebruikt in stap 2.</span><span class="sxs-lookup"><span data-stu-id="c0985-601">Save the ETag of this entity to use in step 2.</span></span>  
2. <span data-ttu-id="c0985-602">Maken van een entiteit groep transactie (dat wil zeggen, een batchbewerking) die de nieuwe werknemer entiteit ingevoegd (**PartitionKey** waarde 'Verkoop' en **RowKey** waarde '000152'), en updates van de entiteit index (**PartitionKey** waarde 'Verkoop' en **RowKey** waarde 'Jones') door de nieuwe werknemers-id toe te voegen aan de lijst in het veld EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="c0985-602">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates the index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</span></span> <span data-ttu-id="c0985-603">Zie voor meer informatie over entiteit groepstransacties [entiteit groepstransacties](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="c0985-603">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="c0985-604">Als de entiteit groep transactie is mislukt vanwege een optimistische gelijktijdigheid-fout (iemand anders heeft alleen de entiteit index gewijzigd), moet u opnieuw beginnen bij stap 1.</span><span class="sxs-lookup"><span data-stu-id="c0985-604">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</span></span>  

<span data-ttu-id="c0985-605">U kunt een soortgelijke benadering van een werknemer verwijderen als u de tweede optie gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-605">You can use a similar approach to deleting an employee if you are using the second option.</span></span> <span data-ttu-id="c0985-606">Wijzigen van de achternaam van een werknemer is iets ingewikkelder omdat u moet uitvoeren van een entiteit groep transactie die drie entiteiten worden bijgewerkt: de entiteit van de werknemer, de entiteit van de index voor de achternaam van de oude en de entiteit van de index voor de nieuwe achternaam.</span><span class="sxs-lookup"><span data-stu-id="c0985-606">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</span></span> <span data-ttu-id="c0985-607">Voordat u wijzigingen aanbrengt in om op te halen van de ETag-waarden die u vervolgens gebruiken kunt voor het uitvoeren van de updates gebruikt optimistische gelijktijdigheid, moet u elke entiteit ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-607">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</span></span>  

<span data-ttu-id="c0985-608">De volgende stappen wordt beschreven hoe die u volgen moet wanneer u alle werknemers met een bepaalde achternaam in een afdeling opzoeken moet, als u de tweede optie.</span><span class="sxs-lookup"><span data-stu-id="c0985-608">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</span></span> <span data-ttu-id="c0985-609">In dit voorbeeld zijn er opzoeken van alle werknemers met een achternaam Jones in de afdeling verkoop:</span><span class="sxs-lookup"><span data-stu-id="c0985-609">In this example, we are looking up all the employees with last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="c0985-610">Ophalen van de entiteit index met een **PartitionKey** waarde 'Verkoop' en de **RowKey** waarde "Jones."</span><span class="sxs-lookup"><span data-stu-id="c0985-610">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="c0985-611">De lijst met werknemer-id's in het veld EmployeeIDs parseren.</span><span class="sxs-lookup"><span data-stu-id="c0985-611">Parse the list of employee Ids in the EmployeeIDs field.</span></span>  
3. <span data-ttu-id="c0985-612">Als u meer informatie over elk van deze werknemers (zoals hun e-mailadressen), ophalen van elk van de werknemer entiteiten met **PartitionKey** waarde 'Verkoop' en **RowKey** waarden uit de lijst met werknemers die u hebt verkregen in stap 2.</span><span class="sxs-lookup"><span data-stu-id="c0985-612">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value "Sales" and **RowKey** values from the list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="c0985-613"><u>Optie #3:</u> index entiteiten in een afzonderlijke partitie of een tabel maken</span><span class="sxs-lookup"><span data-stu-id="c0985-613"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="c0985-614">Gebruik voor de derde optie, index-entiteiten die opslaan van de volgende gegevens:</span><span class="sxs-lookup"><span data-stu-id="c0985-614">For the third option, use index entities that store the following data:</span></span>  

![][15]

<span data-ttu-id="c0985-615">De **EmployeeIDs** eigenschap bevat een lijst van de werknemer-id's voor werknemers met de achternaam opgeslagen in de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="c0985-615">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="c0985-616">Met de derde optie, kunt u EGTs niet gebruiken om consistentie te behouden omdat de index-entiteiten in een afzonderlijke partitie van de werknemer entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-616">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</span></span> <span data-ttu-id="c0985-617">U moet ervoor zorgen dat de index entiteiten uiteindelijk consistent is met de werknemer entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-617">You should ensure that the index entities are eventually consistent with the employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-618">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-618">Issues and considerations</span></span>
<span data-ttu-id="c0985-619">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-619">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-620">Deze oplossing vereist ten minste twee query's naar het overeenkomende entiteiten ophalen: een query uitvoeren op de index-entiteiten voor de lijst van **RowKey** waarden en query's voor het ophalen van elke entiteit in de lijst.</span><span class="sxs-lookup"><span data-stu-id="c0985-620">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.</span></span>  
* <span data-ttu-id="c0985-621">Gezien het feit dat een afzonderlijke entiteit een maximale grootte van 1 MB heeft, optie #2 en de optie #3 in de oplossing wordt ervan uitgegaan dat de lijst met werknemer-id's voor een bepaalde achternaam nooit groter dan 1 MB is.</span><span class="sxs-lookup"><span data-stu-id="c0985-621">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="c0985-622">Als de lijst met werknemer-id's kunnen niet groter zijn dan 1 MB groot is, gebruik van optie #1 en opslaan van de indexgegevens in de blob-opslag.</span><span class="sxs-lookup"><span data-stu-id="c0985-622">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</span></span>  
* <span data-ttu-id="c0985-623">Als u de optie #2 gebruikt moet (met EGTs om af te handelen toevoegen en verwijderen van werknemers en het wijzigen van de achternaam van een werknemer) u nagaan of het volume van transacties worden de limieten voor schaalbaarheid in een bepaalde partitie benaderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-623">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee's last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</span></span> <span data-ttu-id="c0985-624">Als dit het geval is, moet u rekening houden met een uiteindelijk consistent oplossing (optie &#1; of optie #3) die gebruikmaakt van wachtrijen om de updateaanvragen te verwerken en kunt u uw index entiteiten opslaan op een afzonderlijke partitie van de werknemer entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-624">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</span></span>  
* <span data-ttu-id="c0985-625">Optie #2 in deze oplossing wordt ervan uitgegaan dat u wilt zoeken op achternaam binnen een afdeling: bijvoorbeeld, u wilt ophalen van een lijst met werknemers met een achternaam Jones van de verkoopafdeling.</span><span class="sxs-lookup"><span data-stu-id="c0985-625">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</span></span> <span data-ttu-id="c0985-626">Als u zoeken naar alle werknemers met een achternaam Jones over de hele organisatie wilt, optie #1 of optie #3 gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c0985-626">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="c0985-627">U kunt een oplossing op basis van wachtrijen die zorgt voor uiteindelijke consistentie implementeren (Zie de [uiteindelijk consistent transacties patroon](#eventually-consistent-transactions-pattern) voor meer informatie).</span><span class="sxs-lookup"><span data-stu-id="c0985-627">You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-628">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-628">When to use this pattern</span></span>
<span data-ttu-id="c0985-629">Gebruik dit patroon als u wilt voor het opzoeken van een set van entiteiten met algemene waarde van een eigenschap, zoals alle werknemers die over de achternaam Jones dezelfde.</span><span class="sxs-lookup"><span data-stu-id="c0985-629">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-630">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-630">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-631">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-631">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-632">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-632">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="c0985-633">Uiteindelijk consistent transacties patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-633">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="c0985-634">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-634">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="c0985-635">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-635">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="c0985-636">Denormalization patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-636">Denormalization pattern</span></span>
<span data-ttu-id="c0985-637">Verwante gegevens samen combineren in één entiteit waarmee u kunt alle gegevens die u nodig hebt met een query één punt ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-637">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-638">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-638">Context and problem</span></span>
<span data-ttu-id="c0985-639">In een relationele database, moet u doorgaans gegevens als u wilt verwijderen, wat resulteert in query's die gegevens uit meerdere tabellen ophalen worden gedupliceerd normaliseren.</span><span class="sxs-lookup"><span data-stu-id="c0985-639">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="c0985-640">Als u uw gegevens in Azure-tabellen normaliseren, moet u meerdere retouren van de client naar de server voor het ophalen van de bijbehorende gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-640">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</span></span> <span data-ttu-id="c0985-641">Bijvoorbeeld met de structuur van de tabel hieronder u moet twee retouren naar de details voor een afdeling ophalen: één voor het ophalen van de afdeling entiteit met id van de manager en vervolgens een andere aanvraag voor het ophalen van de manager details in een entiteit van de werknemer.</span><span class="sxs-lookup"><span data-stu-id="c0985-641">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager's id, and then another request to fetch the manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="c0985-642">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-642">Solution</span></span>
<span data-ttu-id="c0985-643">In plaats van de gegevens worden opgeslagen in twee afzonderlijke entiteiten, denormalize van de gegevens en een kopie van de details van de manager in de entiteit afdeling houden.</span><span class="sxs-lookup"><span data-stu-id="c0985-643">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager's details in the department entity.</span></span> <span data-ttu-id="c0985-644">Bijvoorbeeld:</span><span class="sxs-lookup"><span data-stu-id="c0985-644">For example:</span></span>  

![][17]

<span data-ttu-id="c0985-645">Met de afdeling entiteiten met deze eigenschappen worden opgeslagen, kunt u nu alle gegevens die u moet over een afdeling in een query punt ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-645">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-646">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-646">Issues and considerations</span></span>
<span data-ttu-id="c0985-647">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-647">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-648">Er is enige kosten overhead die is gekoppeld aan twee keer sommige gegevens op te slaan.</span><span class="sxs-lookup"><span data-stu-id="c0985-648">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="c0985-649">De prestatievoordelen (die voortvloeien uit minder aanvragen aan de storage-service) doorgaans belangrijker is dan de marginale toename van de kosten voor opslag (en deze kosten is gedeeltelijk gecompenseerd door een vermindering van het aantal transacties die u nodig hebt voor het ophalen van de details van een afdeling).</span><span class="sxs-lookup"><span data-stu-id="c0985-649">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</span></span>  
* <span data-ttu-id="c0985-650">U moet de consistentie van de twee entiteiten die voor het opslaan van informatie over beheerders onderhouden.</span><span class="sxs-lookup"><span data-stu-id="c0985-650">You must maintain the consistency of the two entities that store information about managers.</span></span> <span data-ttu-id="c0985-651">U kunt het probleem consistentiecontrole verwerkt met behulp van EGTs meerdere entiteiten in één transactie atomic bijwerken: in dit geval wordt de entiteit afdeling en de werknemer entiteit voor de afdelingsmanager worden opgeslagen in dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-651">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-652">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-652">When to use this pattern</span></span>
<span data-ttu-id="c0985-653">Dit patroon gebruikt als u regelmatig om verwante informatie te zoeken.</span><span class="sxs-lookup"><span data-stu-id="c0985-653">Use this pattern when you frequently need to look up related information.</span></span> <span data-ttu-id="c0985-654">Dit patroon vermindert het aantal query's die de client aanbrengen moet in de gegevens die vereist worden opgehaald.</span><span class="sxs-lookup"><span data-stu-id="c0985-654">This pattern reduces the number of queries your client must make to retrieve the data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-655">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-655">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-656">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-656">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-657">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-657">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="c0985-658">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-658">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="c0985-659">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-659">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="c0985-660">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-660">Compound key pattern</span></span>
<span data-ttu-id="c0985-661">Gebruik samengestelde **RowKey** waarden om in te schakelen van een client voor het opzoeken van gerelateerde gegevens met een query één punt.</span><span class="sxs-lookup"><span data-stu-id="c0985-661">Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-662">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-662">Context and problem</span></span>
<span data-ttu-id="c0985-663">In een relationele database is het erg natuurlijke joins in query's gebruiken om te retourneren van gerelateerde delen van gegevens naar de client in één query op.</span><span class="sxs-lookup"><span data-stu-id="c0985-663">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</span></span> <span data-ttu-id="c0985-664">Bijvoorbeeld, kunt u de werknemer-id te zoeken om een overzicht van gerelateerde entiteiten die prestaties bevatten en gegevens voor die werknemer bekijken.</span><span class="sxs-lookup"><span data-stu-id="c0985-664">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="c0985-665">Stel dat u bij het opslaan van entiteiten van de werknemer in de tabel-service met behulp van de volgende structuur:</span><span class="sxs-lookup"><span data-stu-id="c0985-665">Assume you are storing employee entities in the Table service using the following structure:</span></span>  

![][18]

<span data-ttu-id="c0985-666">U moet er ook voor het opslaan van historische gegevens met betrekking tot beoordelingen en prestaties voor elk jaar die de werknemer heeft gewerkt voor uw organisatie en moet u toegang tot deze informatie per jaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-666">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</span></span> <span data-ttu-id="c0985-667">Een mogelijkheid is het maken van een andere tabel die wordt opgeslagen entiteiten met de volgende structuur:</span><span class="sxs-lookup"><span data-stu-id="c0985-667">One option is to create another table that stores entities with the following structure:</span></span>  

![][19]

<span data-ttu-id="c0985-668">U ziet dat met deze methode wilt u misschien dubbele bepaalde gegevens (zoals de voornaam en achternaam) in de nieuwe entiteit waarmee u uw gegevens met één aanvraag ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-668">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</span></span> <span data-ttu-id="c0985-669">U moet echter sterke consistentie kan niet onderhouden omdat u niet een EGT gebruiken voor het bijwerken van de twee entiteiten moment.</span><span class="sxs-lookup"><span data-stu-id="c0985-669">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-670">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-670">Solution</span></span>
<span data-ttu-id="c0985-671">Een nieuwe entiteitstype opslaan in de oorspronkelijke tabel met behulp van de entiteiten met de volgende structuur:</span><span class="sxs-lookup"><span data-stu-id="c0985-671">Store a new entity type in your original table using entities with the following structure:</span></span>  

![][20]

<span data-ttu-id="c0985-672">U ziet hoe de **RowKey** is nu een samengestelde sleutel bestaat uit de werknemer-id en het jaar van de evaluatie-gegevens waarmee u de prestaties van de werknemer ophalen en gegevens met één aanvraag voor een enkele entiteit te controleren.</span><span class="sxs-lookup"><span data-stu-id="c0985-672">Notice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="c0985-673">Het volgende voorbeeld ziet hoe u alle controle-gegevens kunt ophalen voor een bepaalde werknemer (zoals werknemer 000123 van de verkoopafdeling):</span><span class="sxs-lookup"><span data-stu-id="c0985-673">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</span></span>  

<span data-ttu-id="c0985-674">$filter = (PartitionKey eq 'Sales') en (RowKey ge 'empid_000123') en (RowKey lt 'empid_000124') & $select = RowKey, beoordeling door Manager, beoordeling van de Peer, opmerkingen</span><span class="sxs-lookup"><span data-stu-id="c0985-674">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-675">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-675">Issues and considerations</span></span>
<span data-ttu-id="c0985-676">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-676">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-677">U moet een geschikte scheidingsteken waarmee u gemakkelijk parseren gebruiken de **RowKey** waarde: bijvoorbeeld **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="c0985-677">You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="c0985-678">U ook opslaat deze entiteit in dezelfde partitie als andere entiteiten die gerelateerde gegevens bevatten voor dezelfde werknemer, wat betekent dat u kunt EGTs sterke consistentie.</span><span class="sxs-lookup"><span data-stu-id="c0985-678">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</span></span>
* <span data-ttu-id="c0985-679">U moet overwegen hoe vaak u een query uit op de gegevens om te bepalen of dit patroon geschikt is.</span><span class="sxs-lookup"><span data-stu-id="c0985-679">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</span></span>  <span data-ttu-id="c0985-680">Bijvoorbeeld, als u toegang hebben tot de gegevens van revisie zelden en vaak de belangrijkste werknemersgegevens bewaar ze als afzonderlijke entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-680">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-681">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-681">When to use this pattern</span></span>
<span data-ttu-id="c0985-682">Gebruik dit patroon wanneer u wilt opslaan op een of meer entiteiten die query u vaak gerelateerde.</span><span class="sxs-lookup"><span data-stu-id="c0985-682">Use this pattern when you need to store one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-683">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-683">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-684">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-684">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-685">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-685">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="c0985-686">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-686">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="c0985-687">Uiteindelijk consistent transacties patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-687">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="c0985-688">Patroon voor logboekbestand staart</span><span class="sxs-lookup"><span data-stu-id="c0985-688">Log tail pattern</span></span>
<span data-ttu-id="c0985-689">Ophalen van de  *n*  entiteiten die onlangs zijn toegevoegd aan een partitie met behulp van een **RowKey** waarde die in omgekeerde datum en tijd volgorde worden gesorteerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-689">Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-690">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-690">Context and problem</span></span>
<span data-ttu-id="c0985-691">Een algemene vereiste is mogelijk het meest recent gemaakte entiteiten ophalen, bijvoorbeeld de meest recente tien claims die zijn ingediend door een werknemer onkosten.</span><span class="sxs-lookup"><span data-stu-id="c0985-691">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="c0985-692">Tabel ondersteuning vraagt een **$top** querybewerking te retourneren van de eerste  *n*  entiteiten uit een set: Er is geen equivalent querybewerking te retourneren van de laatste n entiteiten in een set.</span><span class="sxs-lookup"><span data-stu-id="c0985-692">Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-693">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-693">Solution</span></span>
<span data-ttu-id="c0985-694">Opslaan van de entiteiten met een **RowKey** dat natuurlijk sorteren in volgorde van de omgekeerde datum/tijd met behulp van zodat de meest recente vermelding is altijd de eerste rij in de tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-694">Store the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</span></span>  

<span data-ttu-id="c0985-695">Bijvoorbeeld, om te kunnen ophalen van de tien meest recente onkosten claims ingediend door een werknemer, kunt u een omgekeerde maatstreepjes-waarde die is afgeleid van de huidige datum en tijd.</span><span class="sxs-lookup"><span data-stu-id="c0985-695">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</span></span> <span data-ttu-id="c0985-696">De volgende C#-codevoorbeeld ziet u een manier om u te maken van een geschikte waarde 'omgekeerde ticks' voor een **RowKey** die sorteren van de meest recente naar oud:</span><span class="sxs-lookup"><span data-stu-id="c0985-696">The following C# code sample shows one way to create a suitable "inverted ticks" value for a **RowKey** that sorts from the most recent to the oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="c0985-697">U kunt teruggaan naar de datum-tijdwaarde met de volgende code:</span><span class="sxs-lookup"><span data-stu-id="c0985-697">You can get back to the date time value using the following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="c0985-698">De tabelquery ziet er als volgt:</span><span class="sxs-lookup"><span data-stu-id="c0985-698">The table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-699">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-699">Issues and considerations</span></span>
<span data-ttu-id="c0985-700">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-700">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-701">U moet de waarde van de omgekeerde maatstreepjes met nullen om te controleren of dat de tekenreekswaarde sorteert zoals verwacht toonaangevende opgevuld.</span><span class="sxs-lookup"><span data-stu-id="c0985-701">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</span></span>  
* <span data-ttu-id="c0985-702">U moet rekening houden met de schaalbaarheidsdoelen op het niveau van een partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-702">You must be aware of the scalability targets at the level of a partition.</span></span> <span data-ttu-id="c0985-703">Wees voorzichtig hotspot partities niet maken.</span><span class="sxs-lookup"><span data-stu-id="c0985-703">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-704">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-704">When to use this pattern</span></span>
<span data-ttu-id="c0985-705">Dit patroon gebruikt als u toegang tot entiteiten in volgorde van de omgekeerde datum/tijd- of wanneer u toegang wilt tot de meest recent toegevoegde entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-705">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-706">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-706">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-707">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-707">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-708">Toevoegen / antivirusprogramma patroon toevoegen</span><span class="sxs-lookup"><span data-stu-id="c0985-708">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="c0985-709">Entiteiten ophalen</span><span class="sxs-lookup"><span data-stu-id="c0985-709">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="c0985-710">Patroon voor grote volumes verwijderen</span><span class="sxs-lookup"><span data-stu-id="c0985-710">High volume delete pattern</span></span>
<span data-ttu-id="c0985-711">Het verwijderen van een groot aantal entiteiten inschakelen door het opslaan van alle entiteiten voor gelijktijdige verwijdering in hun eigen afzonderlijke tabel. u kunt de entiteiten verwijderen door de tabel verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-711">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-712">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-712">Context and problem</span></span>
<span data-ttu-id="c0985-713">Veel toepassingen verwijderen oude gegevens die niet langer beschikbaar zijn voor een clienttoepassing of de toepassing naar een ander opslagmedium is gearchiveerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-713">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</span></span> <span data-ttu-id="c0985-714">U doorgaans dergelijke gegevens identificeren met een datum: bijvoorbeeld: u hebt een vereiste om records van alle aanmeldingsaanvragen voor die meer dan 60 dagen te verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-714">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="c0985-715">Een mogelijke ontwerp is het gebruik van de datum en tijd van de aanmeldingsaanvraag in de **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="c0985-715">One possible design is to use the date and time of the login request in the **RowKey**:</span></span>  

![][21]

<span data-ttu-id="c0985-716">Deze aanpak voorkomt partitie hotspots omdat de toepassing kunt invoegen en verwijderen van aanmelding entiteiten voor elke gebruiker in een afzonderlijke partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-716">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="c0985-717">Deze aanpak kan echter kostbaar en tijd in beslag nemen als u een groot aantal entiteiten hebt omdat u eerst een tabelscan uitvoeren om te kunnen identificeren van de entiteiten moet te verwijderen en vervolgens moet u elke oude entiteit verwijderen zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-717">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</span></span> <span data-ttu-id="c0985-718">Houd er rekening mee dat u het aantal retouren naar de server vereist voor het verwijderen van de oude entiteiten met meerdere delete-aanvragen in EGTs batchverwerking kunt verkleinen.</span><span class="sxs-lookup"><span data-stu-id="c0985-718">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-719">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-719">Solution</span></span>
<span data-ttu-id="c0985-720">Een afzonderlijke tabel gebruiken voor elke dag van aanmeldingspogingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-720">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="c0985-721">U kunt het ontwerp van de entiteit bovenstaande hotspots voorkomen wanneer entiteiten invoegen en verwijderen van oude entiteiten nu gewoon een vraag is van het verwijderen van één tabel elke dag (een enkele opslagbewerking) in plaats van zoeken en verwijderen van honderden en duizenden afzonderlijke aanmelding entiteiten elke dag.</span><span class="sxs-lookup"><span data-stu-id="c0985-721">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-722">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-722">Issues and considerations</span></span>
<span data-ttu-id="c0985-723">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-723">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-724">Uw ontwerp biedt ondersteuning voor andere manieren de gegevens zoals het opzoeken van specifieke entiteiten, koppelen aan andere gegevens of genereren verzamelde gegevens zullen worden gebruikt door uw toepassing?</span><span class="sxs-lookup"><span data-stu-id="c0985-724">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="c0985-725">Uw ontwerp hotspots voorkomen tijdens het invoegen van nieuwe entiteiten</span><span class="sxs-lookup"><span data-stu-id="c0985-725">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="c0985-726">Een vertraging verwachten als u gebruiken als de naam van de dezelfde tabel wilt na het verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-726">Expect a delay if you want to reuse the same table name after deleting it.</span></span> <span data-ttu-id="c0985-727">Het is beter gebruik altijd uniek tabelnamen.</span><span class="sxs-lookup"><span data-stu-id="c0985-727">It's better to always use unique table names.</span></span>  
* <span data-ttu-id="c0985-728">Verwachten dat sommige beperking wanneer u eerst een nieuwe tabel terwijl de tabelservice de toegangspatronen leert en distributie van de partities over knooppunten.</span><span class="sxs-lookup"><span data-stu-id="c0985-728">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</span></span> <span data-ttu-id="c0985-729">U moet rekening houden hoe vaak moet u nieuwe tabellen maken.</span><span class="sxs-lookup"><span data-stu-id="c0985-729">You should consider how frequently you need to create new tables.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-730">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-730">When to use this pattern</span></span>
<span data-ttu-id="c0985-731">Dit patroon gebruiken wanneer u een groot aantal entiteiten die op hetzelfde moment moet u verwijderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-731">Use this pattern when you have a high volume of entities that you must delete at the same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-732">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-732">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-733">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-733">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-734">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-734">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="c0985-735">Entiteiten wijzigen</span><span class="sxs-lookup"><span data-stu-id="c0985-735">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="c0985-736">Patroon van de reeks gegevens</span><span class="sxs-lookup"><span data-stu-id="c0985-736">Data series pattern</span></span>
<span data-ttu-id="c0985-737">Store voltooid gegevensreeksen in één entiteit om te beperken het aantal aanvragen die u aanbrengt.</span><span class="sxs-lookup"><span data-stu-id="c0985-737">Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-738">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-738">Context and problem</span></span>
<span data-ttu-id="c0985-739">Er is een veelvoorkomend scenario voor een toepassing voor het opslaan van een reeks met gegevens die normaal gesproken nodig is om op te halen in één keer.</span><span class="sxs-lookup"><span data-stu-id="c0985-739">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</span></span> <span data-ttu-id="c0985-740">Uw toepassing kan bijvoorbeeld opname hoeveel IM-berichten elke werknemer elk uur en vervolgens deze informatie gebruiken om te tekenen hoeveel berichten elke gebruiker die is verzonden via de voorgaande 24 uur.</span><span class="sxs-lookup"><span data-stu-id="c0985-740">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</span></span> <span data-ttu-id="c0985-741">Een ontwerp kan voor het opslaan van 24 entiteiten voor elke werknemer zijn:</span><span class="sxs-lookup"><span data-stu-id="c0985-741">One design might be to store 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="c0985-742">Bij dit ontwerp kunt u eenvoudig zoeken en bijwerken van de entiteit voor elke werknemer bijwerken wanneer de toepassing moet de waarde voor aantal bijwerken.</span><span class="sxs-lookup"><span data-stu-id="c0985-742">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</span></span> <span data-ttu-id="c0985-743">Voor het ophalen van de informatie voor het tekenen van een grafiek van de activiteit voor de voorgaande 24 uur, moet u echter 24 entiteiten ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-743">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-744">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-744">Solution</span></span>
<span data-ttu-id="c0985-745">Het ontwerp van de volgende voor het opslaan van het aantal berichten voor elk uur een afzonderlijke eigenschap gebruiken:</span><span class="sxs-lookup"><span data-stu-id="c0985-745">Use the following design with a separate property to store the message count for each hour:</span></span>  

![][23]

<span data-ttu-id="c0985-746">Bij dit ontwerp kunt u een samenvoegbewerking voor het aantal berichten voor een werknemer bijwerken voor een specifiek uur.</span><span class="sxs-lookup"><span data-stu-id="c0985-746">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</span></span> <span data-ttu-id="c0985-747">U kunt nu alle informatie die u nodig hebt om het gebruik van een aanvraag voor een enkele entiteit diagram te tekenen ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-747">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-748">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-748">Issues and considerations</span></span>
<span data-ttu-id="c0985-749">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-749">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-750">Als de volledige reeks past niet in één entiteit (een entiteit kan maximaal 252 eigenschappen hebben), gebruikt u een alternatieve gegevensarchief, zoals een blob.</span><span class="sxs-lookup"><span data-stu-id="c0985-750">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="c0985-751">Als u meerdere clients tegelijkertijd bijwerken van een entiteit hebt, moet u gebruik van de **ETag** optimistische gelijktijdigheid implementeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-751">If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency.</span></span> <span data-ttu-id="c0985-752">Als u veel clients hebt, kunt u hoge conflicten ondervinden.</span><span class="sxs-lookup"><span data-stu-id="c0985-752">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-753">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-753">When to use this pattern</span></span>
<span data-ttu-id="c0985-754">Dit patroon gebruiken als u wilt bijwerken en ophalen van een reeks die is gekoppeld aan een afzonderlijke entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-754">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-755">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-755">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-756">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-756">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-757">Grote entiteiten patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-757">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="c0985-758">Samenvoegen of vervangen</span><span class="sxs-lookup"><span data-stu-id="c0985-758">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="c0985-759">[Uiteindelijk consistent transacties patroon](#eventually-consistent-transactions-pattern) (als u de gegevensreeks in een blob opslaat)</span><span class="sxs-lookup"><span data-stu-id="c0985-759">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="c0985-760">Wide entiteiten patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-760">Wide entities pattern</span></span>
<span data-ttu-id="c0985-761">Gebruik van meerdere fysieke entiteiten voor het opslaan van logische entiteiten met meer dan 252 eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c0985-761">Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-762">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-762">Context and problem</span></span>
<span data-ttu-id="c0985-763">Een afzonderlijke entiteit kan maximaal 252 eigenschappen (met uitzondering van de verplichte eigenschappen) en kan niet meer dan 1 MB aan gegevens opslaan in totaal.</span><span class="sxs-lookup"><span data-stu-id="c0985-763">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="c0985-764">In een relationele database, doorgaans krijgt u ronde beperkingen met betrekking tot de grootte van een rij bij het toevoegen van een nieuwe tabel en een 1-op-1-relatie tussen deze twee afdwingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-764">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-765">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-765">Solution</span></span>
<span data-ttu-id="c0985-766">De tabel-service gebruikt, kunt u meerdere entiteiten ter vertegenwoordiging van een object één grote bedrijven met meer dan 252 eigenschappen opslaan.</span><span class="sxs-lookup"><span data-stu-id="c0985-766">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="c0985-767">Bijvoorbeeld, als u een telling van het aantal IM-berichten is verzonden door elke werknemer voor de afgelopen 365 dagen opslaan wilt, kunt u het ontwerp van de volgende die gebruikmaakt van twee entiteiten met verschillende schema's:</span><span class="sxs-lookup"><span data-stu-id="c0985-767">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="c0985-768">U kunt een EGT gebruiken als u een wijziging aanbrengt die is vereist voor het bijwerken van beide entiteiten wilt zodat ze zijn gesynchroniseerd met elkaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-768">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="c0985-769">Anders kunt u één samenvoegbewerking bijwerken van het aantal berichten voor een specifieke dag.</span><span class="sxs-lookup"><span data-stu-id="c0985-769">Otherwise, you can use a single merge operation to update the message count for a specific day.</span></span> <span data-ttu-id="c0985-770">Alle gegevens ophalen voor een afzonderlijke werknemer moet u beide entiteiten, kunt u doen met twee efficiënte aanvragen die gebruikmaken van beide ophalen een **PartitionKey** en een **RowKey** waarde.</span><span class="sxs-lookup"><span data-stu-id="c0985-770">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-771">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-771">Issues and considerations</span></span>
<span data-ttu-id="c0985-772">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-772">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-773">Bij het ophalen van een volledige logische entiteit ten minste twee opslagtransacties omvat: een voor elke fysieke entiteit ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-773">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-774">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-774">When to use this pattern</span></span>
<span data-ttu-id="c0985-775">Gebruik dit patroon wanneer nodig voor het opslaan van entiteiten waarvan de grootte van of het aantal eigenschappen de grenzen voor een afzonderlijke entiteit in de tabel-service overschrijdt.</span><span class="sxs-lookup"><span data-stu-id="c0985-775">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-776">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-776">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-777">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-777">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-778">Entiteit groep transacties</span><span class="sxs-lookup"><span data-stu-id="c0985-778">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="c0985-779">Samenvoegen of vervangen</span><span class="sxs-lookup"><span data-stu-id="c0985-779">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="c0985-780">Grote entiteiten patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-780">Large entities pattern</span></span>
<span data-ttu-id="c0985-781">Blob storage gebruiken voor het opslaan van grote eigenschapswaarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-781">Use blob storage to store large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-782">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-782">Context and problem</span></span>
<span data-ttu-id="c0985-783">Een afzonderlijke entiteit kan niet meer dan 1 MB aan gegevens opslaan in totaal.</span><span class="sxs-lookup"><span data-stu-id="c0985-783">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="c0985-784">Als een of meer van de eigenschappen van uw waarden die ertoe leiden dat de totale grootte van uw entiteit zijn dan deze waarde kunt opslaan, kunt u het geheel niet opslaan in de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-784">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="c0985-785">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-785">Solution</span></span>
<span data-ttu-id="c0985-786">Als uw entiteit 1 MB groot overschrijdt omdat een of meer eigenschappen een grote hoeveelheid gegevens bevatten, kunt u gegevens opslaan in de Blob-service en het adres van de blob op te slaan in een eigenschap in de entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-786">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</span></span> <span data-ttu-id="c0985-787">Bijvoorbeeld, u kunt de foto van een werknemer opslaan in blob-opslag en opslaan van een koppeling naar de foto in de **Photo** eigenschap van de werknemer entiteit:</span><span class="sxs-lookup"><span data-stu-id="c0985-787">For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-788">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-788">Issues and considerations</span></span>
<span data-ttu-id="c0985-789">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-789">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-790">Gebruiken om te blijven uiteindelijke consistentie tussen de entiteit in de tabel-service en de gegevens in de Blob-service, de [uiteindelijk consistent transacties patroon](#eventually-consistent-transactions-pattern) uw entiteiten onderhouden.</span><span class="sxs-lookup"><span data-stu-id="c0985-790">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.</span></span>
* <span data-ttu-id="c0985-791">Bij het ophalen van een volledige entiteit ten minste twee opslagtransacties omvat: één voor het ophalen van de entiteit en één voor het ophalen van de blob-gegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-791">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-792">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-792">When to use this pattern</span></span>
<span data-ttu-id="c0985-793">Dit patroon gebruikt als u voor het opslaan van entiteiten waarvan de grootte de grenzen voor een afzonderlijke entiteit in de tabel-service overschrijdt.</span><span class="sxs-lookup"><span data-stu-id="c0985-793">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-794">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-794">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-795">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-795">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-796">Uiteindelijk consistent transacties patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-796">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="c0985-797">Wide entiteiten patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-797">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="c0985-798">Antivirusprogramma patroon toevoegen/toevoegen</span><span class="sxs-lookup"><span data-stu-id="c0985-798">Prepend/append anti-pattern</span></span>
<span data-ttu-id="c0985-799">Schaalbaarheid vergroten wanneer u een groot aantal invoegingen hebt met de invoegt verspreid over meerdere partities.</span><span class="sxs-lookup"><span data-stu-id="c0985-799">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-800">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-800">Context and problem</span></span>
<span data-ttu-id="c0985-801">Voorafgaand of entiteiten doorgaans in te voegen aan uw opgeslagen entiteiten resulteert in de toepassing nieuwe entiteiten toe te voegen aan de eerste of laatste partitie van een reeks van partities.</span><span class="sxs-lookup"><span data-stu-id="c0985-801">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="c0985-802">In dit geval plaatsvinden alle van de invoegt op elk moment in dezelfde partitie maken van een hotspot waarmee wordt voorkomen de tabelservice van load voegt te verdelen over meerdere knooppunten en mogelijk veroorzaakt door uw toepassing dat om de schaalbaarheidsdoelen voor partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-802">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</span></span> <span data-ttu-id="c0985-803">Bijvoorbeeld, als u een toepassing hebt die netwerk logboeken en toegang tot bedrijfsbronnen door werknemers, klikt u vervolgens een entiteit structuur zoals hieronder wordt weergegeven in het huidige uur partitie een hotspot is als het volume van transacties het doel van de schaalbaarheid van een afzonderlijke partitie bereikt kan leiden:</span><span class="sxs-lookup"><span data-stu-id="c0985-803">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour's partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="c0985-804">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-804">Solution</span></span>
<span data-ttu-id="c0985-805">De volgende alternatieve entiteit structuur voorkomt een hotspot op een bepaalde partitie als de toepassing Logboeken gebeurtenissen:</span><span class="sxs-lookup"><span data-stu-id="c0985-805">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</span></span>  

![][27]

<span data-ttu-id="c0985-806">Kennisgeving met dit voorbeeld van hoe beide de **PartitionKey** en **RowKey** samengestelde sleutels.</span><span class="sxs-lookup"><span data-stu-id="c0985-806">Notice with this example how both the **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="c0985-807">De **PartitionKey** gebruikt de afdeling en de werknemer-id om de logboekregistratie verdelen over meerdere partities.</span><span class="sxs-lookup"><span data-stu-id="c0985-807">The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-808">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-808">Issues and considerations</span></span>
<span data-ttu-id="c0985-809">Houd rekening met de volgende punten bij het bepalen van het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-809">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="c0985-810">Ondersteunt de alternatieve sleutelstructuur die voorkomt efficiënt hot partities maken op voegt de query's kunt u de clienttoepassing?</span><span class="sxs-lookup"><span data-stu-id="c0985-810">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</span></span>  
* <span data-ttu-id="c0985-811">Het verwachte volume van transacties betekent dat u waarschijnlijk de schaalbaarheidsdoelen voor een afzonderlijke partitie bereiken en worden beperkt door de storage-service?</span><span class="sxs-lookup"><span data-stu-id="c0985-811">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="c0985-812">Het gebruik van dit patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-812">When to use this pattern</span></span>
<span data-ttu-id="c0985-813">Vermijd het prepend/append anti-patroon wanneer het volume van transacties kunnen ertoe leiden dat door de storage-service beperken wanneer u een hot partitie is.</span><span class="sxs-lookup"><span data-stu-id="c0985-813">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="c0985-814">Verwante patronen en richtlijnen</span><span class="sxs-lookup"><span data-stu-id="c0985-814">Related patterns and guidance</span></span>
<span data-ttu-id="c0985-815">De volgende patronen en richtlijnen mogelijk ook relevante bij het implementeren van dit patroon:</span><span class="sxs-lookup"><span data-stu-id="c0985-815">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="c0985-816">Samengestelde sleutel patroon</span><span class="sxs-lookup"><span data-stu-id="c0985-816">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="c0985-817">Patroon voor logboekbestand staart</span><span class="sxs-lookup"><span data-stu-id="c0985-817">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="c0985-818">Entiteiten wijzigen</span><span class="sxs-lookup"><span data-stu-id="c0985-818">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="c0985-819">Antivirusprogramma patroon voor logboekbestand gegevens</span><span class="sxs-lookup"><span data-stu-id="c0985-819">Log data anti-pattern</span></span>
<span data-ttu-id="c0985-820">Normaal gesproken moet u de Blob-service in plaats van de tabel-service voor het opslaan van gegevens aan het logboek.</span><span class="sxs-lookup"><span data-stu-id="c0985-820">Typically, you should use the Blob service instead of the Table service to store log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="c0985-821">Context en probleem</span><span class="sxs-lookup"><span data-stu-id="c0985-821">Context and problem</span></span>
<span data-ttu-id="c0985-822">Als u een algemeen gebruiksvoorbeeld voor logboekgegevens is voor het ophalen van een selectie van vermeldingen in het logboek voor een specifieke datum/tijd-bereik: bijvoorbeeld wordt gezocht naar alle fout en kritieke berichten die uw toepassing vastgelegd tussen 15:04 en 15:06 op een bepaalde datum.</span><span class="sxs-lookup"><span data-stu-id="c0985-822">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="c0985-823">U niet wilt dat de datum en tijd van het logboekbericht gebruiken om te bepalen van de partitie opslaan van entiteiten logboek: die resulteert in een hot partitie omdat er op elk gewenst alle entiteiten in het logboek wordt delen dezelfde **PartitionKey** waarde (Zie de sectie [antivirusprogramma patroon Prepend/append](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="c0985-823">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="c0985-824">Het volgende schema van de entiteit voor een logboekbericht resulteert bijvoorbeeld in een hot partitie omdat de toepassing alle berichten in het logboek voor de partitie voor de huidige datum en het uur schrijft:</span><span class="sxs-lookup"><span data-stu-id="c0985-824">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</span></span>  

![][28]

<span data-ttu-id="c0985-825">In dit voorbeeld wordt de **RowKey** bevat de datum en tijd van het logboekbericht om ervoor te zorgen dat logboekberichten worden opgeslagen in datum/tijd-volgorde gesorteerd en bevat een bericht-id als meerdere logboekberichten de dezelfde datum en tijd delen.</span><span class="sxs-lookup"><span data-stu-id="c0985-825">In this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</span></span>  

<span data-ttu-id="c0985-826">Een andere manier is het gebruik van een **PartitionKey** die ervoor zorgt dat de toepassing berichten over een reeks partities schrijft.</span><span class="sxs-lookup"><span data-stu-id="c0985-826">Another approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions.</span></span> <span data-ttu-id="c0985-827">Als de bron van het logboekbericht een manier biedt voor de distributie van berichten over veel partities, kan u bijvoorbeeld het volgende schema voor de entiteit gebruiken:</span><span class="sxs-lookup"><span data-stu-id="c0985-827">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</span></span>  

![][29]

<span data-ttu-id="c0985-828">Het probleem met dit schema is echter voor het ophalen van de logboekberichten voor een bepaalde periode moet u elke partitie zoeken in de tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-828">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</span></span>

#### <a name="solution"></a><span data-ttu-id="c0985-829">Oplossing</span><span class="sxs-lookup"><span data-stu-id="c0985-829">Solution</span></span>
<span data-ttu-id="c0985-830">De vorige sectie het probleem van de tabel-service gebruiken voor het opslaan van logboekvermeldingen en voorgestelde twee onvoldoende, ontwerpen probeert gemarkeerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-830">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="c0985-831">Een oplossing heeft geleid tot een hot partitie met het risico van slechte prestaties schrijven logboekberichten; de andere oplossing heeft geresulteerd in slechte queryprestaties vanwege de vereisten voor het scannen van elke partitie in de tabel voor het ophalen van berichten in het logboek voor een bepaalde periode.</span><span class="sxs-lookup"><span data-stu-id="c0985-831">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</span></span> <span data-ttu-id="c0985-832">BLOB storage biedt een betere oplossing voor dit soort scenario en dit is hoe Azure Storage Analytics slaat de logboekgegevens worden verzameld.</span><span class="sxs-lookup"><span data-stu-id="c0985-832">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</span></span>  

<span data-ttu-id="c0985-833">Deze sectie geeft een overzicht van hoe opslag Analytics logboekgegevens opslaat in de blob-opslag ter illustratie van deze benadering voor het opslaan van gegevens die u doorgaans een query voor het bereik.</span><span class="sxs-lookup"><span data-stu-id="c0985-833">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</span></span>  

<span data-ttu-id="c0985-834">Storage Analytics slaat logboekberichten in een indeling met scheidingstekens in meerdere blobs.</span><span class="sxs-lookup"><span data-stu-id="c0985-834">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="c0985-835">De indeling gescheiden eenvoudig een clienttoepassing parseren van de gegevens in het logboekbericht.</span><span class="sxs-lookup"><span data-stu-id="c0985-835">The delimited format makes it easy for a client application to parse the data in the log message.</span></span>  

<span data-ttu-id="c0985-836">Storage Analytics maakt gebruik van een naamgevingsconventie voor blobs die kunt u de blob vinden (of BLOB's) die de berichten in het logboek waarnaar u zoekt bevatten.</span><span class="sxs-lookup"><span data-stu-id="c0985-836">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</span></span> <span data-ttu-id="c0985-837">Een blob met de naam 'queue/2014/07/31/1800/000001.log' bevat bijvoorbeeld logboekberichten die betrekking hebben op de queue-service voor het uur om 18:00 uur op 31 juli 2014 wordt gestart.</span><span class="sxs-lookup"><span data-stu-id="c0985-837">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="c0985-838">De '000001' geeft aan dat dit het eerste logboekbestand voor deze periode.</span><span class="sxs-lookup"><span data-stu-id="c0985-838">The "000001" indicates that this is the first log file for this period.</span></span> <span data-ttu-id="c0985-839">Storage Analytics registreert ook de tijdstempel van de eerste en laatste logboekberichten opgeslagen in het bestand als onderdeel van de blob-metagegevens.</span><span class="sxs-lookup"><span data-stu-id="c0985-839">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob's metadata.</span></span> <span data-ttu-id="c0985-840">De API voor blob-opslag kunt u blobs niet in een container op basis van een voorvoegsel vinden: om te zoeken in alle blobs die wachtrij logboekgegevens bevatten voor het beginnen bij 18:00 uur, kunt u het voorvoegsel "wachtrij/2014/07/31/1800."</span><span class="sxs-lookup"><span data-stu-id="c0985-840">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="c0985-841">Storage Analytics buffers Meld berichten intern en vervolgens regelmatig updates van de juiste blob of maakt u een nieuw bestand met de meest recente batch van logboekvermeldingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-841">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</span></span> <span data-ttu-id="c0985-842">Dit vermindert het aantal schrijft die deze naar de blob-service moet uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="c0985-842">This reduces the number of writes it must perform to the blob service.</span></span>  

<span data-ttu-id="c0985-843">Als u een vergelijkbare oplossing in uw eigen toepassing implementeert, moet u rekening houden met het beheren van de verhouding tussen betrouwbaarheid (elke logboekvermelding schrijven naar de blob-opslag als dit gebeurt) en de kosten en schaalbaarheid (buffer updates in uw toepassing en worden geschreven naar blob storage in batches).</span><span class="sxs-lookup"><span data-stu-id="c0985-843">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="c0985-844">Problemen en overwegingen</span><span class="sxs-lookup"><span data-stu-id="c0985-844">Issues and considerations</span></span>
<span data-ttu-id="c0985-845">Houd rekening met de volgende punten wanneer u beslist het opslaan van gegevens aan het logboek:</span><span class="sxs-lookup"><span data-stu-id="c0985-845">Consider the following points when deciding how to store log data:</span></span>  

* <span data-ttu-id="c0985-846">Als u een tabelontwerp dat potentiële hot partities voorkomt maakt, merkt u dat u geen toegang uw logboekgegevens efficiënt tot.</span><span class="sxs-lookup"><span data-stu-id="c0985-846">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="c0985-847">Voor het verwerken van gegevens aan het logboek moet een client vaak veel records laden.</span><span class="sxs-lookup"><span data-stu-id="c0985-847">To process log data, a client often needs to load many records.</span></span>  
* <span data-ttu-id="c0985-848">Hoewel logboekgegevens is vaak opgebouwd, kan de blob-opslag een betere oplossing zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-848">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="c0985-849">Overwegingen bij de implementatie</span><span class="sxs-lookup"><span data-stu-id="c0985-849">Implementation considerations</span></span>
<span data-ttu-id="c0985-850">Deze sectie worden enkele van de overwegingen op moet letten wanneer u de patronen die zijn beschreven in de vorige secties implementeert beschreven.</span><span class="sxs-lookup"><span data-stu-id="c0985-850">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</span></span> <span data-ttu-id="c0985-851">De meeste van deze sectie bevat voorbeelden geschreven in C# en die gebruikmaken van de Storage-clientbibliotheek (versie 4.3.0 op het moment van schrijven).</span><span class="sxs-lookup"><span data-stu-id="c0985-851">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="c0985-852">Entiteiten ophalen</span><span class="sxs-lookup"><span data-stu-id="c0985-852">Retrieving entities</span></span>
<span data-ttu-id="c0985-853">Zoals beschreven in de sectie [ontwerp voor het uitvoeren van query's](#design-for-querying), de meest efficiënte query is een punt-query.</span><span class="sxs-lookup"><span data-stu-id="c0985-853">As discussed in the section [Design for querying](#design-for-querying), the most efficient query is a point query.</span></span> <span data-ttu-id="c0985-854">In sommige scenario's moet u mogelijk echter meerdere entiteiten ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-854">However, in some scenarios you may need to retrieve multiple entities.</span></span> <span data-ttu-id="c0985-855">Deze sectie beschrijft een aantal algemene benaderingen bij het ophalen van entiteiten met behulp van de Storage-clientbibliotheek.</span><span class="sxs-lookup"><span data-stu-id="c0985-855">This section describes some common approaches to retrieving entities using the Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a><span data-ttu-id="c0985-856">Uitvoeren van een punt-query met behulp van de Storage-clientbibliotheek</span><span class="sxs-lookup"><span data-stu-id="c0985-856">Executing a point query using the Storage Client Library</span></span>
<span data-ttu-id="c0985-857">De eenvoudigste manier om het uitvoeren van een punt-query is met de **ophalen** bewerking tabel, zoals wordt weergegeven in het volgende C# codefragment die ophaalt van een entity met een **PartitionKey** van de waarde 'Verkoop' en een **RowKey** van de waarde '212':</span><span class="sxs-lookup"><span data-stu-id="c0985-857">The easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="c0985-858">U ziet hoe de entiteit in dit voorbeeld worden verwacht opgehaald om te worden van het type **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="c0985-858">Notice how this example expects the entity it retrieves to be of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="c0985-859">Bij het ophalen van meerdere entiteiten met behulp van LINQ</span><span class="sxs-lookup"><span data-stu-id="c0985-859">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="c0985-860">U kunt meerdere entiteiten ophalen met behulp van LINQ met Storage-clientbibliotheek en het opgeven van een query met een **waar** component.</span><span class="sxs-lookup"><span data-stu-id="c0985-860">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="c0985-861">Om te voorkomen dat een tabelscan, moet u altijd opnemen de **PartitionKey** waarde in de where-component, en indien mogelijk de **RowKey** waarde om te voorkomen dat de tabel en partitie scans.</span><span class="sxs-lookup"><span data-stu-id="c0985-861">To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans.</span></span> <span data-ttu-id="c0985-862">De tabelservice ondersteunt een beperkte set vergelijkingsoperators (groter dan groter dan of gelijk is, minder dan, kleiner dan of gelijk zijn, gelijk en niet gelijk) te gebruiken in de where component.</span><span class="sxs-lookup"><span data-stu-id="c0985-862">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</span></span> <span data-ttu-id="c0985-863">De volgende C#-codefragment vindt alle werknemers waarvan de laatste naam begint met "B" (ervan uitgaande dat de **RowKey** slaat de achternaam) in de afdeling verkoop (ervan uitgaande dat de **PartitionKey** slaat de afdelingsnaam):</span><span class="sxs-lookup"><span data-stu-id="c0985-863">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="c0985-864">U ziet hoe de query is zowel een **RowKey** en een **PartitionKey** betere prestaties te garanderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-864">Notice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.</span></span>  

<span data-ttu-id="c0985-865">Het volgende codevoorbeeld toont dezelfde functionaliteit beheersen API gebruiken (Zie voor meer informatie over beheersen API's in het algemeen [aanbevolen procedures voor het ontwerpen van een beheersen API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span><span class="sxs-lookup"><span data-stu-id="c0985-865">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="c0985-866">Het voorbeeld worden genest meerdere **CombineFilters** methoden voor het opnemen van de drie filtervoorwaarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-866">The sample nests multiple **CombineFilters** methods to include the three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="c0985-867">Groot aantal entiteiten ophalen uit een query</span><span class="sxs-lookup"><span data-stu-id="c0985-867">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="c0985-868">Een optimale query retourneert een afzonderlijke entiteit op basis van een **PartitionKey** waarde en een **RowKey** waarde.</span><span class="sxs-lookup"><span data-stu-id="c0985-868">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="c0985-869">In sommige scenario's hebben u echter een vereiste is te groot aantal entiteiten retourneren vanuit dezelfde partitie of zelfs via veel partities.</span><span class="sxs-lookup"><span data-stu-id="c0985-869">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</span></span>  

<span data-ttu-id="c0985-870">In dergelijke gevallen moet u altijd volledig de prestaties van uw toepassing testen.</span><span class="sxs-lookup"><span data-stu-id="c0985-870">You should always fully test the performance of your application in such scenarios.</span></span>  

<span data-ttu-id="c0985-871">Een query op de tabelservice kan maximaal 1000 entiteiten in één keer worden geretourneerd en wordt uitgevoerd voor een maximum van vijf seconden.</span><span class="sxs-lookup"><span data-stu-id="c0985-871">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="c0985-872">Als de resultatenset bevat meer dan 1000 entiteiten, als de query is niet voltooid binnen vijf seconden, of als de query overschrijdt de grens van de partitie is, retourneert de tabel-service een vervolgtoken zodat de clienttoepassing om aan te vragen van de volgende set van entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-872">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</span></span> <span data-ttu-id="c0985-873">Zie voor meer informatie over hoe voortzetting werk tokens [querytime-out en paginering](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0985-873">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="c0985-874">Als u de Storage-clientbibliotheek gebruikt, kan deze automatisch voortzetting tokens voor u verwerken als deze entiteiten uit de tabelservice retourneert.</span><span class="sxs-lookup"><span data-stu-id="c0985-874">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</span></span> <span data-ttu-id="c0985-875">De volgende C# voorbeeldcode met behulp van de Storage-clientbibliotheek automatisch verwerkt voortzetting tokens als de tabelservice die in een antwoord retourneert:</span><span class="sxs-lookup"><span data-stu-id="c0985-875">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="c0985-876">De volgende C#-code voortzetting tokens expliciet worden verwerkt:</span><span class="sxs-lookup"><span data-stu-id="c0985-876">The following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="c0985-877">Voortzetting tokens expliciet gebruikt, kunt u bepalen wanneer de toepassing wordt het volgende segment van gegevens wordt opgehaald.</span><span class="sxs-lookup"><span data-stu-id="c0985-877">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</span></span> <span data-ttu-id="c0985-878">Bijvoorbeeld, als uw clienttoepassing kan gebruikers op de pagina via de entiteiten die zijn opgeslagen in een tabel, een gebruiker kan niet meer wilt pagina via de entiteiten die zijn opgehaald door de query zodat uw toepassing een vervolgtoken alleen gebruiken zou voor het ophalen van het volgende segment wanneer de gebruiker had voltooid paging via alle entiteiten in het huidige segment.</span><span class="sxs-lookup"><span data-stu-id="c0985-878">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</span></span> <span data-ttu-id="c0985-879">Deze methode biedt verschillende voordelen:</span><span class="sxs-lookup"><span data-stu-id="c0985-879">This approach has several benefits:</span></span>  

* <span data-ttu-id="c0985-880">Hiermee kunt u de hoeveelheid gegevens op te halen uit de tabel-service beperken en die u via het netwerk verplaatst.</span><span class="sxs-lookup"><span data-stu-id="c0985-880">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</span></span>  
* <span data-ttu-id="c0985-881">Hiermee kunt u het uitvoeren van asynchrone IO in .NET.</span><span class="sxs-lookup"><span data-stu-id="c0985-881">It enables you to perform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="c0985-882">Hiermee kunt u voor het serialiseren van het vervolgtoken naar de permanente opslag zodat u kunt doorgaan in het geval van een toepassing is vastgelopen.</span><span class="sxs-lookup"><span data-stu-id="c0985-882">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="c0985-883">Een vervolgtoken retourneert doorgaans een segment met 1000 entiteiten, hoewel deze mogelijk minder.</span><span class="sxs-lookup"><span data-stu-id="c0985-883">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="c0985-884">Dit is ook het geval als u het aantal vermeldingen met behulp van een query retourneert beperken **nemen** te retourneren van de eerste n entiteiten die voldoen aan uw criteria lookup: de tabelservice kan een segment met minder dan n entiteiten samen met een vervolgtoken waarmee u kunt de resterende entiteiten ophalen geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-884">This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</span></span>  
> 
> 

<span data-ttu-id="c0985-885">De volgende C#-code wordt getoond hoe u het aantal entiteiten die zijn geretourneerd binnen een segment wijzigen:</span><span class="sxs-lookup"><span data-stu-id="c0985-885">The following C# code shows how to modify the number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="c0985-886">Projectie-serverzijde</span><span class="sxs-lookup"><span data-stu-id="c0985-886">Server-side projection</span></span>
<span data-ttu-id="c0985-887">Één entiteit kan maximaal 255 eigenschappen hebben en maximaal 1 MB groot zijn.</span><span class="sxs-lookup"><span data-stu-id="c0985-887">A single entity can have up to 255 properties and be up to 1 MB in size.</span></span> <span data-ttu-id="c0985-888">Wanneer u een query uitvoeren op de tabel en entiteiten ophalen, moet u wellicht niet alle eigenschappen en ervaren onnodig (als u wilt verminderen en de kosten van latentie) kunt voorkomen.</span><span class="sxs-lookup"><span data-stu-id="c0985-888">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</span></span> <span data-ttu-id="c0985-889">U kunt serverzijde projectie gebruiken om over te dragen alleen de eigenschappen die u nodig hebt.</span><span class="sxs-lookup"><span data-stu-id="c0985-889">You can use server-side projection to transfer just the properties you need.</span></span> <span data-ttu-id="c0985-890">Het volgende voorbeeld is haalt alleen de **e** eigenschap (samen met **PartitionKey**, **RowKey**, **tijdstempel**, en **ETag**) van de entiteiten die zijn geselecteerd door de query.</span><span class="sxs-lookup"><span data-stu-id="c0985-890">The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="c0985-891">U ziet hoe de **RowKey** waarde is beschikbaar, zelfs als deze niet is opgenomen in de lijst met eigenschappen om op te halen.</span><span class="sxs-lookup"><span data-stu-id="c0985-891">Notice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="c0985-892">Entiteiten wijzigen</span><span class="sxs-lookup"><span data-stu-id="c0985-892">Modifying entities</span></span>
<span data-ttu-id="c0985-893">De Storage-clientbibliotheek kunt u de entiteiten die zijn opgeslagen in de tabelservice door invoegen, verwijderen en bijwerken van entiteiten wijzigen.</span><span class="sxs-lookup"><span data-stu-id="c0985-893">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="c0985-894">U kunt EGTs batch meerdere insert, update en delete-bewerkingen samen in Verminder het aantal retouren vereist en de prestaties van uw oplossing verbeteren.</span><span class="sxs-lookup"><span data-stu-id="c0985-894">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</span></span>  

<span data-ttu-id="c0985-895">Rekening mee dat uitzonderingen die worden gegenereerd wanneer de Opslagclientbibliotheek wordt uitgevoerd een EGT doorgaans de index van de entiteit die de batch mislukken veroorzaakt.</span><span class="sxs-lookup"><span data-stu-id="c0985-895">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</span></span> <span data-ttu-id="c0985-896">Dit is handig wanneer u code die gebruikmaakt van EGTs foutopsporing.</span><span class="sxs-lookup"><span data-stu-id="c0985-896">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="c0985-897">U moet ook overwegen hoe uw ontwerp is van invloed op hoe de clienttoepassing gelijktijdigheid van taken en updatebewerkingen verwerkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-897">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="c0985-898">Gelijktijdigheid van taken beheren</span><span class="sxs-lookup"><span data-stu-id="c0985-898">Managing concurrency</span></span>
<span data-ttu-id="c0985-899">Standaard implementeert de tabelservice optimistische gelijktijdigheid controleert op het niveau van afzonderlijke entiteiten voor **invoegen**, **samenvoegen**, en **verwijderen** bewerkingen, hoewel het mogelijk voor een client om af te dwingen van de tabelservice voor het overslaan van deze controles.</span><span class="sxs-lookup"><span data-stu-id="c0985-899">By default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks.</span></span> <span data-ttu-id="c0985-900">Zie voor meer informatie over hoe de tabelservice gelijktijdigheid beheert [gelijktijdigheid beheren in Microsoft Azure Storage](../storage/common/storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="c0985-900">For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](../storage/common/storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="c0985-901">Samenvoegen of vervangen</span><span class="sxs-lookup"><span data-stu-id="c0985-901">Merge or replace</span></span>
<span data-ttu-id="c0985-902">De **vervangen** methode van de **TableOperation** klasse altijd vervangen door de volledige entiteit in de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-902">The **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service.</span></span> <span data-ttu-id="c0985-903">Als u geen een eigenschap in de aanvraag wanneer deze eigenschap in de opgeslagen entiteit bestaat, wordt in de aanvraag die eigenschap verwijdert uit de opgeslagen entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-903">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</span></span> <span data-ttu-id="c0985-904">Tenzij u een eigenschap expliciet verwijderen uit een opgeslagen entiteit wilt, moet u elke eigenschap opnemen in de aanvraag.</span><span class="sxs-lookup"><span data-stu-id="c0985-904">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</span></span>  

<span data-ttu-id="c0985-905">U kunt de **samenvoegen** methode van de **TableOperation** klasse om te verminderen de hoeveelheid gegevens die u naar de tabel-service verzendt wanneer u wilt bijwerken van een entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-905">You can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity.</span></span> <span data-ttu-id="c0985-906">De **samenvoegen** methode alle eigenschappen in de opgeslagen entiteit vervangen door waarden van eigenschappen van de entiteit die is opgenomen in de aanvraag, maar blijft behouden alle eigenschappen in de opgeslagen entiteit die niet zijn opgenomen in de aanvraag.</span><span class="sxs-lookup"><span data-stu-id="c0985-906">The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</span></span> <span data-ttu-id="c0985-907">Dit is handig als u grote entiteiten en hoeft slechts een klein aantal eigenschappen in een aanvraag bijwerken.</span><span class="sxs-lookup"><span data-stu-id="c0985-907">This is useful if you have large entities and only need to update a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="c0985-908">De **vervangen** en **samenvoegen** twee methoden mislukken als de entiteit niet bestaat.</span><span class="sxs-lookup"><span data-stu-id="c0985-908">The **Replace** and **Merge** methods fail if the entity does not exist.</span></span> <span data-ttu-id="c0985-909">Als alternatief kunt u de **InsertOrReplace** en **InsertOrMerge** methoden die nieuwe entiteit maken als deze niet bestaat.</span><span class="sxs-lookup"><span data-stu-id="c0985-909">As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="c0985-910">Werken met heterogene Entiteitstypen</span><span class="sxs-lookup"><span data-stu-id="c0985-910">Working with heterogeneous entity types</span></span>
<span data-ttu-id="c0985-911">De tabel-service is een *schema minder* tabel archief dat betekent dat één tabel entiteiten van meerdere typen bieden geweldige flexibiliteit in uw ontwerp kunt opslaan.</span><span class="sxs-lookup"><span data-stu-id="c0985-911">The Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="c0985-912">Het volgende voorbeeld wordt een tabel die het opslaan van zowel werknemer en entiteiten van de afdeling:</span><span class="sxs-lookup"><span data-stu-id="c0985-912">The following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="c0985-913">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="c0985-913">PartitionKey</span></span></th>
<th><span data-ttu-id="c0985-914">RowKey</span><span class="sxs-lookup"><span data-stu-id="c0985-914">RowKey</span></span></th>
<th><span data-ttu-id="c0985-915">tijdstempel</span><span class="sxs-lookup"><span data-stu-id="c0985-915">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-916">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-916">FirstName</span></span></th>
<th><span data-ttu-id="c0985-917">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-917">LastName</span></span></th>
<th><span data-ttu-id="c0985-918">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-918">Age</span></span></th>
<th><span data-ttu-id="c0985-919">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-919">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-920">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-920">FirstName</span></span></th>
<th><span data-ttu-id="c0985-921">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-921">LastName</span></span></th>
<th><span data-ttu-id="c0985-922">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-922">Age</span></span></th>
<th><span data-ttu-id="c0985-923">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-923">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-924">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="c0985-924">DepartmentName</span></span></th>
<th><span data-ttu-id="c0985-925">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="c0985-925">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-926">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-926">FirstName</span></span></th>
<th><span data-ttu-id="c0985-927">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-927">LastName</span></span></th>
<th><span data-ttu-id="c0985-928">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-928">Age</span></span></th>
<th><span data-ttu-id="c0985-929">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-929">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="c0985-930">Denk eraan dat elke entiteit moet nog steeds **PartitionKey**, **RowKey**, en **tijdstempel** waarden, maar mogelijk elke gewenste set eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c0985-930">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="c0985-931">Bovendien, er is niets om aan te geven van het type van een entiteit, tenzij u ervoor kiest die gegevens ergens op te slaan.</span><span class="sxs-lookup"><span data-stu-id="c0985-931">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</span></span> <span data-ttu-id="c0985-932">Er zijn twee opties voor het identificeren van het entiteitstype:</span><span class="sxs-lookup"><span data-stu-id="c0985-932">There are two options for identifying the entity type:</span></span>  

* <span data-ttu-id="c0985-933">Toevoegen van het entiteitstype voor de **RowKey** (of mogelijk de **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="c0985-933">Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**).</span></span> <span data-ttu-id="c0985-934">Bijvoorbeeld: **EMPLOYEE_000123** of **DEPARTMENT_SALES** als **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-934">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="c0985-935">Gebruik een afzonderlijke eigenschap voor het vastleggen van het entiteitstype, zoals wordt weergegeven in de onderstaande tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-935">Use a separate property to record the entity type as shown in the table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="c0985-936">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="c0985-936">PartitionKey</span></span></th>
<th><span data-ttu-id="c0985-937">RowKey</span><span class="sxs-lookup"><span data-stu-id="c0985-937">RowKey</span></span></th>
<th><span data-ttu-id="c0985-938">tijdstempel</span><span class="sxs-lookup"><span data-stu-id="c0985-938">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-939">EntityType</span><span class="sxs-lookup"><span data-stu-id="c0985-939">EntityType</span></span></th>
<th><span data-ttu-id="c0985-940">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-940">FirstName</span></span></th>
<th><span data-ttu-id="c0985-941">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-941">LastName</span></span></th>
<th><span data-ttu-id="c0985-942">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-942">Age</span></span></th>
<th><span data-ttu-id="c0985-943">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-943">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-944">Werknemer</span><span class="sxs-lookup"><span data-stu-id="c0985-944">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-945">EntityType</span><span class="sxs-lookup"><span data-stu-id="c0985-945">EntityType</span></span></th>
<th><span data-ttu-id="c0985-946">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-946">FirstName</span></span></th>
<th><span data-ttu-id="c0985-947">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-947">LastName</span></span></th>
<th><span data-ttu-id="c0985-948">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-948">Age</span></span></th>
<th><span data-ttu-id="c0985-949">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-949">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-950">Werknemer</span><span class="sxs-lookup"><span data-stu-id="c0985-950">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-951">EntityType</span><span class="sxs-lookup"><span data-stu-id="c0985-951">EntityType</span></span></th>
<th><span data-ttu-id="c0985-952">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="c0985-952">DepartmentName</span></span></th>
<th><span data-ttu-id="c0985-953">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="c0985-953">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-954">Afdeling</span><span class="sxs-lookup"><span data-stu-id="c0985-954">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="c0985-955">EntityType</span><span class="sxs-lookup"><span data-stu-id="c0985-955">EntityType</span></span></th>
<th><span data-ttu-id="c0985-956">Voornaam</span><span class="sxs-lookup"><span data-stu-id="c0985-956">FirstName</span></span></th>
<th><span data-ttu-id="c0985-957">Achternaam</span><span class="sxs-lookup"><span data-stu-id="c0985-957">LastName</span></span></th>
<th><span data-ttu-id="c0985-958">Leeftijd</span><span class="sxs-lookup"><span data-stu-id="c0985-958">Age</span></span></th>
<th><span data-ttu-id="c0985-959">E-mail</span><span class="sxs-lookup"><span data-stu-id="c0985-959">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="c0985-960">Werknemer</span><span class="sxs-lookup"><span data-stu-id="c0985-960">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="c0985-961">De eerste optie, de entiteit prepending type de **RowKey**, is handig als er een kans bestaat dat twee entiteiten met verschillende typen wellicht dezelfde sleutelwaarde.</span><span class="sxs-lookup"><span data-stu-id="c0985-961">The first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value.</span></span> <span data-ttu-id="c0985-962">Deze groepen ook entiteiten van hetzelfde type samen in de partitie.</span><span class="sxs-lookup"><span data-stu-id="c0985-962">It also groups entities of the same type together in the partition.</span></span>  

<span data-ttu-id="c0985-963">De technieken beschreven in deze sectie zijn vooral relevant zijn voor de bespreking van de [relaties voor overname](#inheritance-relationships) eerder in deze handleiding in de sectie [modellering relaties](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="c0985-963">The techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="c0985-964">U moet rekening houden met inbegrip van een uniek versienummer op in de waarde van het type entiteit zodat clienttoepassingen ontwikkelen POCO-objecten en werken met verschillende versies.</span><span class="sxs-lookup"><span data-stu-id="c0985-964">You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="c0985-965">De rest van deze sectie beschrijft een aantal van de functies in de Storage-clientbibliotheek die werken met meerdere Entiteitstypen in dezelfde tabel vergemakkelijken.</span><span class="sxs-lookup"><span data-stu-id="c0985-965">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="c0985-966">Heterogene Entiteitstypen ophalen</span><span class="sxs-lookup"><span data-stu-id="c0985-966">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="c0985-967">Als u van de Storage-clientbibliotheek gebruikmaakt, hebt u drie opties voor het werken met meerdere Entiteitstypen.</span><span class="sxs-lookup"><span data-stu-id="c0985-967">If you are using the Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="c0985-968">Als u welk type van de entiteit die is opgeslagen met een specifieke weet **RowKey** en **PartitionKey** waarden, daarna u het entiteitstype opgeven kunt wanneer u de entiteit ophalen, zoals wordt weergegeven in de vorige twee voorbeelden die entiteiten van het type ophalen **EmployeeEntity**: [uitvoeren van een punt-query met behulp van de Storage-clientbibliotheek](#executing-a-point-query-using-the-storage-client-library) en [bij het ophalen van meerdere entiteiten met behulp van LINQ](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="c0985-968">If you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using the Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="c0985-969">De tweede optie is met de **DynamicTableEntity** type (een eigenschappenverzameling) in plaats van een concreet POCO entiteitstype (deze optie ook de prestaties mogelijk verbeterd omdat het is niet nodig voor het serialiseren en deserialiseren van de entiteit .NET-typen).</span><span class="sxs-lookup"><span data-stu-id="c0985-969">The second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</span></span> <span data-ttu-id="c0985-970">De volgende C#-code mogelijk meerdere entiteiten met verschillende typen opgehaald uit de tabel, maar retourneert alle entiteiten als **DynamicTableEntity** exemplaren.</span><span class="sxs-lookup"><span data-stu-id="c0985-970">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="c0985-971">Vervolgens wordt de **EntityType** eigenschap om te bepalen van het type van elke entiteit:</span><span class="sxs-lookup"><span data-stu-id="c0985-971">It then uses the **EntityType** property to determine the type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="c0985-972">Houd er rekening mee dat voor het ophalen van andere eigenschappen moet u de **TryGetValue** methode op de **eigenschappen** eigenschap van de **DynamicTableEntity** klasse.</span><span class="sxs-lookup"><span data-stu-id="c0985-972">Note that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="c0985-973">Een derde optie is om te combineren met behulp van de **DynamicTableEntity** type en een **EntityResolver** exemplaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-973">A third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="c0985-974">Hiermee kunt u omzetten in meerdere POCO-typen in dezelfde query.</span><span class="sxs-lookup"><span data-stu-id="c0985-974">This enables you to resolve to multiple POCO types in the same query.</span></span> <span data-ttu-id="c0985-975">In dit voorbeeld wordt de **EntityResolver** gemachtigde maakt gebruik van de **EntityType** eigenschap onderscheid maken tussen de twee typen entiteit die de query retourneert.</span><span class="sxs-lookup"><span data-stu-id="c0985-975">In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns.</span></span> <span data-ttu-id="c0985-976">De **los** methode gebruikt de **resolver** gemachtigde om op te lossen **DynamicTableEntity** exemplaren te **TableEntity** exemplaren.</span><span class="sxs-lookup"><span data-stu-id="c0985-976">The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="c0985-977">Heterogene Entiteitstypen wijzigen</span><span class="sxs-lookup"><span data-stu-id="c0985-977">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="c0985-978">U hoeft niet te weten van het type van een entiteit wilt verwijderen en u het type van een entiteit altijd weet wanneer u het invoegen.</span><span class="sxs-lookup"><span data-stu-id="c0985-978">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</span></span> <span data-ttu-id="c0985-979">U kunt echter **DynamicTableEntity** type zonder te weten van het type en zonder gebruik van een POCO-entiteitsklasse bijwerken van een entiteit.</span><span class="sxs-lookup"><span data-stu-id="c0985-979">However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="c0985-980">Het volgende codevoorbeeld één entiteit worden opgehaald en controleert de **EmployeeCount** eigenschap bestaat voordat u het bijwerkt.</span><span class="sxs-lookup"><span data-stu-id="c0985-980">The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="c0985-981">Beheren van toegang met handtekeningen voor gedeelde toegang</span><span class="sxs-lookup"><span data-stu-id="c0985-981">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="c0985-982">Shared Access Signature (SAS)-tokens kunt u toepassingen die client te wijzigen (en een query) tabelentiteiten rechtstreeks zonder de noodzaak om te verifiëren rechtstreeks met de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="c0985-982">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</span></span> <span data-ttu-id="c0985-983">Er zijn in principe drie belangrijke voordelen bij SAS gebruiken in uw toepassing:</span><span class="sxs-lookup"><span data-stu-id="c0985-983">Typically, there are three main benefits to using SAS in your application:</span></span>  

* <span data-ttu-id="c0985-984">U hoeft niet te distribueren naar een onbeveiligde platform (zoals een mobiel apparaat) sleutel van uw opslagaccount als u wilt toestaan dat het apparaat te openen en te wijzigen van de entiteiten in de tabel-service.</span><span class="sxs-lookup"><span data-stu-id="c0985-984">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</span></span>  
* <span data-ttu-id="c0985-985">U kunt offload deel van het werk die web-en werkrollen uitvoeren bij het beheren van uw entiteiten op clientapparaten zoals eindgebruikers, computers en mobiele apparaten.</span><span class="sxs-lookup"><span data-stu-id="c0985-985">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="c0985-986">U kunt een beperkte toewijzen en tijd beperkt set machtigingen voor een client (zoals alleen-lezen toegang tot specifieke bronnen toe te staan).</span><span class="sxs-lookup"><span data-stu-id="c0985-986">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</span></span>  

<span data-ttu-id="c0985-987">Zie voor meer informatie over het gebruik van SAS-tokens met de tabelservice [met behulp van Shared Access Signatures (SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="c0985-987">For more information about using SAS tokens with the Table service, see [Using Shared Access Signatures (SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="c0985-988">Echter, moet u nog steeds de SAS-tokens die de entiteiten in de tabelservice een clienttoepassing verlenen genereren: u moet dit doen in een omgeving met veilige toegang tot uw toegangscodes voor opslag.</span><span class="sxs-lookup"><span data-stu-id="c0985-988">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</span></span> <span data-ttu-id="c0985-989">Normaal, gebruikt u een web- of worker-rol voor het genereren van de SAS-tokens en ervoor zorgen dat ze de clienttoepassingen die toegang nodig tot de entiteiten.</span><span class="sxs-lookup"><span data-stu-id="c0985-989">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</span></span> <span data-ttu-id="c0985-990">Omdat er nog steeds een overhead voor het genereren en leveren van SAS-tokens op clients, moet u het beste aan deze overhead, met name in grootschalige scenario's verminderen.</span><span class="sxs-lookup"><span data-stu-id="c0985-990">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="c0985-991">Het is mogelijk om een SAS-token die toegang tot een subset van de entiteiten in een tabel verleent te genereren.</span><span class="sxs-lookup"><span data-stu-id="c0985-991">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</span></span> <span data-ttu-id="c0985-992">U maakt standaard een SAS-token voor een hele tabel, maar het is ook mogelijk om op te geven dat het SAS-token toegang verlenen tot een bereik van **PartitionKey** waarden of een bereik van **PartitionKey** en **RowKey** waarden.</span><span class="sxs-lookup"><span data-stu-id="c0985-992">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="c0985-993">U kunt selecteren voor het genereren van SAS-tokens voor afzonderlijke gebruikers van uw systeem dat de SAS-token van elke gebruiker kan alleen ze toegang tot hun eigen entiteiten in de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="c0985-993">You might choose to generate SAS tokens for individual users of your system such that each user's SAS token only allows them access to their own entities in the table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="c0985-994">Asynchrone en parallelle bewerkingen</span><span class="sxs-lookup"><span data-stu-id="c0985-994">Asynchronous and parallel operations</span></span>
<span data-ttu-id="c0985-995">Mits u kunt uw verzoeken om te worden verspreid over meerdere partities, kunt u de doorvoer en client reactiesnelheid verbeteren met behulp van asynchrone of parallelle query's.</span><span class="sxs-lookup"><span data-stu-id="c0985-995">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="c0985-996">U wellicht bijvoorbeeld twee of meer werkprocessen rolinstanties toegang krijgen tot uw tabellen parallel.</span><span class="sxs-lookup"><span data-stu-id="c0985-996">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="c0985-997">U kunt afzonderlijke werkrollen die verantwoordelijk zijn voor bepaalde sets van partities hebben of gewoon hebben meerdere worker rolinstanties, elke toegang kunnen krijgen tot alle partities in een tabel.</span><span class="sxs-lookup"><span data-stu-id="c0985-997">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</span></span>  

<span data-ttu-id="c0985-998">U kunt binnen een clientexemplaar doorvoer verbeteren door opslagbewerkingen asynchroon uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c0985-998">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="c0985-999">De Storage-clientbibliotheek kunt eenvoudig schrijven van asynchrone query's en wijzigingen.</span><span class="sxs-lookup"><span data-stu-id="c0985-999">The Storage Client Library makes it easy to write asynchronous queries and modifications.</span></span> <span data-ttu-id="c0985-1000">Bijvoorbeeld, kunt u bijvoorbeeld starten met de synchrone methode die alle entiteiten in een partitie haalt zoals weergegeven in de volgende C#-code:</span><span class="sxs-lookup"><span data-stu-id="c0985-1000">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="c0985-1001">U kunt deze code eenvoudig wijzigen zodat de query wordt asynchroon als volgt uitgevoerd:</span><span class="sxs-lookup"><span data-stu-id="c0985-1001">You can easily modify this code so that the query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="c0985-1002">In dit voorbeeld asynchrone ziet u de volgende wijzigingen van de synchrone versie:</span><span class="sxs-lookup"><span data-stu-id="c0985-1002">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="c0985-1003">Handtekening van de methode bevat nu de **asynchrone** aanpassingsfunctie en retourneert een **taak** exemplaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-1003">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="c0985-1004">In plaats van aanroepen de **ExecuteSegmented** methode voor het ophalen van de resultaten van de methode nu roept de **ExecuteSegmentedAsync** methode en gebruikt de **await** aanpassingsfunctie resultaten asynchroon ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-1004">Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="c0985-1005">De clienttoepassing kan deze methode niet aanroepen meerdere keren (met verschillende waarden voor de **afdeling** parameter), en elke query wordt uitgevoerd op een afzonderlijke thread.</span><span class="sxs-lookup"><span data-stu-id="c0985-1005">The client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="c0985-1006">Houd er rekening mee dat er geen asynchrone versie van is de **Execute** methode in de **TableQuery** klasse omdat de **IEnumerable** interface ondersteunt geen asynchrone opsomming.</span><span class="sxs-lookup"><span data-stu-id="c0985-1006">Note that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="c0985-1007">U kunt invoegen, bijwerken en verwijderen van entiteiten asynchroon.</span><span class="sxs-lookup"><span data-stu-id="c0985-1007">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="c0985-1008">De volgende C#-voorbeeld ziet u een eenvoudige, synchrone methode invoegen of vervangen van een werknemer entiteit:</span><span class="sxs-lookup"><span data-stu-id="c0985-1008">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="c0985-1009">U kunt deze code eenvoudig wijzigen zodat de update wordt asynchroon als volgt uitgevoerd:</span><span class="sxs-lookup"><span data-stu-id="c0985-1009">You can easily modify this code so that the update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="c0985-1010">In dit voorbeeld asynchrone ziet u de volgende wijzigingen van de synchrone versie:</span><span class="sxs-lookup"><span data-stu-id="c0985-1010">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="c0985-1011">Handtekening van de methode bevat nu de **asynchrone** aanpassingsfunctie en retourneert een **taak** exemplaar.</span><span class="sxs-lookup"><span data-stu-id="c0985-1011">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="c0985-1012">In plaats van aanroepen de **Execute** methode voor het bijwerken van de entiteit, de methode nu roept de **ExecuteAsync** methode en gebruikt de **await** aanpassingsfunctie resultaten asynchroon ophalen.</span><span class="sxs-lookup"><span data-stu-id="c0985-1012">Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="c0985-1013">De clienttoepassing kan meerdere asynchrone methoden zoals deze aanroepen en elke methodeaanroep wordt uitgevoerd op een afzonderlijke thread.</span><span class="sxs-lookup"><span data-stu-id="c0985-1013">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="c0985-1014">Tegoed</span><span class="sxs-lookup"><span data-stu-id="c0985-1014">Credits</span></span>
<span data-ttu-id="c0985-1015">Wij willen graag Bedankt dat de volgende leden van het team van Azure voor hun bijdragen: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah en Serdar Ozler evenals Tom Hollander van Microsoft DX.</span><span class="sxs-lookup"><span data-stu-id="c0985-1015">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="c0985-1016">We willen ook graag Bedankt dat de volgende Microsoft MVP van voor hun waardevolle feedback in revisie runs: Igor Papirov en Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="c0985-1016">We would also like to thank the following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

