---
title: Azure Storage-controlelijst voor prestaties en schaalbaarheid | Microsoft Docs
description: Een controlelijst met bewezen voor gebruik met Azure Storage zodat toepassingen te ontwikkelen.
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c12f98b069689e335d308d8f8edba2dece21d806
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 07/11/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="d9fbb-103">Controlelijst voor prestaties en schaalbaarheid van Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="d9fbb-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="d9fbb-104">Overzicht</span><span class="sxs-lookup"><span data-stu-id="d9fbb-104">Overview</span></span>
<span data-ttu-id="d9fbb-105">Microsoft heeft een aantal beproefde procedures voor het gebruik van deze services op een manier zodat ontwikkeld sinds de release van de Microsoft Azure Storage-services en in dit artikel fungeert de belangrijkste hiervan consolideren in een controlelijst-stijl-lijst.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="d9fbb-106">De bedoeling van dit artikel is om te controleren of dat ze bewezen gebruiken met Azure Storage toepassingsontwikkelaars en zodat andere bewezen overstap overweegt identificeren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="d9fbb-107">In dit artikel probeert niet elke mogelijke optimalisatie van prestaties en schaalbaarheid omvatten, worden uitgesloten die gevolgen klein of niet algemeen van toepassing zijn.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="d9fbb-108">Voor zover dit gedrag van de toepassing kan worden voorspeld tijdens het ontwerpen, is het nuttig te houden in gedachten vroeg stadium te ontwerpen die wordt uitgevoerd in prestatieproblemen te voorkomen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="d9fbb-109">Elke ontwikkelaar van toepassingen met behulp van Azure Storage moet even de tijd in dit artikel lezen en controleren van toepassing zijn of haar volgt elk van de hieronder vermelde bewezen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="d9fbb-110">Controlelijst</span><span class="sxs-lookup"><span data-stu-id="d9fbb-110">Checklist</span></span>
<span data-ttu-id="d9fbb-111">In dit artikel worden de bewezen in de volgende groepen ingedeeld.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="d9fbb-112">Bewezen toepassingen die van toepassing op:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="d9fbb-113">Alle Azure Storage-services (blobs, tabellen, wachtrijen en -bestanden)</span><span class="sxs-lookup"><span data-stu-id="d9fbb-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="d9fbb-114">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-114">Blobs</span></span>
* <span data-ttu-id="d9fbb-115">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-115">Tables</span></span>
* <span data-ttu-id="d9fbb-116">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-116">Queues</span></span>  

| <span data-ttu-id="d9fbb-117">Klaar</span><span class="sxs-lookup"><span data-stu-id="d9fbb-117">Done</span></span> | <span data-ttu-id="d9fbb-118">Onderwerp</span><span class="sxs-lookup"><span data-stu-id="d9fbb-118">Area</span></span> | <span data-ttu-id="d9fbb-119">Category</span><span class="sxs-lookup"><span data-stu-id="d9fbb-119">Category</span></span> | <span data-ttu-id="d9fbb-120">Vraag</span><span class="sxs-lookup"><span data-stu-id="d9fbb-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="d9fbb-121">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-121">All Services</span></span> |<span data-ttu-id="d9fbb-122">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-122">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-123">Is uw toepassing ontworpen om te voorkomen dat de schaalbaarheidsdoelen bijna?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="d9fbb-124">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-124">All Services</span></span> |<span data-ttu-id="d9fbb-125">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-125">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-126">Is uw naamgevingsconventie ontworpen om in te schakelen beter taakverdeling?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="d9fbb-127">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-127">All Services</span></span> |<span data-ttu-id="d9fbb-128">Netwerken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-128">Networking</span></span> |[<span data-ttu-id="d9fbb-129">Hebt side clientapparaten hoog genoeg bandbreedte en lage latentie voor de prestaties die nodig zijn?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="d9fbb-130">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-130">All Services</span></span> |<span data-ttu-id="d9fbb-131">Netwerken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-131">Networking</span></span> |[<span data-ttu-id="d9fbb-132">Hebt clientapparaten naast een koppeling hoog genoeg kwaliteit?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="d9fbb-133">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-133">All Services</span></span> |<span data-ttu-id="d9fbb-134">Netwerken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-134">Networking</span></span> |[<span data-ttu-id="d9fbb-135">De clienttoepassing vindt 'aan' het storage-account?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="d9fbb-136">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-136">All Services</span></span> |<span data-ttu-id="d9fbb-137">Inhoudsdistributie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-137">Content Distribution</span></span> |[<span data-ttu-id="d9fbb-138">Gebruikt u de CDN voor distributie van inhoud?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="d9fbb-139">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-139">All Services</span></span> |<span data-ttu-id="d9fbb-140">Directe clienttoegang</span><span class="sxs-lookup"><span data-stu-id="d9fbb-140">Direct Client Access</span></span> |[<span data-ttu-id="d9fbb-141">Gebruikt u SAS en CORS voor directe toegang tot opslag in plaats van proxy toestaan?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="d9fbb-142">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-142">All Services</span></span> |<span data-ttu-id="d9fbb-143">Caching</span><span class="sxs-lookup"><span data-stu-id="d9fbb-143">Caching</span></span> |[<span data-ttu-id="d9fbb-144">Uw cache toepassingsgegevens die herhaaldelijk wordt gebruikt en de wijzigingen zelden is?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="d9fbb-145">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-145">All Services</span></span> |<span data-ttu-id="d9fbb-146">Caching</span><span class="sxs-lookup"><span data-stu-id="d9fbb-146">Caching</span></span> |[<span data-ttu-id="d9fbb-147">Is uw toepassing batchverwerking updates (deze clientzijde in cache en vervolgens uploaden in grotere sets)?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="d9fbb-148">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-148">All Services</span></span> |<span data-ttu-id="d9fbb-149">.NET-configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-149">.NET Configuration</span></span> |[<span data-ttu-id="d9fbb-150">Hebt u de client voor het gebruik van een voldoende aantal gelijktijdige verbindingen geconfigureerd?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="d9fbb-151">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-151">All Services</span></span> |<span data-ttu-id="d9fbb-152">.NET-configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-152">.NET Configuration</span></span> |[<span data-ttu-id="d9fbb-153">Hebt u .NET voor het gebruik van een voldoende aantal threads geconfigureerd?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="d9fbb-154">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-154">All Services</span></span> |<span data-ttu-id="d9fbb-155">.NET-configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-155">.NET Configuration</span></span> |[<span data-ttu-id="d9fbb-156">Gebruikt u de .NET 4.5 of hoger, waarop garbagecollection is verbeterd?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="d9fbb-157">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-157">All Services</span></span> |<span data-ttu-id="d9fbb-158">Parallelle uitvoering</span><span class="sxs-lookup"><span data-stu-id="d9fbb-158">Parallelism</span></span> |[<span data-ttu-id="d9fbb-159">U zorgt dat parallelle uitvoering op de juiste wijze wordt begrensd zodat u niet de clientmogelijkheden van de of de schaalbaarheidsdoelen van de overbelasting?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="d9fbb-160">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-160">All Services</span></span> |<span data-ttu-id="d9fbb-161">Hulpprogramma's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-161">Tools</span></span> |[<span data-ttu-id="d9fbb-162">Vindt u de nieuwste versie van Microsoft clientbibliotheken en hulpprogramma's?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="d9fbb-163">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-163">All Services</span></span> |<span data-ttu-id="d9fbb-164">Nieuwe pogingen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-164">Retries</span></span> |[<span data-ttu-id="d9fbb-165">Weet u exponentieel uitstel met beleid voor beperking van de fouten en time-outs voor opnieuw proberen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="d9fbb-166">Alle services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-166">All Services</span></span> |<span data-ttu-id="d9fbb-167">Nieuwe pogingen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-167">Retries</span></span> |[<span data-ttu-id="d9fbb-168">Is uw toepassing waarbij pogingen voor niet-herstelbare fouten?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="d9fbb-169">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-169">Blobs</span></span> |<span data-ttu-id="d9fbb-170">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-170">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-171">Hebt u een groot aantal clients tegelijkertijd toegang krijgen tot een enkel object?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="d9fbb-172">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-172">Blobs</span></span> |<span data-ttu-id="d9fbb-173">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-173">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-174">Is uw toepassing binnen het doel van de schaalbaarheid bandbreedte of bewerkingen voor één blob blijft?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="d9fbb-175">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-175">Blobs</span></span> |<span data-ttu-id="d9fbb-176">Blobs kopiëren</span><span class="sxs-lookup"><span data-stu-id="d9fbb-176">Copying Blobs</span></span> |[<span data-ttu-id="d9fbb-177">Weet u kopiëren blobs op efficiënte wijze?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="d9fbb-178">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-178">Blobs</span></span> |<span data-ttu-id="d9fbb-179">Blobs kopiëren</span><span class="sxs-lookup"><span data-stu-id="d9fbb-179">Copying Blobs</span></span> |[<span data-ttu-id="d9fbb-180">Gebruikt u AzCopy voor bulksgewijs kopieën van BLOB's?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="d9fbb-181">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-181">Blobs</span></span> |<span data-ttu-id="d9fbb-182">Blobs kopiëren</span><span class="sxs-lookup"><span data-stu-id="d9fbb-182">Copying Blobs</span></span> |[<span data-ttu-id="d9fbb-183">Gebruikt u Azure Import/Export om over te dragen van zeer grote hoeveelheden gegevens?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="d9fbb-184">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-184">Blobs</span></span> |<span data-ttu-id="d9fbb-185">Met behulp van metagegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-185">Use Metadata</span></span> |[<span data-ttu-id="d9fbb-186">Bewaart u veelgebruikte metagegevens over blobs in de metagegevens?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="d9fbb-187">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-187">Blobs</span></span> |<span data-ttu-id="d9fbb-188">Snel uploaden</span><span class="sxs-lookup"><span data-stu-id="d9fbb-188">Uploading Fast</span></span> |[<span data-ttu-id="d9fbb-189">Bij het snel uploaden van een blob, uploadt u blokken parallel?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="d9fbb-190">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-190">Blobs</span></span> |<span data-ttu-id="d9fbb-191">Snel uploaden</span><span class="sxs-lookup"><span data-stu-id="d9fbb-191">Uploading Fast</span></span> |[<span data-ttu-id="d9fbb-192">Wanneer u probeert veel blobs snel uploaden, uploadt u blobs parallel?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="d9fbb-193">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-193">Blobs</span></span> |<span data-ttu-id="d9fbb-194">Juiste Blob-Type</span><span class="sxs-lookup"><span data-stu-id="d9fbb-194">Correct Blob Type</span></span> |[<span data-ttu-id="d9fbb-195">Gebruikt u pagina-blobs of blok-blobs als het nodig?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="d9fbb-196">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-196">Tables</span></span> |<span data-ttu-id="d9fbb-197">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-197">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-198">Bent u bijna de schaalbaarheidsdoelen voor entiteiten per seconde?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="d9fbb-199">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-199">Tables</span></span> |<span data-ttu-id="d9fbb-200">Configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-200">Configuration</span></span> |[<span data-ttu-id="d9fbb-201">Gebruikt u JSON voor uw tabel aanvragen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="d9fbb-202">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-202">Tables</span></span> |<span data-ttu-id="d9fbb-203">Configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-203">Configuration</span></span> |[<span data-ttu-id="d9fbb-204">Hebt u uitgeschakeld Nagle verbeteren de prestaties van kleine aanvragen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="d9fbb-205">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-205">Tables</span></span> |<span data-ttu-id="d9fbb-206">Tabellen en partities</span><span class="sxs-lookup"><span data-stu-id="d9fbb-206">Tables and Partitions</span></span> |[<span data-ttu-id="d9fbb-207">Uw gegevens correct gepartitioneerd?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="d9fbb-208">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-208">Tables</span></span> |<span data-ttu-id="d9fbb-209">Hot partities</span><span class="sxs-lookup"><span data-stu-id="d9fbb-209">Hot Partitions</span></span> |[<span data-ttu-id="d9fbb-210">Weet u alleen toevoegen en voeg alleen-lezen patronen voorkomen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="d9fbb-211">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-211">Tables</span></span> |<span data-ttu-id="d9fbb-212">Hot partities</span><span class="sxs-lookup"><span data-stu-id="d9fbb-212">Hot Partitions</span></span> |[<span data-ttu-id="d9fbb-213">Worden uw bijgewerkte voegt verdeeld over veel partities?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="d9fbb-214">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-214">Tables</span></span> |<span data-ttu-id="d9fbb-215">Querybereik</span><span class="sxs-lookup"><span data-stu-id="d9fbb-215">Query Scope</span></span> |[<span data-ttu-id="d9fbb-216">Hebt u uw schema om toe te staan voor punt-query's moet worden gebruikt in de meeste gevallen en tabel query's moeten spaarzaam worden gebruikt die is ontworpen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="d9fbb-217">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-217">Tables</span></span> |<span data-ttu-id="d9fbb-218">Query-dichtheid</span><span class="sxs-lookup"><span data-stu-id="d9fbb-218">Query Density</span></span> |[<span data-ttu-id="d9fbb-219">Uw query's doorgaans alleen scan doen en retourneert de rijen die door uw toepassing wordt gebruikt?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="d9fbb-220">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-220">Tables</span></span> |<span data-ttu-id="d9fbb-221">Beperkende geretourneerde gegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-221">Limiting Returned Data</span></span> |[<span data-ttu-id="d9fbb-222">Gebruikt u voor het filteren om te voorkomen dat er geretourneerd entiteiten die niet nodig zijn?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="d9fbb-223">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-223">Tables</span></span> |<span data-ttu-id="d9fbb-224">Beperkende geretourneerde gegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-224">Limiting Returned Data</span></span> |[<span data-ttu-id="d9fbb-225">Gebruikt u projectie voorkomen dat er geretourneerd eigenschappen die niet nodig zijn?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="d9fbb-226">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-226">Tables</span></span> |<span data-ttu-id="d9fbb-227">Denormalization</span><span class="sxs-lookup"><span data-stu-id="d9fbb-227">Denormalization</span></span> |[<span data-ttu-id="d9fbb-228">Hebt u uw gegevens gedenormaliseerd zodat u inefficiënte query's of meerdere leesaanvragen voorkomen bij het ophalen van gegevens?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="d9fbb-229">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-229">Tables</span></span> |<span data-ttu-id="d9fbb-230">Invoegen, bijwerken, verwijderen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="d9fbb-231">Weet u batchverwerking aanvragen die moeten worden transactionele of op hetzelfde moment te verminderen retourbewerkingen kan worden uitgevoerd?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="d9fbb-232">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-232">Tables</span></span> |<span data-ttu-id="d9fbb-233">Invoegen, bijwerken, verwijderen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="d9fbb-234">Weet u vermijden bij het ophalen van een entiteit die u zojuist hebt om te bepalen of aan te roepen invoegen of bijwerken?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="d9fbb-235">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-235">Tables</span></span> |<span data-ttu-id="d9fbb-236">Invoegen, bijwerken, verwijderen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="d9fbb-237">Hebt u beschouwd als reeks gegevens dat wordt vaak opgehaald samen in één entiteit opslaan als eigenschappen in plaats van meerdere entiteiten?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="d9fbb-238">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-238">Tables</span></span> |<span data-ttu-id="d9fbb-239">Invoegen, bijwerken, verwijderen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="d9fbb-240">Voor entiteiten die wordt altijd samen worden opgehaald en kunnen worden geschreven in batches (bijvoorbeeld tijd reeksgegevens), hebt u beschouwd als blobs in plaats van tabellen gebruiken?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="d9fbb-241">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-241">Queues</span></span> |<span data-ttu-id="d9fbb-242">Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-242">Scalability Targets</span></span> |[<span data-ttu-id="d9fbb-243">Bent u bijna de schaalbaarheidsdoelen voor berichten die per seconde?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="d9fbb-244">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-244">Queues</span></span> |<span data-ttu-id="d9fbb-245">Configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-245">Configuration</span></span> |[<span data-ttu-id="d9fbb-246">Hebt u uitgeschakeld Nagle verbeteren de prestaties van kleine aanvragen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="d9fbb-247">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-247">Queues</span></span> |<span data-ttu-id="d9fbb-248">Berichtgrootte</span><span class="sxs-lookup"><span data-stu-id="d9fbb-248">Message Size</span></span> |[<span data-ttu-id="d9fbb-249">Uw berichten compact verbeteren de prestaties van de wachtrij zijn?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="d9fbb-250">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-250">Queues</span></span> |<span data-ttu-id="d9fbb-251">Bulksgewijs ophalen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-251">Bulk Retrieve</span></span> |[<span data-ttu-id="d9fbb-252">Weet u bij het ophalen van meerdere berichten in één bewerking 'Ophalen'?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="d9fbb-253">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-253">Queues</span></span> |<span data-ttu-id="d9fbb-254">Pollingfrequentie opgeven</span><span class="sxs-lookup"><span data-stu-id="d9fbb-254">Polling Frequency</span></span> |[<span data-ttu-id="d9fbb-255">Weet u polling vaak genoeg om te beperken van de merkbare latentie van uw toepassing?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="d9fbb-256">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-256">Queues</span></span> |<span data-ttu-id="d9fbb-257">Updatebericht</span><span class="sxs-lookup"><span data-stu-id="d9fbb-257">Update Message</span></span> |[<span data-ttu-id="d9fbb-258">Gebruikt u UpdateMessage voor het opslaan van voortgang in verwerking van berichten, waardoor wordt voorkomen dat het volledige bericht opnieuw verwerken als een fout optreedt?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="d9fbb-259">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-259">Queues</span></span> |<span data-ttu-id="d9fbb-260">Architectuur</span><span class="sxs-lookup"><span data-stu-id="d9fbb-260">Architecture</span></span> |[<span data-ttu-id="d9fbb-261">Gebruikt u wachtrijen ervoor dat uw hele toepassing meer schaalbare doordat langlopende werkbelastingen buiten het kritieke pad en vervolgens afzonderlijk van elkaar schalen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="d9fbb-262"><a name="allservices"></a>Alle Services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="d9fbb-263">Deze sectie vindt bewezen toepassingen die van toepassing op het gebruik van een van de Azure Storage-services (blobs, tabellen, wachtrijen of bestanden).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="d9fbb-264"><a name="subheading1"></a>Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="d9fbb-265">Elk van de Azure Storage-services heeft schaalbaarheidsdoelen voor capaciteit (GB), Transactiesnelheid en bandbreedte.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="d9fbb-266">Als uw toepassing nadert of hoger is dan een van de schaalbaarheidsdoelen, ondervinden het toegenomen transactie latenties of beperking.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="d9fbb-267">Wanneer een opslagservice uw toepassing bandbreedte, begint de service '503 Server bezet' of '500 time-out voor de bewerking' foutcodes voor sommige opslagtransacties als resultaat geven.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="d9fbb-268">Deze sectie wordt de algemene benadering voor het omgaan met schaalbaarheidsdoelen en schaalbaarheidsdoelen van bandbreedte, met name besproken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="d9fbb-269">Latere secties die betrekking op afzonderlijke opslagservices hebben behandeld schaalbaarheidsdoelen in de context van die service:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="d9fbb-270">BLOB-bandbreedte en aanvragen per seconde</span><span class="sxs-lookup"><span data-stu-id="d9fbb-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="d9fbb-271">Tabelentiteiten per seconde</span><span class="sxs-lookup"><span data-stu-id="d9fbb-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="d9fbb-272">Wachtrijberichten per seconde</span><span class="sxs-lookup"><span data-stu-id="d9fbb-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="d9fbb-273"><a name="sub1bandwidth"></a>Doel van schaalbaarheid bandbreedte voor alle Services</span><span class="sxs-lookup"><span data-stu-id="d9fbb-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="d9fbb-274">Op het moment van schrijven zijn de doelen van de bandbreedte in de Verenigde Staten voor een account met geografisch redundante opslag (GRS) 10 Gigabit per seconde (Gbps) voor inkomende (gegevens verzonden naar het opslagaccount) en 20 Gbps voor uitgaande (gegevens verzonden van het storage-account).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="d9fbb-275">Voor een account lokaal redundante opslag (LRS) de grenzen zijn hogere – 20 Gbps voor inkomend en 30 Gbps voor uitgaande.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="d9fbb-276">Internationale bandbreedtelimieten mogelijk lager en vindt u op onze [schaalbaarheid van de pagina](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="d9fbb-277">Zie voor meer informatie over de opties voor opslag redundantie de koppelingen in [nuttige informatiebronnen](#sub1useful) hieronder.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="d9fbb-278">Wat te doen wanneer een doel schaalbaarheid nadert</span><span class="sxs-lookup"><span data-stu-id="d9fbb-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="d9fbb-279">Als uw toepassing uitgevoerd, de schaalbaarheidsdoelen voor een enkele storage-account bereikt wordt, kunt u de overstap op een van de volgende methoden:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="d9fbb-280">Andere de werkbelasting die ervoor zorgt uw toepassing dat te benaderen of hoger zijn dan het doel van de schaalbaarheid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="d9fbb-281">Kunt u ook anders minder bandbreedte of capaciteit of minder transacties gebruiken ontwerpen?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="d9fbb-282">Als een toepassing moet groter zijn dan een van de schaalbaarheidsdoelen, moet u meerdere opslagaccounts en partitie uw toepassingsgegevens tussen die meerdere opslagaccounts.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="d9fbb-283">Als u dit patroon gebruikt, vervolgens moet u voor het ontwerpen van uw toepassing zodat u meer storage-accounts in de toekomst voor taakverdeling kunt toevoegen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="d9fbb-284">Op het moment van schrijven, kan elk Azure-abonnement maximaal 100 opslagaccounts hebben.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="d9fbb-285">Storage-accounts hebben ook geen kosten dan gebruik van uw in termen van de gegevens die zijn opgeslagen, transacties die zijn aangebracht of gegevens die zijn overgebracht.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="d9fbb-286">Als uw toepassing de doelen van bandbreedte raakt, kunt u overwegen het comprimeren van gegevens in de client en het verminderen van de bandbreedte die de gegevens verzenden naar de storage-service is vereist.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="d9fbb-287">Houd er rekening mee dat terwijl dit kunt u bandbreedte besparen en verbetering van netwerkprestaties, het kan ook sommige negatieve gevolgen hebben.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="d9fbb-288">De prestatie-invloed van deze vanwege de vereisten voor extra verwerking voor het comprimeren en decomprimeren van gegevens in de client, moet u evalueren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="d9fbb-289">Bovendien kan opslaan van gecomprimeerde gegevens het moeilijker problemen kunt oplossen, omdat deze mogelijk moeilijker om opgeslagen gegevens met standaardprogramma's weer te geven.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="d9fbb-290">Als uw toepassing de schaalbaarheidsdoelen raakt, Verzeker u ervan dat u van exponentieel uitstel voor nieuwe pogingen gebruikmaakt (Zie [pogingen](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="d9fbb-291">Is het beter om ervoor te zorgen nooit benadering van de schaalbaarheidsdoelen (met behulp van een van de bovenstaande methoden), maar hierdoor zorgt u dat uw toepassing won't NET blijft proberen snel, waardoor de beperking slechter.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="d9fbb-292">Nuttige informatie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-292">Useful Resources</span></span>
<span data-ttu-id="d9fbb-293">De volgende koppelingen bieden aanvullende details voor schaalbaarheidsdoelen:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="d9fbb-294">Zie [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) voor meer informatie over schaalbaarheidsdoelen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="d9fbb-295">Zie [Azure Storage-replicatie](storage-redundancy.md) en de blogpublicatie [opslagopties van Azure voor redundantie en geografisch redundante opslag met leestoegang](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) voor meer informatie over opties voor opslag redundantie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="d9fbb-296">Zie voor actuele informatie over prijzen voor Azure-services [Azure-prijzen](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="d9fbb-297"><a name="subheading47"></a>De naamconventie partitie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="d9fbb-298">Azure-opslag maakt gebruik van een bereik gebaseerde partitieschema schaal en load toepassen van het systeem.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="d9fbb-299">De partitiesleutel wordt gebruikt voor de partitie gegevens in de bereiken en deze bereiken zijn Netwerktaakverdeling in het systeem.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="d9fbb-300">Dit betekent dat naamconventies zoals lexicale ordenen (bijvoorbeeld msftpayroll, msftperformance, msftemployees, enzovoort) of met behulp van tijdstempels (log20160101, log20160102, log20160102, enzovoort) wordt zichzelf goed lenen voor de partities wordt mogelijk CO-locatie op de server met dezelfde partitie, tot aan een load balancing bewerking splitst deze in kleinere bereiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="d9fbb-301">Alle blobs in een container kunnen bijvoorbeeld worden geleverd door één server, totdat de belasting van deze blobs vereist meer herverdeling van de partitie bereiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="d9fbb-302">Op dezelfde manier een groep licht geladen accounts met hun namen lexicale volgorde kan worden geleverd door een enkele server totdat de belasting op één of al deze accounts moet u ze om te worden verdeeld over meerdere partities servers.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="d9fbb-303">Elke load balancer bewerking mogelijk van invloed op de latentie van storage aanroepen tijdens de bewerking.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="d9fbb-304">Mogelijkheid voor het afhandelen van een plotselinge toename van het verkeer naar een partitie van het systeem wordt beperkt door de schaalbaarheid van een server met één partitie totdat de bewerking voor taakverdeling in gang en de partitiesleutelbereik rebalances.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="d9fbb-305">U kunt volgen enkele aanbevolen procedures voor het Verlaag de frequentie van dergelijke bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="d9fbb-306">Bekijk de naamgevingsconventie die u voor accounts, containers, blobs, tabellen en wachtrijen, nauw gebruikt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="d9fbb-307">U kunt de accountnamen Mining met een 3-cijferige hash met een hash-functie die het beste past bij uw behoeften.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="d9fbb-308">Als u uw gegevens dankzij tijdstempels of numerieke id's organiseren, hebt u ervoor dat u niet gebruikmaken van een verkeerspatronen alleen toevoegen (of alleen-toevoegen).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="d9fbb-309">Deze patronen zijn niet geschikt voor een bereik-gebaseerd systeem partitioneren en kan leiden tot alle verkeer van één partitie en effectief beperken van het systeem van taakverdeling.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="d9fbb-310">Bijvoorbeeld als u de dagelijkse bewerkingen die gebruikmaken van een blob-object met een tijdstempel zoals JJJJMMDD hebt, is klikt u vervolgens het verkeer voor de dagelijkse bewerking gericht op een enkel object die worden geleverd door een server met één partitie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="d9fbb-311">Bekijk of de per limieten voor blob per partitie limieten aan uw behoeften voldoet en u kunt deze bewerking in meerdere blobs op te splitsen indien nodig.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="d9fbb-312">Op dezelfde manier als u een reeksgegevens in de tabellen opslaat, al het verkeer kan worden omgeleid naar het laatste deel van de belangrijkste naamruimte.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="d9fbb-313">Als u tijdstempels of numerieke id's moet gebruiken, het voorvoegsel van de id met een 3-cijferige hash of in het geval van tijdstempels het seconden deel van de tijd zoals ssyyyymmdd voorvoegsel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="d9fbb-314">Als het weergeven en opvragen bewerkingen worden regelmatig uitgevoerd, kiest u een hash-functie die wordt beperkt het aantal query's.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="d9fbb-315">In andere gevallen mogelijk een willekeurige voorvoegsel voldoende.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="d9fbb-316">Voor meer informatie over het partitieschema gebruikt in Azure Storage Lees het artikel SOSP [hier](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="d9fbb-317">Netwerken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-317">Networking</span></span>
<span data-ttu-id="d9fbb-318">Terwijl de API materie aanroept, hebben de beperkingen van het fysieke netwerk van de toepassing vaak een aanzienlijke invloed op de prestaties.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="d9fbb-319">Het volgende worden een aantal beperkingen die gebruikers kunnen ondervinden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="d9fbb-320">Mogelijkheid via het netwerk van de client</span><span class="sxs-lookup"><span data-stu-id="d9fbb-320">Client Network Capability</span></span>
##### <span data-ttu-id="d9fbb-321"><a name="subheading2"></a>Doorvoer</span><span class="sxs-lookup"><span data-stu-id="d9fbb-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="d9fbb-322">Voor bandbreedte is het probleem vaak de mogelijkheden van de client.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="d9fbb-323">Bijvoorbeeld, terwijl een enkele opslagaccount 10 Gbps of meer van de inkomende gegevens kan verwerken (Zie [schaalbaarheidsdoelen van bandbreedte](#sub1bandwidth)), de netwerksnelheid in een exemplaar van 'Kleine' Azure Worker-rol is alleen geschikt voor ongeveer 100 Mbps.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="d9fbb-324">Grotere Azure-exemplaren hebben NIC's met grotere capaciteit, dus u overwegen moet een grotere exemplaar of meer van de virtuele machine als u een hogere netwerk limieten vanaf één computer nodig.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="d9fbb-325">Als u een service Storage vanuit een on-premises-toepassing opent, wordt dezelfde regel van toepassing is: inzicht in de netwerkmogelijkheden van het clientapparaat en de netwerkverbinding met de Azure-opslaglocatie en u ze als nodig is of ontwerpen van uw toepassing uit te voeren binnen hun mogelijkheden verbeteren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="d9fbb-326"><a name="subheading3"></a>Kwaliteit van de verbinding</span><span class="sxs-lookup"><span data-stu-id="d9fbb-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="d9fbb-327">Net als bij alle netwerkgebruik Bedenk dat netwerkomstandigheden, wat leidt tot fouten en pakketverlies effectieve doorvoer vertragen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="d9fbb-328">Met behulp van WireShark of NetMon kan helpen bij het oplossen van dit probleem.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="d9fbb-329">Nuttige informatie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-329">Useful Resources</span></span>
<span data-ttu-id="d9fbb-330">Zie voor meer informatie over grootten van virtuele machines en toegewezen bandbreedte [Windows VM-grootten](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) of [Linux VM-grootten](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="d9fbb-331"><a name="subheading4"></a>Locatie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="d9fbb-332">In een gedistribueerde omgeving biedt plaatsen van de client in de buurt bevindt de server in de beste prestaties.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="d9fbb-333">Voor toegang tot Azure Storage met de laagste latentie, is de aanbevolen locatie voor de client binnen dezelfde Azure-regio.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="d9fbb-334">Als u een Azure-website die gebruikmaakt van Azure Storage hebt, moet u bijvoorbeeld beide in één regio (bijvoorbeeld VS-West of Zuidoost-Azië).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="d9fbb-335">Dit vermindert de latentie en de kosten, op het moment van schrijven, bandbreedtegebruik binnen één regio is gratis.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="d9fbb-336">Als uw toepassingen niet in Azure (zoals apps voor mobiele apparaten of op de lokale enterprise-services), klikt u vervolgens opnieuw gehost worden client plaatsen van het storage-account in een regio in de buurt bevindt de apparaten die toegang hebben tot, in het algemeen de latentie te verminderen wordt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="d9fbb-337">Als uw clients worden grote schaal gedistribueerd (voor bijvoorbeeld enkele in Noord-Amerika, en sommige in Europa), dan moet u overwegen meerdere opslagaccounts: een zich bevinden in een regio Noord-Amerika en een in een Europese regio.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="d9fbb-338">Dit helpt de latentie voor gebruikers in beide regio's te verminderen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="d9fbb-339">Deze aanpak is meestal eenvoudiger te implementeren als de gegevens door de toepassing opgeslagen is specifiek voor afzonderlijke gebruikers en vereist niet dat voor het repliceren van gegevens tussen opslagaccounts.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="d9fbb-340">Voor een brede distributie van inhoud, verdient het aanbeveling een CDN: Zie de volgende sectie voor meer informatie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="d9fbb-341"><a name="subheading5"></a>Distributie van inhoud</span><span class="sxs-lookup"><span data-stu-id="d9fbb-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="d9fbb-342">Soms moet een toepassing voor dezelfde inhoud aan meerdere gebruikers (bijvoorbeeld een product demovideo gebruikt in de startpagina van een website), zich in dezelfde of verschillende regio's.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="d9fbb-343">In dit scenario moet u een Content Delivery Network (CDN) zoals Azure CDN gebruiken en de CDN Azure-opslag wilt gebruiken als de oorsprong van de gegevens.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="d9fbb-344">In tegenstelling tot een Azure-opslagaccount die zich in één regio en die inhoud niet afleveren bij een lage latentie naar andere regio's, gebruikt Azure CDN servers in meerdere datacenters over de hele wereld.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="d9fbb-345">Bovendien kan een CDN doorgaans veel hoger uitgaande limieten dan een enkele opslagaccount ondersteunen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="d9fbb-346">Zie voor meer informatie over Azure CDN [Azure CDN](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="d9fbb-347"><a name="subheading6"></a>Met behulp van SAS- en CORS</span><span class="sxs-lookup"><span data-stu-id="d9fbb-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="d9fbb-348">Als u toestaan, zoals JavaScript-code in de webbrowser van een gebruiker of een mobiele telefoon-app voor toegang tot gegevens in Azure Storage wilt, een aanpak is voor het gebruik van een toepassing in Webrol als proxy: apparaat van de gebruiker wordt geverifieerd met de Webrol, op zijn beurt is geverifieerd met de storage-service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="d9fbb-349">Op deze manier kunt u voorkomen dat blootstellen van uw toegangscodes voor opslag op onbeveiligde apparaten.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="d9fbb-350">Dit wordt een groot overhead echter geplaatst op de Webrol omdat alle gegevens die worden overgedragen tussen apparaat van de gebruiker en de storage-service aan de Webrol doorgeven moet.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="d9fbb-351">U kunt het gebruik van een Webrol als proxy voor de storage-service met behulp van de Shared Access Signatures (SAS), soms in combinatie met koppen Cross-Origin-Resource delen (CORS) voorkomen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="d9fbb-352">Met SAS, kunt u uw gebruikersapparaat aanvragen rechtstreeks naar een opslagservice maken met behulp van een token met beperkte toegang toestaan.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="d9fbb-353">Bijvoorbeeld, als een gebruiker wil een foto uploadt naar uw toepassing, kunt de Webrol genereren en verzenden naar apparaat van de gebruiker een SAS-token dat toegang biedt tot het schrijven naar een specifieke blob of een container voor de komende 30 minuten (waarna het SAS-token vervalt).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="d9fbb-354">Een browser wordt normaal gesproken niet JavaScript toestaan op een pagina die wordt gehost door een website op één domein bepaalde bewerkingen, zoals een 'PUT' naar een ander domein uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="d9fbb-355">Bijvoorbeeld, als u een Webrol op 'contosomarketing.cloudapp.net' host, en wilt gebruiken van client-side JavaScript een blob uploaden naar uw opslagaccount op 'contosoproducts.blob.core.windows.net,' de browser van 'dezelfde oorsprong beleid' deze bewerking wordt verbieden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="d9fbb-356">CORS is een browser-functie waarmee het doeldomein (in dit geval het storage-account) om te communiceren met de browser dat aanvragen die afkomstig zijn in het brondomein (in dit geval de Webrol) wordt vertrouwd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="d9fbb-357">Beide technologieën kunt u onnodige laden (en knelpunten) op uw webtoepassing voorkomen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="d9fbb-358">Nuttige informatie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-358">Useful Resources</span></span>
<span data-ttu-id="d9fbb-359">Zie voor meer informatie over SAS [handtekeningen voor gedeelde toegang, deel 1: inzicht in het SAS-Model](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="d9fbb-360">Zie voor meer informatie over CORS [Cross-Origin-Resource delen (CORS) ondersteuning voor de Azure Storage-Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="d9fbb-361">Caching</span><span class="sxs-lookup"><span data-stu-id="d9fbb-361">Caching</span></span>
#### <span data-ttu-id="d9fbb-362"><a name="subheading7"></a>Ophalen van gegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="d9fbb-363">In het algemeen is het beter dan tweemaal aan eenmaal ophalen van gegevens van een service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="d9fbb-364">Bekijk het voorbeeld van een MVC-webtoepassing uitgevoerd in een Webrol die heeft al een blob 50MB opgehaald uit de storage-service om te fungeren als de inhoud naar een gebruiker.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="d9fbb-365">De toepassing kan vervolgens dezelfde blob ophalen telkens wanneer een gebruiker vraagt of het cache plaatsen kan lokaal naar schijf en de versie van de cache voor daaropvolgende gebruikersaanvragen hergebruiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="d9fbb-366">Bovendien telkens wanneer een gebruiker vraagt de gegevens, de toepassing kan probleem verkrijgen met een voorwaardelijke kop voor wijzigingstijd voorkomen de hele blob dat zou als deze niet is gewijzigd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="d9fbb-367">U kunt dit patroon toepassen op het werken met tabelentiteiten.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="d9fbb-368">In sommige gevallen kunt u beslissen dat uw toepassing wordt ervan uitgegaan dat de blob geldig blijft gedurende een korte periode na het en dat gedurende deze periode de toepassing niet hoeft te controleren of de blob is gewijzigd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="d9fbb-369">Configuratie, opzoeken en andere gegevens die altijd door de toepassing gebruikt worden zijn goede kandidaten voor opslaan in cache.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="d9fbb-370">Zie voor een voorbeeld van hoe u een blob-eigenschappen voor het detecteren van de datum van laatste wijziging met .NET [Set eigenschappen ophalen en metagegevens en](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="d9fbb-371">Zie voor meer informatie over voorwaardelijke downloads [voorwaardelijk vernieuwen van een lokale kopie van een Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="d9fbb-372"><a name="subheading8"></a>Uploaden van gegevens in Batches</span><span class="sxs-lookup"><span data-stu-id="d9fbb-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="d9fbb-373">In bepaalde situaties toepassing, kunt u statistische gegevens lokaal en periodiek uploaden in een batch in plaats van elk gegevensitem direct te uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="d9fbb-374">Bijvoorbeeld, een webtoepassing ervoor kiezen om een logbestand van activiteiten: de toepassing kan details van elke activiteit uploadt als dit als een Tabelentiteit gebeurt (waarvoor veel opslagbewerkingen) of het bestand kan activiteitendetails in een lokale logboekbestand opslaan en alle details van computeractiviteit periodiek als een bestand met scheidingstekens naar een blob te uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="d9fbb-375">Als elke logboekvermelding 1KB groot is, kunt u duizenden in één 'Blob plaatsen' transactie (u kunt een blob van maximaal 64MB groot in één transactie uploaden) uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="d9fbb-376">Natuurlijk als de lokale computer voordat het uploaden vastloopt, wordt mogelijk verbroken sommige logboekgegevens: ontwikkelaar van de toepassing moet de mogelijkheid van clientapparaat ontwerpt of fouten uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="d9fbb-377">Als de activiteitsgegevens moet worden gedownload voor timespans (niet slechts één activiteit), worden de blobs voorkeur boven tabellen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="d9fbb-378">.NET-configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-378">.NET Configuration</span></span>
<span data-ttu-id="d9fbb-379">Deze sectie vindt u enkele snelle configuratie-instellingen die u gebruiken kunt voor het maken van belangrijke prestatieverbeteringen als u gebruikmaakt van .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="d9fbb-380">Als u andere talen, controleert u of vergelijkbare concepten toepassing in uw gekozen taal.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="d9fbb-381"><a name="subheading9"></a>Standaard verbindingslimiet verhogen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="d9fbb-382">De volgende code verhoogt in .NET de standaard verbindingslimiet bereikt (dit is doorgaans 2 in de clientomgeving van een of 10 in een serveromgeving) en 100.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="d9fbb-383">Normaal gesproken moet u de waarde ingesteld op ongeveer het aantal threads die worden gebruikt door de toepassing.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="d9fbb-384">U moet de verbindingslimiet voor het openen van alle verbindingen instellen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="d9fbb-385">Zie de documentatie voor die taal te bepalen hoe de verbindingslimiet instellen voor andere programmeertalen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="d9fbb-386">Zie voor meer informatie het blogbericht [webservices: gelijktijdige verbindingen](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="d9fbb-387"><a name="subheading10"></a>ThreadPool Min Threads te verhogen als synchrone code met asynchrone taken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="d9fbb-388">Deze code wordt de thread pool min-threads te verhogen:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="d9fbb-389">Zie voor meer informatie [ThreadPool.SetMinThreads methode](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="d9fbb-390"><a name="subheading11"></a>Profiteren van de .NET 4.5-garbagecollection</span><span class="sxs-lookup"><span data-stu-id="d9fbb-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="d9fbb-391">.NET 4.5 of hoger voor de clienttoepassing gebruiken om te profiteren van betere prestaties in server garbagecollection.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="d9fbb-392">Zie voor meer informatie het artikel [een overzicht van prestatieverbeteringen in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="d9fbb-393"><a name="subheading12"></a>Ongebonden parallelle uitvoering</span><span class="sxs-lookup"><span data-stu-id="d9fbb-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="d9fbb-394">Parallelle uitvoering kan zijn ideaal voor prestaties, Wees voorzichtig bij gebruik van ongebonden parallelle uitvoering (geen limiet voor het aantal threads en/of parallelle aanvragen) om te uploaden of downloaden van gegevens, met meerdere werknemers voor toegang tot meerdere partities (containers, wachtrijen of Tabelpartities) in hetzelfde opslagaccount of toegang krijgen tot meerdere items in dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="d9fbb-395">Als de parallelle uitvoering unbounded, uw toepassing kan groter zijn dan het clientapparaat mogelijkheden of schaalbaarheid van het opslagaccount is bedoeld voor wat resulteert in langere latentietijden en beperking.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="d9fbb-396"><a name="subheading13"></a>Opslagclientbibliotheken en hulpprogramma 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="d9fbb-397">Gebruik altijd de meest recente Microsoft opgegeven clientbibliotheken en hulpprogramma's.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="d9fbb-398">Op het moment van schrijven zijn beschikbaar voor .NET, Windows Phone, Windows Runtime, Java en C++ clientbibliotheken, evenals de preview-bibliotheken voor andere talen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="d9fbb-399">Microsoft heeft bovendien uitgebracht PowerShell-cmdlets en Azure CLI-opdrachten voor het werken met Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="d9fbb-400">Microsoft actief deze hulpprogramma's met het oog op prestaties ontwikkelt, up-to-date met de nieuwste Serviceversies blijft en zorgt ervoor dat ze beproefde prestaties praktijken van intern verwerkt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="d9fbb-401">Nieuwe pogingen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-401">Retries</span></span>
#### <span data-ttu-id="d9fbb-402"><a name="subheading14"></a>Beperking/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="d9fbb-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="d9fbb-403">In sommige gevallen kan de storage-service kan uw toepassing beperken of gewoon mogelijk geen dient voor de aanvraag als gevolg van een aantal tijdelijke voorwaarde en een bericht '503 Server bezet' of '500 time-out' retourneren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="d9fbb-404">Dit kan gebeuren als uw toepassing bijna de van schaalbaarheidsdoelen is bereikt, of als het systeem is herverdeling uw gepartitioneerde gegevens om toe te staan voor een hogere doorvoer.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="d9fbb-405">De clienttoepassing moet doorgaans probeer het opnieuw dat ervoor zorgt een fout opgetreden dat: probeert dezelfde aanvraag later kan worden voltooid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="d9fbb-406">Als de storage-service is uw toepassing beperking, omdat deze schaalbaarheidsdoelen overschrijdt, of zelfs als de service heeft geen voor de aanvraag om een andere reden, nog agressieve pogingen meestal wel de probleem verergert.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="d9fbb-407">Daarom moet u een exponentiële uit (de client-bibliotheken standaard dit gedrag).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="d9fbb-408">Uw toepassing kan bijvoorbeeld opnieuw proberen na twee seconden vervolgens 4 seconden vervolgens 10 seconden vervolgens 30 seconden en vervolgens gaven ze volledig.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="d9fbb-409">Dit gedrag resulteert in uw toepassing aanzienlijk verminderen van de belasting van de service in plaats van exacerbating problemen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="d9fbb-410">Houd er rekening mee dat connectiviteitsfouten kunnen opnieuw worden geprobeerd onmiddellijk, omdat ze niet het resultaat van de beperking van en naar verwachting wordt tijdelijke.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="d9fbb-411"><a name="subheading15"></a>Niet-herstelbare fouten</span><span class="sxs-lookup"><span data-stu-id="d9fbb-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="d9fbb-412">De clientbibliotheken zich bewust zijn van welke fouten opnieuw kunnen zijn en welke niet.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="d9fbb-413">Echter als u uw eigen code te vergelijken met de REST-API van de opslag schrijft, moet u er zijn enkele fouten die u niet proberen: bijvoorbeeld 400 (ongeldige aanvraag) antwoord geeft aan dat de clienttoepassing een aanvraag kan niet worden verwerkt omdat deze niet in een verwachte formulier verzonden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="d9fbb-414">Deze aanvraag opnieuw te verzenden leidt tot hetzelfde antwoord telkens, zodat er geen punt in het opnieuw proberen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="d9fbb-415">Als u uw eigen code te vergelijken met de REST-API van de opslag schrijft, worden op de hoogte van de betekenis van de foutcodes en de juiste wijze opnieuw proberen (of niet) voor elk van deze.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="d9fbb-416">Nuttige informatie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-416">Useful Resources</span></span>
<span data-ttu-id="d9fbb-417">Zie voor meer informatie over foutcodes opslag [Status en foutcodes](http://msdn.microsoft.com/library/azure/dd179382.aspx) op de website van Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="d9fbb-418">Blobs</span><span class="sxs-lookup"><span data-stu-id="d9fbb-418">Blobs</span></span>
<span data-ttu-id="d9fbb-419">Naast de bewezen [alle Services](#allservices) hierboven beschreven, de volgende procedures bewezen name van toepassing op de blob-service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="d9fbb-420">Van de BLOB-specifieke Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="d9fbb-421"><a name="subheading46"></a>Meerdere clients tegelijkertijd toegang krijgen tot een enkel object</span><span class="sxs-lookup"><span data-stu-id="d9fbb-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="d9fbb-422">Als u hebt een groot aantal clients tegelijkertijd toegang krijgen tot een enkel object moet u rekening moet houden per object en opslag schaalbaarheidsdoelen van het account.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="d9fbb-423">Het exacte aantal clients die toegang heeft tot een enkel object zal variëren afhankelijk van factoren zoals het aantal clients tegelijk, aanvragen van het object de grootte van het object, netwerk-voorwaarden enzovoort.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="d9fbb-424">Als het object kan worden gedistribueerd via de CDN bijvoorbeeld installatiekopieën of video's geleverd vanuit een website en moet u een CDN.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="d9fbb-425">Zie [hier](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-425">See [here](#subheading5).</span></span>

<span data-ttu-id="d9fbb-426">In andere scenario's zoals wetenschappelijke simulaties waar de gegevens vertrouwelijk zijn hebt u twee opties.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="d9fbb-427">De eerste is toegang tot uw werkbelasting spreiden zodanig dat het object wordt benaderd gedurende een periode van tegenover tegelijkertijd worden geopend.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="d9fbb-428">U kunt ook het object tijdelijk kopiëren naar meerdere accounts voor opslag waardoor de totale IOP's per object en tussen opslagaccounts te verhogen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="d9fbb-429">In de beperkte testen we gevonden dat ongeveer 25 virtuele machines tegelijkertijd een blob 100GB parallel (elke virtuele machine is het downloaden met 32 threads parallelizing) kunnen downloaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="d9fbb-430">Als u had 100 clients die toegang tot het object, eerst kopiëren naar een tweede storage-account en vervolgens de eerste 50 VM's toegang tot de eerste blob en het tweede 50 VM's toegang tot de tweede blob.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="d9fbb-431">Resultaten varieert afhankelijk van het gedrag van uw toepassingen zodat u dit tijdens het ontwerp moet testen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="d9fbb-432"><a name="subheading16"></a>Bandbreedte en bewerkingen per Blob</span><span class="sxs-lookup"><span data-stu-id="d9fbb-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="d9fbb-433">U kunt lezen of schrijven naar één blob op maximaal 60 MB per seconde (dit is ongeveer 480 Mbps die groter is dan de mogelijkheden van veel client-side netwerken (met inbegrip van de fysieke NIC op het clientapparaat).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="d9fbb-434">Bovendien ondersteunt één blob maximaal 500 aanvragen per seconde.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="d9fbb-435">Als u meerdere clients hebt die moeten worden gelezen van de dezelfde blob hebt en u kunt deze limiet overschrijden, moet u overwegen een CDN voor het distribueren van de blob.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="d9fbb-436">Zie voor meer informatie over de doorvoer van het doel voor blobs [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="d9fbb-437">Kopiëren en verplaatsen van BLOB 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="d9fbb-438"><a name="subheading17"></a>Blob kopiëren</span><span class="sxs-lookup"><span data-stu-id="d9fbb-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="d9fbb-439">De REST-API versie 2012-02-12-opslag is de mogelijkheid nuttig voor het kopiëren van BLOB's tussen accounts geïntroduceerd: een clienttoepassing kunt opgeven dat de storage-service naar een blob kopiëren uit een andere bron (mogelijk in een ander opslagaccount) en vervolgens laat u de service de kopie asynchroon uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="d9fbb-440">Dit kan aanzienlijk verminderen de bandbreedte nodig voor de toepassing wanneer u gegevens uit andere opslagaccounts migreert omdat u niet wilt downloaden en de gegevens te uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="d9fbb-441">Een overweging is echter dat bij het kopiëren tussen opslagaccounts, er geen tijd garantie is op wanneer het exemplaar wordt voltooid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="d9fbb-442">Als uw toepassing een kopie van de blob snel onder uw beheer te voltooien moet, is het wellicht beter kopiëren van de blob door te downloaden naar een virtuele machine en vervolgens uploaden naar de bestemming.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="d9fbb-443">Zorg ervoor dat het exemplaar wordt uitgevoerd door een virtuele machine uitgevoerd in dezelfde Azure-regio, anders netwerkomstandigheden mogelijk (en mogelijk wordt) invloed hebben op de prestaties van uw exemplaar voor volledige voorspelbaarheid in dit geval.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="d9fbb-444">Bovendien kunt u de voortgang van een asynchrone kopie programmatisch bewaken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="d9fbb-445">Houd er rekening mee dat snel exemplaren binnen hetzelfde opslagaccount zelf in het algemeen zijn voltooid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="d9fbb-446">Zie voor meer informatie [Blob kopiëren](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="d9fbb-447"><a name="subheading18"></a>AzCopy gebruiken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="d9fbb-448">Het Azure Storage-team heeft een opdrachtregelprogramma 'AzCopy' die is bedoeld om u te helpen bij bulksgewijs overbrengen veel blobs naar, van, en tussen opslagaccounts.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="d9fbb-449">Dit hulpprogramma is geoptimaliseerd voor dit scenario en maximale overdrachtssnelheid kunt bereiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="d9fbb-450">Het gebruik ervan wordt aangemoedigd voor bulksgewijs laden, gedownload en kopieer scenario's.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="d9fbb-451">Zie voor meer informatie over deze en downloaden, [gegevensoverdracht met het AzCopy-opdrachtregelprogramma](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="d9fbb-452"><a name="subheading19"></a>Azure Import/Export-Service</span><span class="sxs-lookup"><span data-stu-id="d9fbb-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="d9fbb-453">Voor zeer grote hoeveelheden gegevens (meer dan 1TB) biedt Azure Storage de Import/Export-service, die staat voor het uploaden en downloaden van blob-opslag van back-upfunctie harde schijven.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="d9fbb-454">U kunt uw gegevens op een harde schijf te plaatsen en naar Microsoft verzenden voor het uploaden of een lege harde schijf naar Microsoft verzonden om gegevens te downloaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="d9fbb-455">Zie voor meer informatie [gebruik van de Microsoft Azure Import/Export-Service gegevens overdragen naar Blob Storage](storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="d9fbb-456">Dit kan zijn veel efficiënter dan uploaden/downloaden van dit volume aan gegevens via het netwerk.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="d9fbb-457"><a name="subheading20"></a>Met behulp van metagegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="d9fbb-458">De blob-service ondersteunt head-aanvragen, met inbegrip van metagegevens over de blob.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="d9fbb-459">Bijvoorbeeld, als uw toepassing de EXIF-gegevens buiten een foto vereist, kan deze ophalen van de foto en pakt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="d9fbb-460">U bandbreedte besparen en de prestaties verbeteren door uw toepassing kan de EXIF gegevens opslaan in de blob-metagegevens wanneer de toepassing de foto geüpload: u kunt vervolgens ophalen EXIF-gegevens in de metagegevens met alleen een HEAD-aanvragen, opslaan van veel bandbreedte en de verwerkingstijd nodig om op te halen van de EXIF gegevens door elke keer dat de blob wordt gelezen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="d9fbb-461">Dit is nuttig in scenario's waarbij u alleen de metagegevens en niet de volledige inhoud van een blob hoeft.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="d9fbb-462">Houd er rekening mee dat alleen 8 KB van metagegevens per blob (de service accepteert geen een aanvraag voor het opslaan van meer dan die), kunnen worden opgeslagen zodat als de gegevens in die grootte niet past, kunt u mogelijk niet gebruik deze benadering.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="d9fbb-463">Zie voor een voorbeeld van het ophalen van metagegevens van een blob met .NET [Set eigenschappen ophalen en metagegevens en](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="d9fbb-464">Snel uploaden</span><span class="sxs-lookup"><span data-stu-id="d9fbb-464">Uploading Fast</span></span>
<span data-ttu-id="d9fbb-465">Als u wilt uploaden snel blobs, de eerste vraag te beantwoorden is: weet u het uploaden van een blob of veel?</span><span class="sxs-lookup"><span data-stu-id="d9fbb-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="d9fbb-466">Gebruik de onderstaande richtlijnen voor het bepalen van de juiste methode te gebruiken, afhankelijk van uw scenario.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="d9fbb-467"><a name="subheading21"></a>Snel uploaden een groot blob</span><span class="sxs-lookup"><span data-stu-id="d9fbb-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="d9fbb-468">Als u wilt uploaden snel één grote blob, uploaden uw clienttoepassing de blokken of pagina's parallel (met name Houd ook rekening met de schaalbaarheidsdoelen voor afzonderlijke blobs en het opslagaccount in zijn geheel).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="d9fbb-469">Houd er rekening mee dat het officiële Microsoft geleverde RTM opslag clientbibliotheken (.NET, Java) de mogelijkheid om dit te doen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="d9fbb-470">Voor elk van de bibliotheken, gebruikt u de hieronder opgegeven object of de eigenschap in te stellen van het niveau van gelijktijdigheid van taken:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="d9fbb-471">.NET: Set ParallelOperationThreadCount op een object BlobRequestOptions moet worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="d9fbb-472">Java/Android: BlobRequestOptions.setConcurrentRequestCount() gebruiken</span><span class="sxs-lookup"><span data-stu-id="d9fbb-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="d9fbb-473">Node.js: Gebruik parallelOperationThreadCount op de aanvraag-opties of op de blob-service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="d9fbb-474">C++: Gebruik de methode blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="d9fbb-475"><a name="subheading22"></a>Veel blobs uploaden snel</span><span class="sxs-lookup"><span data-stu-id="d9fbb-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="d9fbb-476">Als u wilt uploaden snel veel blobs, blobs parallel te uploaden.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="d9fbb-477">Dit is sneller dan één BLOB's tegelijk met parallel blok uploads worden geüpload omdat het uploaden van de verspreid over meerdere partities van de storage-service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="d9fbb-478">Één blob biedt alleen ondersteuning voor een doorvoer van 60 MB per seconde (ongeveer 480 Mbps).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="d9fbb-479">Op het moment van schrijven ondersteunt een account op basis van VS LRS maximaal 20 Gbps inkomend die veel meer dan de doorvoer wordt ondersteund door een afzonderlijke blob.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="d9fbb-480">[AzCopy](#subheading18) uploads parallel standaard uitvoert, en wordt aanbevolen voor dit scenario.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="d9fbb-481"><a name="subheading23"></a>Het juiste type blob kiezen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="d9fbb-482">Azure Storage ondersteunt twee typen blobs: *pagina* blobs en *blok* blobs.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="d9fbb-483">Uw keuze van het blobtype heeft invloed op de prestaties en schaalbaarheid van uw oplossing voor een bepaalde gebruiksscenario.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="d9fbb-484">Blok-blobs geschikt zijn wanneer u wilt uploaden van grote hoeveelheden gegevens efficiënt: bijvoorbeeld wellicht een clienttoepassing foto's of video uploaden naar blob storage.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="d9fbb-485">Pagina-blobs geschikt als de toepassing moet voor het uitvoeren van willekeurige schrijfbewerkingen op de gegevens zijn: bijvoorbeeld Azure VHD's worden opgeslagen als pagina-blobs.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="d9fbb-486">Zie voor meer informatie [blok-Blobs, toevoeg-Blobs en pagina-Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="d9fbb-487">Tabellen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-487">Tables</span></span>
<span data-ttu-id="d9fbb-488">Naast de bewezen [alle Services](#allservices) hierboven beschreven, de volgende procedures bewezen name van toepassing op de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="d9fbb-489"><a name="subheading24"></a>Tabel-specifieke Schaalbaarheidsdoelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="d9fbb-490">Naast de bandbreedtebeperkingen van een volledige storage-account hebben tabellen de volgende specifieke schaalbaarheidslimiet.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="d9fbb-491">Houd er rekening mee dat het systeem taakverdeling van als het verkeer toeneemt, maar als het verkeer plotselinge bursts heeft, kunt u mogelijk niet onmiddellijk ophalen van dit volume van doorvoer.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="d9fbb-492">Als het patroon bursts heeft, moet u verwachten Zie bandbreedtebeperking en/of time-outs tijdens de burst omdat de opslaggroep service automatisch load saldo's uit de tabel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="d9fbb-493">In het algemeen langzaam afhandelen heeft betere resultaten als dit de systeemtijd waarop taakverdeling wordt toegepast op de juiste wijze biedt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="d9fbb-494">Entiteiten per seconde (Account)</span><span class="sxs-lookup"><span data-stu-id="d9fbb-494">Entities per Second (Account)</span></span>
<span data-ttu-id="d9fbb-495">De schaalbaarheidslimiet voor toegang tot tabellen voor is maximaal 20.000 entiteiten (1KB elke) per seconde voor een account.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="d9fbb-496">In het algemeen elke entiteit die wordt ingevoegd, bijgewerkt, verwijderd of gescand tellingen voor dit doel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="d9fbb-497">Dus een batchinvoeging met 100 entiteiten geteld als 100 entiteiten.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="d9fbb-498">Een query waarmee 1000 entiteiten wordt gescand en retourneert 5 geteld als 1000 entiteiten.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="d9fbb-499">Entiteiten per seconde (partitie)</span><span class="sxs-lookup"><span data-stu-id="d9fbb-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="d9fbb-500">Binnen een enkele partitie is het doel schaalbaarheid voor toegang tot tabellen 2.000 entiteiten (1KB elke) per seconde, met behulp van de dezelfde tellen zoals beschreven in de vorige sectie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="d9fbb-501">Configuratie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-501">Configuration</span></span>
<span data-ttu-id="d9fbb-502">Deze sectie vindt u enkele snelle configuratie-instellingen die u gebruiken kunt om belangrijke prestatieverbeteringen in de tabelservice:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="d9fbb-503"><a name="subheading25"></a>Gebruik JSON</span><span class="sxs-lookup"><span data-stu-id="d9fbb-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="d9fbb-504">Vanaf versie van de service storage 2013-08-15, ondersteunt de tabelservice het gebruik van JSON in plaats van de AtomPub op basis van een XML-indeling voor het overbrengen van gegevens in een tabel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="d9fbb-505">Dit bespaart nettolading grootten met zoveel 75% en kan de prestaties van uw toepassing aanzienlijk verbeterd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="d9fbb-506">Zie voor meer informatie het bericht [Microsoft Azure-tabellen: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) en [indeling van nettolading voor tabel servicebewerkingen](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="d9fbb-507"><a name="subheading26"></a>Nagle uitschakelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="d9fbb-508">Nagle van algoritme is algemeen geïmplementeerd via TCP/IP-netwerken als ter verbetering van netwerkprestaties.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="d9fbb-509">Het is echter niet optimaal in alle gevallen (zoals interactieve omgevingen).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="d9fbb-510">Voor Azure Storage van Nagle-algoritme heeft een nadelige invloed op de prestaties van aanvragen voor de tabel en queue-services en moet u dit indien mogelijk uitschakelen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="d9fbb-511">Zie voor meer informatie onze blogbericht [van Nagle-algoritme is niet beschrijvende kleine aanvragen](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), waarin wordt uitgelegd waarom Nagle van algoritme slecht communiceert met table en queue aanvragen en laat zien hoe deze in uw clienttoepassing uitschakelen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="d9fbb-512">Schema</span><span class="sxs-lookup"><span data-stu-id="d9fbb-512">Schema</span></span>
<span data-ttu-id="d9fbb-513">Hoe u vertegenwoordigen en uw gegevens een query is de grootste één factor die invloed heeft op de prestaties van de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="d9fbb-514">Terwijl elke toepassing verschilt, is deze sectie geeft een overzicht enkele algemene beproefde procedures die betrekking hebben op:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="d9fbb-515">Tabelontwerp</span><span class="sxs-lookup"><span data-stu-id="d9fbb-515">Table design</span></span>
* <span data-ttu-id="d9fbb-516">Efficiënt query 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-516">Efficient queries</span></span>
* <span data-ttu-id="d9fbb-517">Efficiënte Gegevensupdates</span><span class="sxs-lookup"><span data-stu-id="d9fbb-517">Efficient data updates</span></span>  

#### <span data-ttu-id="d9fbb-518"><a name="subheading27"></a>Tabellen en partities</span><span class="sxs-lookup"><span data-stu-id="d9fbb-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="d9fbb-519">Tabellen worden onderverdeeld in partities.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-519">Tables are divided into partitions.</span></span> <span data-ttu-id="d9fbb-520">Elke entiteit die is opgeslagen in een partitie dezelfde partitiesleutel gedeeld en heeft een unieke rij-sleutel bij het identificeren ervan in die partitie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="d9fbb-521">Partities voordelen bieden, maar ook limieten voor schaalbaarheid veroorzaken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="d9fbb-522">Voordelen: U kunt entiteiten in dezelfde partitie in een enkel, atomic, batchtransactie met maximaal 100 afzonderlijke opslagbewerkingen (maximaal 4MB totale grootte) bijwerken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="d9fbb-523">Ervan uitgaande dat hetzelfde aantal entiteiten worden opgehaald, u kunt ook een query gegevens binnen één partitie efficiënter dan gegevens meerdere partities (Hoewel gelezen op voor verdere aanbevelingen voor het opvragen van tabelgegevens).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="d9fbb-524">Schaalbaarheidslimiet: toegang tot de entiteiten die zijn opgeslagen in één partitie kan niet worden taakverdeling omdat partities atomic batchtransacties ondersteunen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="d9fbb-525">Daarom is het doel van de schaalbaarheid van de partitie van een afzonderlijke tabel lager is dan voor de tabelservice als geheel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="d9fbb-526">Vanwege deze kenmerken van tabellen en partities, moet u overstapt op de volgende principes:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="d9fbb-527">Gegevens die uw clienttoepassing regelmatig bijgewerkt of een query uitgevoerd in dezelfde logische eenheid van werk moeten zich bevinden in dezelfde partitie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="d9fbb-528">Dit kan zijn omdat schrijfbewerkingen is aggregeren van uw toepassing, of omdat u wilt profiteren van atomaire batchbewerkingen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="d9fbb-529">Bovendien kan gegevens in één partitie worden efficiënter doorzocht in één query dan gegevens meerdere partities.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="d9fbb-530">Gegevens die uw clienttoepassing komt niet invoegen/bijwerken of query op in dezelfde logische eenheid van werk (één query of batch-update) moet zich bevinden op afzonderlijke partities.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="d9fbb-531">Een belangrijke opmerking is dat er geen limiet voor het aantal partitiesleutels in één tabel, dus met miljoenen partitiesleutels geen probleem is en heeft geen invloed op prestaties.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="d9fbb-532">Bijvoorbeeld, als uw toepassing een populaire website met gebruikersaanmelding, is met behulp van de gebruikers-Id als de partitiesleutel een goede keuze.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="d9fbb-533">Hot partities</span><span class="sxs-lookup"><span data-stu-id="d9fbb-533">Hot Partitions</span></span>
<span data-ttu-id="d9fbb-534">Een hot partitie is een waarin een onevenredige percentage van het verkeer naar een account is ontvangen en kan niet worden met gelijke taakverdeling omdat deze één partitie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="d9fbb-535">Hot partities gemaakt in het algemeen zijn twee manieren:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="d9fbb-536"><a name="subheading28"></a>Alleen toevoegen en voeg alleen patronen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="d9fbb-537">Het patroon 'Alleen toevoegen' is een waar alle (of bijna alle) van het verkeer naar een bepaalde PK verhoogt en verkleint u volgens de huidige tijd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="d9fbb-538">Een voorbeeld is als uw toepassing de huidige datum als een partitiesleutel voor logboekgegevens gebruikt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="d9fbb-539">Dit leidt ertoe dat alle van de invoegt gaan naar de laatste partitie in de tabel en het systeem kan saldo niet laden omdat alle van schrijfbewerkingen naar het einde van de tabel gaat.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="d9fbb-540">Als het volume van verkeer voor deze partitie is groter dan het doel partitie niveau schaalbaarheid en vervolgens het tot beperking leiden zal.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="d9fbb-541">Is het beter om ervoor te zorgen dat verkeer wordt verzonden naar meerdere partities bevat, waarmee taakverdeling de aanvragen in de tabel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="d9fbb-542"><a name="subheading29"></a>Intensief verkeer gegevens</span><span class="sxs-lookup"><span data-stu-id="d9fbb-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="d9fbb-543">Als uw partitieschema in een enkele partitie met alleen gegevens die veel meer dan andere partities die worden gebruikt resulteert, ziet u mogelijk ook beperking als dat partitie het doel van de schaalbaarheid van één partitie nadert.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="d9fbb-544">Is het beter om ervoor te zorgen dat uw partitieschema resulteert in geen enkele partitie de schaalbaarheidsdoelen nadert.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="d9fbb-545">Uitvoeren van query 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-545">Querying</span></span>
<span data-ttu-id="d9fbb-546">Deze sectie beschrijft bewezen voor query's in de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="d9fbb-547"><a name="subheading30"></a>Querybereik</span><span class="sxs-lookup"><span data-stu-id="d9fbb-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="d9fbb-548">Er zijn verschillende manieren om op te geven van het bereik van entiteiten aan query.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="d9fbb-549">Hier volgt een bespreking van elk worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="d9fbb-550">In het algemeen te voorkomen dat scans (query's groter is dan één entiteit), maar als u scannen moet, probeert de gegevens te ordenen zodat uw scans gegevens zonder scannen of het opvragen van grote hoeveelheden entiteiten hoeft u niet ophalen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="d9fbb-551">Punt-query 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-551">Point Queries</span></span>
<span data-ttu-id="d9fbb-552">Een punt query haalt precies één entiteit.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="d9fbb-553">Dit gebeurt door het opgeven van de partitiesleutel en de rijsleutel van de entiteit ophalen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="d9fbb-554">Deze query's zijn zeer efficiënte en u zoveel mogelijk deze moet gebruiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="d9fbb-555">Partitie-query 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-555">Partition Queries</span></span>
<span data-ttu-id="d9fbb-556">Een partitiequery is een query waarmee een set gegevens die een algemene partitiesleutel deelt opgehaald.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="d9fbb-557">De query is doorgaans een bereik van de sleutelwaarden rij of een bereik van waarden voor een bepaalde eigenschap van entiteit naast een partitiesleutel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="d9fbb-558">Deze zijn minder efficiënt dan punt query's en moeten spaarzaam worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="d9fbb-559">Tabel-query 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-559">Table Queries</span></span>
<span data-ttu-id="d9fbb-560">Een tabelquery is een query waarmee een verzameling entiteiten die een algemene partitiesleutel niet deelt worden opgehaald.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="d9fbb-561">Deze query's zijn niet efficiënt en u indien mogelijk moet voorkomen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="d9fbb-562"><a name="subheading31"></a>Query-dichtheid</span><span class="sxs-lookup"><span data-stu-id="d9fbb-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="d9fbb-563">Een andere belangrijke factor in de efficiëntie van de query is het aantal entiteiten die zijn geretourneerd in vergelijking met het aantal entiteiten gescand om te zoeken naar de resulterende set.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="d9fbb-564">Als uw toepassing wordt een tabelquery met een filter voor een eigenschapswaarde slechts 1% van de gegevens shares, de query wordt scannen 100 entiteiten voor elke één entiteit wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="d9fbb-565">De tabel schaalbaarheidsdoelen besproken eerder alle betrekking op het aantal entiteiten gescand en niet het aantal entiteiten dat is geretourneerd: een lage query dichtheid eenvoudig ertoe leiden dat de tabelservice om te beperken van uw toepassing omdat zoveel entiteiten voor het ophalen van de entiteit die u zoekt moet worden gecontroleerd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="d9fbb-566">Zie de sectie hieronder op [denormalization](#subheading34) voor meer informatie over hoe u dit probleem te voorkomen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="d9fbb-567">Beperken van de hoeveelheid gegevens die worden geretourneerd</span><span class="sxs-lookup"><span data-stu-id="d9fbb-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="d9fbb-568"><a name="subheading32"></a>Filteren</span><span class="sxs-lookup"><span data-stu-id="d9fbb-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="d9fbb-569">Wanneer u een query wordt retourneert entiteiten die u hoeft niet in de clienttoepassing weet, kunt u overwegen een filter op Reduceer de grootte van de resulterende set.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="d9fbb-570">Terwijl de entiteiten die niet zijn geretourneerd naar de client wordt nog steeds voor de limieten voor schaalbaarheid meetellen, verbeteren de toepassingsprestaties van uw vanwege de grootte van de nettolading verminderde netwerk en de verminderde aantal entiteiten dat is verwerkt door de clienttoepassing.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="d9fbb-571">Zie boven notitie op [Query dichtheid](#subheading31), echter – de schaalbaarheidsdoelen hebben betrekking op het aantal entiteiten gescand, zodat een query die veel entiteiten gefilterd mogelijk nog steeds in de beperking, zelfs als er enkele entiteiten worden geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="d9fbb-572"><a name="subheading33"></a>Projectie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="d9fbb-573">Als u de clienttoepassing een beperkt aantal eigenschappen van de entiteiten in de tabel moet, kunt u projectie beperkt de omvang van de geretourneerde gegevensset.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="d9fbb-574">Net als bij filteren, helpt dit minder netwerkbelasting en client verwerken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="d9fbb-575"><a name="subheading34"></a>Denormalization</span><span class="sxs-lookup"><span data-stu-id="d9fbb-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="d9fbb-576">In tegenstelling tot het werken met relationele databases, wordt de beproefde procedures voor het opvragen van tabelgegevens efficiënt leiden tot denormalizing van uw gegevens.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="d9fbb-577">Dat wil zeggen, het dupliceren van dezelfde gegevens in meerdere entiteiten (één voor elke sleutel die u kunt de gegevens zoeken) Beperk het aantal entiteiten waarmee een query moet worden gescand om te zoeken de gegevens van de client moeten in plaats uw toepassing moet hebben om te scannen van grote aantallen entiteiten vinden van de gegevens.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="d9fbb-578">Bijvoorbeeld, een webwinkel u kunt in een volgorde beide door de klant-ID vinden (Geef me van de klant orders) en de datum (Geef me orders op een datum).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="d9fbb-579">In de Table Storage, is het aanbevolen voor het opslaan van de entiteit (of een verwijzing naar het) tweemaal – één keer met de naam van de tabel PK en RK te vergemakkelijken zoeken door de klant-ID, eenmaal vinden door de datum mogelijk te maken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="d9fbb-580">Invoegen, bijwerken, verwijderen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-580">Insert/Update/Delete</span></span>
<span data-ttu-id="d9fbb-581">Deze sectie beschrijft bewezen voor het wijzigen van de entiteiten die zijn opgeslagen in de tabelservice.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="d9fbb-582"><a name="subheading35"></a>Batchverwerking</span><span class="sxs-lookup"><span data-stu-id="d9fbb-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="d9fbb-583">Batchtransacties bekend als entiteit groep transacties (ETG) in Azure Storage; alle bewerkingen binnen een ETG moeten zich op één partitie in één tabel.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="d9fbb-584">Waar mogelijk, ETGs voor invoegen, bijwerken en verwijderen in batches gebruiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="d9fbb-585">Dit vermindert het aantal retouren van uw clienttoepassing op de server, vermindert het aantal factureerbare transacties (een ETG telt als een enkele transactie voor facturering en mag maximaal 100 opslagbewerkingen) en maakt atomic updates (alle bewerkingen slagen of allemaal binnen een ETG mislukken).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="d9fbb-586">Omgevingen met hoge latentie, zoals mobiele apparaten profiteren aanzienlijk ETGs te gebruiken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="d9fbb-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="d9fbb-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="d9fbb-588">Gebruik tabel **Upsert** operations waar mogelijk.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="d9fbb-589">Er zijn twee soorten **Upsert**, die beide kunnen zijn efficiënter dan een traditionele **invoegen** en **Update** bewerkingen:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="d9fbb-590">**InsertOrMerge**: Gebruik deze optie als u wilt uploaden een subset van de eigenschappen van de entiteit, maar niet zeker weet of de entiteit bestaat al.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="d9fbb-591">Als de entiteit bestaat, deze aanroep bijgewerkt met de eigenschappen die zijn opgenomen in de **Upsert** bewerking, en blijven alle bestaande eigenschappen zoals ze zijn, als de entiteit niet bestaat, wordt de nieuwe entiteit ingevoegd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="d9fbb-592">Dit is vergelijkbaar met het gebruik van projectie in een query in dat u alleen hoeft voor het uploaden van de eigenschappen die u wilt wijzigen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="d9fbb-593">**InsertOrReplace**: Gebruik deze optie als u wilt uploaden van een geheel nieuwe entiteit, maar u niet zeker weet of deze al bestaat.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="d9fbb-594">U moet dit alleen gebruiken als u weet dat het recent geüploade entiteit volledig juist is, omdat de oude entiteit volledig overschrijft.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="d9fbb-595">Bijvoorbeeld, wilt u bijwerken van de entiteit die de huidige locatie van een gebruiker slaat ongeacht de toepassing al dan niet eerder locatiegegevens voor de gebruiker opgeslagen heeft. de nieuwe locatie entiteit is voltooid en u hoeft geen gegevens uit een eerdere entiteit.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="d9fbb-596"><a name="subheading37"></a>De gegevensreeks opslaan in een enkele entiteit</span><span class="sxs-lookup"><span data-stu-id="d9fbb-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="d9fbb-597">Een toepassing slaat soms, een reeks met gegevens die vaak nodig is om op te halen in één keer: bijvoorbeeld een toepassing kan CPU-gebruik gedurende een periode bijhouden om te kunnen tekenen van een rolling grafiek van de gegevens van de afgelopen 24 uur.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="d9fbb-598">Een aanpak is om een Tabelentiteit per uur, met elke entiteit die een specifiek uur en het CPU-gebruik op te slaan voor dat uur.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="d9fbb-599">De toepassing moet u deze gegevens getekend, voor het ophalen van de entiteiten die de gegevens van de 24 uur van de meest recente.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="d9fbb-600">U kunt ook het CPU-gebruik voor elk uur als een afzonderlijke eigenschap van een enkele entiteit kan opslaan van uw toepassing: voor het bijwerken van elk uur toepassingen kunnen gebruikmaken van één **InsertOrMerge Upsert** aanroep van de waarde voor de meest recente uur bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="d9fbb-601">Als u wilt de gegevens wordt getekend, de toepassing alleen hoeft op te halen één entiteit in plaats van 24, maken voor een zeer efficiënte query (Zie hierboven discussie op [bereik query](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="d9fbb-602"><a name="subheading38"></a>Opslaan van gestructureerde gegevens in BLOB 's</span><span class="sxs-lookup"><span data-stu-id="d9fbb-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="d9fbb-603">Soms gestructureerde gegevens werkt zoals moet worden gegaan in tabellen, maar bereiken van entiteiten worden altijd samen opgehaald en kan worden batch ingevoegd.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="d9fbb-604">Een goed voorbeeld hiervan is een logboekbestand.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-604">A good example of this is a log file.</span></span>  <span data-ttu-id="d9fbb-605">In dit geval kunt u enkele minuten aan logboeken batch, voegt u deze, en vervolgens u enkele minuten aan logboeken op een tijdstip ook altijd een ophaalt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="d9fbb-606">In dit geval voor prestaties verdient het aanbeveling blobs in plaats van tabellen, gebruikt, omdat u het aantal objecten geschreven/geretourneerd, evenals meestal het aantal aanvragen die moeten worden aangebracht aanzienlijk kan verminderen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="d9fbb-607">Wachtrijen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-607">Queues</span></span>
<span data-ttu-id="d9fbb-608">Naast de bewezen [alle Services](#allservices) hierboven beschreven, de volgende procedures bewezen name van toepassing op de queue-service.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="d9fbb-609"><a name="subheading39"></a>Limieten voor schaalbaarheid</span><span class="sxs-lookup"><span data-stu-id="d9fbb-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="d9fbb-610">Een enkele wachtrij kunt ongeveer 2.000-berichten verwerken (1KB elke) per seconde (elke AddMessage GetMessage en DeleteMessage aantal als hier een bericht).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="d9fbb-611">Als dit onvoldoende voor uw toepassing is, moet u meerdere wachtrijen gebruiken en de berichten verdeeld over deze.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="d9fbb-612">Huidige schaalbaarheidsdoelen op weergeven [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="d9fbb-613"><a name="subheading40"></a>Nagle uitschakelen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="d9fbb-614">Zie de sectie op de configuratie van de tabel die het algoritme Nagle besproken: het algoritme Nagle is doorgaans niet voor de prestaties van de wachtrij aanvragen en moet u dit uitschakelen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="d9fbb-615"><a name="subheading41"></a>Grootte van het bericht</span><span class="sxs-lookup"><span data-stu-id="d9fbb-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="d9fbb-616">Wachtrij afname prestaties en schaalbaarheid als bericht grootte toeneemt.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="d9fbb-617">U moet alleen de informatie die de ontvanger moet plaatsen in een bericht.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="d9fbb-618"><a name="subheading42"></a>Batch ophalen</span><span class="sxs-lookup"><span data-stu-id="d9fbb-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="d9fbb-619">U kunt maximaal 32 berichten ophalen uit een wachtrij in één bewerking.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="d9fbb-620">Verminder het aantal interactie van de clienttoepassing, dit vooral geschikt voor omgevingen zoals mobiele apparaten is, kan dit met een hoge latentie.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="d9fbb-621"><a name="subheading43"></a>Wachtrij Polling-Interval</span><span class="sxs-lookup"><span data-stu-id="d9fbb-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="d9fbb-622">De meeste toepassingen pollen berichten van een wachtrij, wat kan een van de grootste bronnen van transacties voor die toepassing.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="d9fbb-623">Selecteer uw polling-interval verstandig: polling te vaak kan ervoor zorgen dat uw toepassing om de schaalbaarheidsdoelen voor de wachtrij.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="d9fbb-624">200.000 transacties voor $0,01 (op het moment van schrijven) is één processor polling nadat elke seconde gedurende een maand zou u minder dan 15 cent dus kosten echter niet doorgaans een factor die invloed heeft op uw keuze van polling-interval.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="d9fbb-625">Zie voor kosteninformatie up-to-date [prijzen voor Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="d9fbb-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="d9fbb-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="d9fbb-627">U kunt **UpdateMessage** Verhoog de time-out voor onzichtbaarheid of bij te werken informatie over de status van een bericht.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="d9fbb-628">Dit is een krachtige, houd er rekening mee dat elke **UpdateMessage** bewerking telt naar het doel van de schaalbaarheid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="d9fbb-629">Dit kan echter zijn dat een benadering veel efficiënter dan wanneer een werkstroom die een taak van de ene wachtrij aan de volgende doorgegeven elke stap van de taak is voltooid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="d9fbb-630">Met behulp van de **UpdateMessage** bewerking kan de toepassing voor het opslaan van de taakstatus op het bericht en vervolgens doorgaan met werken in plaats van het bericht voor de volgende stap van de taak opnieuw queuing telkens wanneer een stap is voltooid.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="d9fbb-631">Zie voor meer informatie het artikel [hoe: de inhoud van een bericht in de wachtrij wijzigen](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="d9fbb-631">For more information, see the article [How to: Change the contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="d9fbb-632"><a name="subheading45"></a>Toepassingsarchitectuur</span><span class="sxs-lookup"><span data-stu-id="d9fbb-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="d9fbb-633">Wachtrijen moet u uw toepassingsarchitectuur schaalbare maken.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="d9fbb-634">Hieronder vindt u enkele manieren kunt u wachtrijen ervoor dat uw toepassing meer schaalbare gebruiken:</span><span class="sxs-lookup"><span data-stu-id="d9fbb-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="d9fbb-635">U kunt wachtrijen gebruiken voor het maken van achterstanden voor verwerking en vloeiend werkbelastingen in uw toepassing.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="d9fbb-636">Bijvoorbeeld, u kan in de wachtrij aanvragen van gebruikers om uit te voeren processor intensief werken zoals geüploade afbeeldingen vergroten of verkleinen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="d9fbb-637">U kunt wachtrijen gebruiken loskoppelen van de onderdelen van uw toepassing zodat u afzonderlijk kunt schalen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="d9fbb-638">Een webfront-end kan bijvoorbeeld enquêteresultaten van gebruikers plaatsen in een wachtrij voor latere analyse en opslag.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="d9fbb-639">U kunt meer exemplaren van worker-rol voor het verwerken van de wachtrijgegevens zo nodig kan toevoegen.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="d9fbb-640">Conclusie</span><span class="sxs-lookup"><span data-stu-id="d9fbb-640">Conclusion</span></span>
<span data-ttu-id="d9fbb-641">In dit artikel besproken enkele van de meest voorkomende bewezen procedures voor het optimaliseren van de prestaties bij gebruik van Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="d9fbb-642">Wij raden elke toepassingsontwikkelaar aan om toepassingen te beoordelen aan de hand van elk van de bovenstaande procedures en de aanbevelingen te overwegen voor het verkrijgen van uitstekende prestaties voor toepassingen die gebruikmaken van Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="d9fbb-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>