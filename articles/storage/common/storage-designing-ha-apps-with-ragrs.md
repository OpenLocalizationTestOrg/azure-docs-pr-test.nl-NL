---
title: Het ontwerpen van maximaal beschikbare toepassingen met behulp van Azure leestoegang geografisch redundante opslag (RA-GRS) | Microsoft Docs
description: Klik hier voor meer informatie over het RA-GRS van Azure storage gebruiken voor het bouwen van een maximaal beschikbare toepassing flexibel genoeg is voor het afhandelen van storingen.
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/29/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="efac7-103">Maximaal beschikbare toepassingen met behulp van RA-GRS ontwerpen</span><span class="sxs-lookup"><span data-stu-id="efac7-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="efac7-104">Een algemene functie van de cloud-gebaseerde infrastructuur is dat ze een maximaal beschikbare platform voor het hosten van toepassingen.</span><span class="sxs-lookup"><span data-stu-id="efac7-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="efac7-105">Ontwikkelaars van cloud-gebaseerde toepassingen Overweeg zorgvuldig hoe u dit platform voor het leveren van maximaal beschikbare toepassingen voor hun gebruikers.</span><span class="sxs-lookup"><span data-stu-id="efac7-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="efac7-106">Dit artikel is gericht specifiek op hoe ontwikkelaars de Azure Storage geografisch redundante opslag met leestoegang (RA-GRS) gebruiken kunnen om hun toepassingen meer beschikbaar.</span><span class="sxs-lookup"><span data-stu-id="efac7-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="efac7-107">Er zijn vier opties voor de redundantie – LRS (lokaal redundante opslag), ZRS (Zone-redundante opslag), (Geo-Redundant Storage) GRS en RA-GRS (leestoegang Geo-Redundant Storage).</span><span class="sxs-lookup"><span data-stu-id="efac7-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="efac7-108">We gaan bespreken GRS en RA-GRS in dit artikel.</span><span class="sxs-lookup"><span data-stu-id="efac7-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="efac7-109">Met GRS worden drie kopieën van uw gegevens worden opgeslagen in de primaire regio die u hebt geselecteerd bij het instellen van het opslagaccount.</span><span class="sxs-lookup"><span data-stu-id="efac7-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="efac7-110">Drie extra kopieën worden asynchroon worden bijgehouden in een secundaire regio die is opgegeven door Azure.</span><span class="sxs-lookup"><span data-stu-id="efac7-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="efac7-111">RA-GRS is hetzelfde als GRS, behalve dat u beschikken over leestoegang tot de secundaire kopie.</span><span class="sxs-lookup"><span data-stu-id="efac7-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="efac7-112">Zie voor meer informatie over de verschillende opties voor Azure Storage-redundantie [Azure Storage-replicatie](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="efac7-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="efac7-113">De replicatie-artikel ziet ook de koppelingen tussen de primaire en secundaire regio's.</span><span class="sxs-lookup"><span data-stu-id="efac7-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="efac7-114">Er zijn codefragmenten die zijn opgenomen in dit artikel en een koppeling naar een compleet codevoorbeeld aan het einde die u kunt downloaden en uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="efac7-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="efac7-115">Belangrijke functies van RA-GRS</span><span class="sxs-lookup"><span data-stu-id="efac7-115">Key features of RA-GRS</span></span>

<span data-ttu-id="efac7-116">Voordat we hoe RA-GRS opslag gebruiken, moet u iets over de eigenschappen en het gedrag uitleggen.</span><span class="sxs-lookup"><span data-stu-id="efac7-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="efac7-117">Azure-opslag onderhoudt een alleen-lezen kopie van de gegevens die u in de primaire regio in een secundaire regio opslaat; zoals eerder vermeld, bepaalt de storage-service de locatie van de secundaire regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="efac7-118">De alleen-lezen kopie is [uiteindelijk consistent](https://en.wikipedia.org/wiki/Eventual_consistency) met de gegevens in de primaire regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="efac7-119">Voor blobs, tabellen en wachtrijen, kunt u een query de secundaire regio voor een *tijd van laatste synchronisatie* waarde die aangeeft wanneer de laatste replicatie vanaf de primaire naar de secundaire regio is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="efac7-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="efac7-120">(Dit wordt niet ondersteund voor Azure File storage die geen RA-GRS redundantie op dit moment.)</span><span class="sxs-lookup"><span data-stu-id="efac7-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="efac7-121">U kunt de Storage-clientbibliotheek gebruiken om te communiceren met de gegevens in de primaire of secundaire regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="efac7-122">U kunt ook omleiden schijfleesaanvragen automatisch naar de secundaire regio als een aanvraag voor leestoegang tot de primaire regio een optreedt time-out.</span><span class="sxs-lookup"><span data-stu-id="efac7-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="efac7-123">Als er een grote probleem met betrekking tot de toegankelijkheid van de gegevens in de primaire regio, kan het team van Azure een geo-failover, waarna de DNS-vermeldingen die verwijst naar de primaire regio worden gewijzigd om te verwijzen naar de secundaire regio activeren.</span><span class="sxs-lookup"><span data-stu-id="efac7-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="efac7-124">Als een geo-failover optreedt, wordt Azure selecteert u een nieuwe secundaire locatie en de gegevens worden gerepliceerd naar die locatie en de secundaire DNS-vermeldingen wijs.</span><span class="sxs-lookup"><span data-stu-id="efac7-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="efac7-125">Secundair eindpunt is niet beschikbaar totdat het opslagaccount is voltooid met repliceren.</span><span class="sxs-lookup"><span data-stu-id="efac7-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="efac7-126">Zie voor meer informatie [wat te doen als een Azure Storage-storing optreedt,](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="efac7-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="efac7-127">Toepassing Ontwerpoverwegingen bij het gebruik van RA-GRS</span><span class="sxs-lookup"><span data-stu-id="efac7-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="efac7-128">Het belangrijkste doel van dit artikel is beschreven hoe u met het ontwerpen van een toepassing die wel blijft werken (maar in een beperkte capaciteit), zelfs in het geval van een noodgeval op het primaire Datacenter.</span><span class="sxs-lookup"><span data-stu-id="efac7-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="efac7-129">U doen dit door uw toepassing voor het afhandelen van tijdelijke of langdurige problemen door schakelen om te lezen van de secundaire regio, terwijl er een probleem is en overschakelen terug wanneer de primaire regio weer beschikbaar is.</span><span class="sxs-lookup"><span data-stu-id="efac7-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="efac7-130">Met behulp van uiteindelijk consistent gegevens</span><span class="sxs-lookup"><span data-stu-id="efac7-130">Using eventually consistent data</span></span>

<span data-ttu-id="efac7-131">Deze voorgestelde oplossing wordt ervan uitgegaan dat dit klopt wat verouderde gegevens aan de aanroepende toepassing kan worden geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="efac7-132">Omdat de secundaire gegevens uiteindelijk consistent is, is het mogelijk dat de gegevens zijn geschreven naar de primaire, maar de update naar de secundaire niet was voltooid wanneer de primaire regio is niet toegankelijk geworden repliceren.</span><span class="sxs-lookup"><span data-stu-id="efac7-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="efac7-133">Bijvoorbeeld, een update die is geslaagd door uw klant kan verzenden en vervolgens de primaire kan uitvallen voordat de update wordt doorgegeven naar de secundaire.</span><span class="sxs-lookup"><span data-stu-id="efac7-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="efac7-134">In dit geval als de klant wordt vervolgens gevraagd om de gegevens terug te lezen, ontvangt hij de verouderde gegevens in plaats van de bijgewerkte gegevens.</span><span class="sxs-lookup"><span data-stu-id="efac7-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="efac7-135">U moet beslissen als dit is acceptabel en zo ja, hoe u de klant wordt weergegeven.</span><span class="sxs-lookup"><span data-stu-id="efac7-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="efac7-136">Hier ziet u hoe u controleert de tijd van laatste synchronisatie op de secundaire gegevens verderop in dit artikel om te zien als de secundaire bijgewerkt is.</span><span class="sxs-lookup"><span data-stu-id="efac7-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="efac7-137">Afhandeling van de services afzonderlijk of Alles samenvoegen</span><span class="sxs-lookup"><span data-stu-id="efac7-137">Handling services separately or all together</span></span>

<span data-ttu-id="efac7-138">Tijdens het niet waarschijnlijk is het mogelijk voor een service niet beschikbaar terwijl de andere services nog steeds volledig functioneel zijn.</span><span class="sxs-lookup"><span data-stu-id="efac7-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="efac7-139">U kunt verwerkt de nieuwe pogingen en de modus alleen-lezen voor elke service afzonderlijk (blobs, wachtrijen, tabellen), of kunt u pogingen algemeen voor de opslagservices tegelijk verwerken.</span><span class="sxs-lookup"><span data-stu-id="efac7-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="efac7-140">Bijvoorbeeld, als u wachtrijen en blobs in uw toepassing gebruikt, besluiten u in afzonderlijke code voor het afhandelen van herstelbare fouten voor elk van deze te plaatsen.</span><span class="sxs-lookup"><span data-stu-id="efac7-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="efac7-141">Klik als u een nieuwe poging van de blob-service krijgt, maar de queue-service is nog steeds werken, worden slechts het deel van uw toepassing die verantwoordelijk is voor blobs beïnvloed.</span><span class="sxs-lookup"><span data-stu-id="efac7-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="efac7-142">Als u besluit om af te handelen alle opslag service pogingen algemeen en een aanroep van de blob-service een herstelbare fout retourneert, worden aanvragen voor zowel de blob-service en de queue-service worden beïnvloed.</span><span class="sxs-lookup"><span data-stu-id="efac7-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="efac7-143">Dit is uiteindelijk afhankelijk van de complexiteit van uw toepassing.</span><span class="sxs-lookup"><span data-stu-id="efac7-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="efac7-144">U kunt besluiten geen te verwerken van de fouten door service, maar in plaats daarvan omleiden van aanvragen voor alle storage-services naar de secundaire regio voor lezen en de toepassing uitvoert in de modus alleen-lezen wanneer u een probleem met een storage-service in de primaire regio detecteren.</span><span class="sxs-lookup"><span data-stu-id="efac7-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="efac7-145">Andere overwegingen</span><span class="sxs-lookup"><span data-stu-id="efac7-145">Other considerations</span></span>

<span data-ttu-id="efac7-146">Dit zijn de andere overwegingen die worden besproken in de rest van dit artikel.</span><span class="sxs-lookup"><span data-stu-id="efac7-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="efac7-147">Verwerking van nieuwe pogingen van leesaanvragen met behulp van het patroon Circuitonderbreker</span><span class="sxs-lookup"><span data-stu-id="efac7-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="efac7-148">Uiteindelijk consistent gegevens en de tijd van laatste synchronisatie</span><span class="sxs-lookup"><span data-stu-id="efac7-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="efac7-149">Testen</span><span class="sxs-lookup"><span data-stu-id="efac7-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="efac7-150">Uitvoeren van uw toepassing in de modus alleen-lezen</span><span class="sxs-lookup"><span data-stu-id="efac7-150">Running your application in read-only mode</span></span>

<span data-ttu-id="efac7-151">Voor het gebruik van RA-GRS-opslag, u moet beide mislukte leesaanvragen overweg en mislukte updateaanvragen (met update, wat betekent dat in dit geval voegt, updates en verwijderingen).</span><span class="sxs-lookup"><span data-stu-id="efac7-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="efac7-152">Als de primaire gegevens mislukt centreren, wordt alleen aanvragen kunnen worden omgeleid naar het secundaire Datacenter, maar verzoeken om te werken niet omdat de secundaire alleen-lezen is.</span><span class="sxs-lookup"><span data-stu-id="efac7-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="efac7-153">Daarom moet u een bepaalde manier voor het uitvoeren van uw toepassing in de modus alleen-lezen.</span><span class="sxs-lookup"><span data-stu-id="efac7-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="efac7-154">U kunt bijvoorbeeld een vlag die wordt gecontroleerd vóór het verzenden van de updateaanvragen die naar de storage-service instellen.</span><span class="sxs-lookup"><span data-stu-id="efac7-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="efac7-155">Wanneer een van de updateaanvragen via komt, kunt u dit overslaan en retourneren een juiste reactie aan de klant.</span><span class="sxs-lookup"><span data-stu-id="efac7-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="efac7-156">U kunt ook bepaalde functies uitschakelen helemaal totdat het probleem is opgelost en laat gebruikers weten dat deze functies zijn tijdelijk niet beschikbaar.</span><span class="sxs-lookup"><span data-stu-id="efac7-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="efac7-157">Als u besluit fouten worden verwerkt voor elke service afzonderlijk, moet u ook de mogelijkheid voor het uitvoeren van uw toepassing in de modus alleen-lezen door de service verwerkt.</span><span class="sxs-lookup"><span data-stu-id="efac7-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="efac7-158">Er kan alleen-lezen vlaggen voor elke service die kan worden ingeschakeld, uitgeschakeld en de juiste vlag in de juiste locaties in uw code te verwerken.</span><span class="sxs-lookup"><span data-stu-id="efac7-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="efac7-159">Kunnen de toepassing uitvoeren in de modus alleen-lezen heeft een ander voordeel van de zijde – dit biedt u de mogelijkheid om ervoor te zorgen beperkte functionaliteit tijdens een upgrade van de primaire toepassing.</span><span class="sxs-lookup"><span data-stu-id="efac7-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="efac7-160">U kunt uw toepassing uitvoeren in de modus alleen-lezen en wijs het secundaire Datacenter activeren zodat niemand toegang heeft tot de gegevens in de primaire regio terwijl u upgrades wilt aanbrengen.</span><span class="sxs-lookup"><span data-stu-id="efac7-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="efac7-161">Verwerken van wijzigingen in de modus alleen-lezen</span><span class="sxs-lookup"><span data-stu-id="efac7-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="efac7-162">Er zijn veel manieren voor het afhandelen van aanvragen voor updates in de modus alleen-lezen.</span><span class="sxs-lookup"><span data-stu-id="efac7-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="efac7-163">We dit uitvoerig won't verrekend, maar er zijn in het algemeen een aantal patronen waarmee u rekening houden.</span><span class="sxs-lookup"><span data-stu-id="efac7-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="efac7-164">U kunt reageren als de gebruiker en laat dat u bent momenteel accepteert geen updates.</span><span class="sxs-lookup"><span data-stu-id="efac7-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="efac7-165">Bijvoorbeeld, kan een contactpersoon beheersysteem kunnen klanten toegang krijgen tot contactgegevens, maar geen updates.</span><span class="sxs-lookup"><span data-stu-id="efac7-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="efac7-166">U kunt de updates in een andere regio in de wachtrij plaatsen.</span><span class="sxs-lookup"><span data-stu-id="efac7-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="efac7-167">In dit geval zou u schrijfaanvragen voor de update in behandeling aan een wachtrij in een andere regio en hebt een manier die aanvragen verwerkt nadat het primaire Datacenter weer online komt.</span><span class="sxs-lookup"><span data-stu-id="efac7-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="efac7-168">Laat de klant weten dat de update die is aangevraagd in de wachtrij staat voor het verwerken van later in dit scenario.</span><span class="sxs-lookup"><span data-stu-id="efac7-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="efac7-169">U kunt uw updates schrijven naar een opslagaccount in een andere regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="efac7-170">Als het primaire Datacenter weer online komt, kunt u een manier die updates samenvoegen met de primaire gegevens, afhankelijk van de structuur van de gegevens hebben.</span><span class="sxs-lookup"><span data-stu-id="efac7-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="efac7-171">Als u afzonderlijke bestanden met een datum/tijd-stempel in de naam maakt, kunt u deze bestanden kopiëren terug naar de primaire regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="efac7-172">Dit werkt voor sommige werkbelastingen zoals logboekregistratie en iOT-gegevens.</span><span class="sxs-lookup"><span data-stu-id="efac7-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="efac7-173">Verwerking van nieuwe pogingen</span><span class="sxs-lookup"><span data-stu-id="efac7-173">Handling retries</span></span>

<span data-ttu-id="efac7-174">Hoe wilt u weten welke fouten herstelbare?</span><span class="sxs-lookup"><span data-stu-id="efac7-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="efac7-175">Dit wordt bepaald door de storage-clientbibliotheek.</span><span class="sxs-lookup"><span data-stu-id="efac7-175">This is determined by the storage client library.</span></span> <span data-ttu-id="efac7-176">Een 404-fout (resource niet gevonden) is bijvoorbeeld niet-herstelbare omdat deze opnieuw proberen is niet waarschijnlijk leiden tot succes.</span><span class="sxs-lookup"><span data-stu-id="efac7-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="efac7-177">Een 500 fout is aan de andere kant herstelbare omdat het een serverfout is opgetreden, en dit eenvoudig een tijdelijk probleem komen kan.</span><span class="sxs-lookup"><span data-stu-id="efac7-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="efac7-178">Bekijk voor meer informatie de [open source code voor de klasse ExponentialRetry](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in de storage-clientbibliotheek voor .NET.</span><span class="sxs-lookup"><span data-stu-id="efac7-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="efac7-179">(Zoek naar de methode ShouldRetry).</span><span class="sxs-lookup"><span data-stu-id="efac7-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="efac7-180">Alleen aanvragen</span><span class="sxs-lookup"><span data-stu-id="efac7-180">Read requests</span></span>

<span data-ttu-id="efac7-181">Alleen aanvragen kunnen worden omgeleid naar de secundaire opslag als er een probleem met de primaire opslag.</span><span class="sxs-lookup"><span data-stu-id="efac7-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="efac7-182">Als opgemerkt in [uiteindelijk consistente gegevens met behulp van](#using-eventually-consistent-data), moet deze zijn aanvaardbaar is voor uw toepassing verouderde gegevens mogelijk lezen.</span><span class="sxs-lookup"><span data-stu-id="efac7-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="efac7-183">Als u de storage-clientbibliotheek voor toegang tot gegevens van de RA-GRS gebruikt, kunt u het gedrag van een leesaanvraag voor het opnieuw door een waarde voor de **LocationMode** eigenschap in op een van de volgende:</span><span class="sxs-lookup"><span data-stu-id="efac7-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="efac7-184">**PrimaryOnly** (de standaardinstelling)</span><span class="sxs-lookup"><span data-stu-id="efac7-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="efac7-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="efac7-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="efac7-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="efac7-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="efac7-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="efac7-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="efac7-188">Tijdens het instellen van de **LocationMode** naar **PrimaryThenSecondary**, als de eerste aanvraag voor leestoegang tot de primaire eindpunt mislukt met een herstelbare fout, de client automatisch een andere leesaanvraag naar het secundaire eindpunt maakt.</span><span class="sxs-lookup"><span data-stu-id="efac7-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="efac7-189">Als de fout een time-out van de server is, hebben de client moet worden gewacht voor de time-out is verlopen voordat het een herstelbare fout van de service ontvangt.</span><span class="sxs-lookup"><span data-stu-id="efac7-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="efac7-190">Er zijn in feite twee scenario's om u te overwegen wanneer u beslist reageren op een herstelbare fout:</span><span class="sxs-lookup"><span data-stu-id="efac7-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="efac7-191">Dit probleem is en een herstelbare fout niet de volgende aanvragen naar de primaire eindpunt wordt geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="efac7-192">Een voorbeeld van wanneer dit gebeurt mogelijk is wanneer er een tijdelijke fout.</span><span class="sxs-lookup"><span data-stu-id="efac7-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="efac7-193">In dit scenario wordt er is geen aanzienlijke prestaties voor het hebben van **LocationMode** ingesteld op **PrimaryThenSecondary** als dit alleen zelden gebeurt.</span><span class="sxs-lookup"><span data-stu-id="efac7-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="efac7-194">Dit is een probleem met ten minste één van de storage-services in de primaire regio en alle volgende aanvragen die service in de primaire regio waarschijnlijk herstelbare fouten retourneren, voor een bepaalde periode.</span><span class="sxs-lookup"><span data-stu-id="efac7-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="efac7-195">Een voorbeeld hiervan is als de primaire regio volledig niet toegankelijk.</span><span class="sxs-lookup"><span data-stu-id="efac7-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="efac7-196">In dit scenario is het een op de prestaties omdat uw leesaanvragen wordt Probeer eerst het primaire eindpunt, wacht u totdat de time-out is verlopen en schakel over naar het secundaire eindpunt.</span><span class="sxs-lookup"><span data-stu-id="efac7-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="efac7-197">Voor deze scenario's, moet u bepalen dat er een actieve probleem met het primaire eindpunt en verzendt alle aanvragen rechtstreeks naar het secundaire eindpunt gelezen door het instellen van de **LocationMode** eigenschap **SecondaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="efac7-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="efac7-198">Op dit moment moet u ook de toepassing uit te voeren in de modus alleen-lezen te wijzigen.</span><span class="sxs-lookup"><span data-stu-id="efac7-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="efac7-199">Deze aanpak wordt ook wel de [Circuitonderbreker patroon](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="efac7-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="efac7-200">Verzoeken om te werken</span><span class="sxs-lookup"><span data-stu-id="efac7-200">Update requests</span></span>

<span data-ttu-id="efac7-201">Het patroon Circuitonderbreker kan ook worden toegepast voor het bijwerken van aanvragen.</span><span class="sxs-lookup"><span data-stu-id="efac7-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="efac7-202">Echter worden niet updateaanvragen omgeleid naar secundaire opslag alleen-lezen is.</span><span class="sxs-lookup"><span data-stu-id="efac7-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="efac7-203">Voor deze aanvragen, laat u de **LocationMode** eigenschap ingesteld op **PrimaryOnly** (de standaardinstelling).</span><span class="sxs-lookup"><span data-stu-id="efac7-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="efac7-204">U kunt een waarde van toepassing op deze aanvragen – zoals 10 fouten in een rij- en als de drempelwaarde wordt voldaan, schakelt de toepassing in de modus alleen-lezen voor het afhandelen van deze fouten.</span><span class="sxs-lookup"><span data-stu-id="efac7-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="efac7-205">U kunt dezelfde methoden gebruiken voor het retourneren van modus als die hieronder wordt beschreven in de volgende sectie over het patroon Circuitonderbreker bijwerken.</span><span class="sxs-lookup"><span data-stu-id="efac7-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="efac7-206">Patroon voor Circuitonderbreker</span><span class="sxs-lookup"><span data-stu-id="efac7-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="efac7-207">Het patroon Circuitonderbreker gebruiken in uw toepassing kunt voorkomen dat deze opnieuw wordt geprobeerd een bewerking die is waarschijnlijk geen herhaaldelijk.</span><span class="sxs-lookup"><span data-stu-id="efac7-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="efac7-208">Kunt u de toepassing wordt uitgevoerd in plaats van exponentieel inneemt bij de bewerking is geprobeerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="efac7-209">Daarnaast wordt gedetecteerd wanneer het probleem is opgelost, op dat moment kan de toepassing probeer het opnieuw.</span><span class="sxs-lookup"><span data-stu-id="efac7-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="efac7-210">Het implementeren van het patroon Circuitonderbreker</span><span class="sxs-lookup"><span data-stu-id="efac7-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="efac7-211">Om aan te duiden dat er een actieve probleem met een primaire eindpunt is, kunt u controleren hoe vaak de client er een herstelbare fout optreedt.</span><span class="sxs-lookup"><span data-stu-id="efac7-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="efac7-212">Omdat elk geval niet hetzelfde is, hebt u besluit de drempel die u wilt gebruiken voor de beslissing overschakelen naar het secundaire eindpunt en de toepassing uitvoert in de modus alleen-lezen.</span><span class="sxs-lookup"><span data-stu-id="efac7-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="efac7-213">U kan bijvoorbeeld besluiten om uit te voeren van de switch als er 10 fouten in een rij met geen uitkomsten.</span><span class="sxs-lookup"><span data-stu-id="efac7-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="efac7-214">Een ander voorbeeld is om over te schakelen als 90% van de aanvragen in een periode van 2 minuten mislukken.</span><span class="sxs-lookup"><span data-stu-id="efac7-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="efac7-215">Voor het eerste scenario kunt u eenvoudig houden van een aantal van de fouten en als er een is voltooid voordat het maximum is bereikt de telling weer instellen op nul.</span><span class="sxs-lookup"><span data-stu-id="efac7-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="efac7-216">Voor het tweede scenario is een manier om dit te implementeren voor gebruik van het object MemoryCache (in .NET).</span><span class="sxs-lookup"><span data-stu-id="efac7-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="efac7-217">Voor elke aanvraag een CacheItem toevoegen aan de cache, de waarde instellen op geslaagd (1) of mislukt (0) en de verlooptijd ingesteld op 2 minuten vanaf nu (of wat uw tijdsbeperking is).</span><span class="sxs-lookup"><span data-stu-id="efac7-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="efac7-218">Wanneer een vermelding verlooptijd is bereikt, wordt de vermelding automatisch verwijderd.</span><span class="sxs-lookup"><span data-stu-id="efac7-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="efac7-219">Hierdoor krijgt u een venster met rolling 2 minuten.</span><span class="sxs-lookup"><span data-stu-id="efac7-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="efac7-220">Elke keer dat u een aanvraag naar de service storage u eerst gebruiken een Linq-query over het MemoryCache-object voor het berekenen van het percentage succes door de waarden op te tellen en te delen door het aantal.</span><span class="sxs-lookup"><span data-stu-id="efac7-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="efac7-221">Als het percentage succes zakt onder sommige drempelwaarde (zoals 10%), stelt de **LocationMode** eigenschap voor lezen aanvragen naar **SecondaryOnly** en schakel over naar de toepassing in de modus alleen-lezen voordat u doorgaat.</span><span class="sxs-lookup"><span data-stu-id="efac7-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="efac7-222">De drempelwaarde van fouten die worden gebruikt om te bepalen bij het maken van de switch kan variëren van services in uw toepassing, zodat u kunt overwegen om deze parameters kunnen worden geconfigureerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="efac7-223">Dit is ook waarin u kiest voor het afhandelen van herstelbare fouten van elke service afzonderlijk of als een, zoals eerder besproken.</span><span class="sxs-lookup"><span data-stu-id="efac7-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="efac7-224">Andere overweging is hoe meerdere exemplaren van een toepassing verwerkt, en wat te doen wanneer u in elk exemplaar herstelbare fouten worden opgespoord.</span><span class="sxs-lookup"><span data-stu-id="efac7-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="efac7-225">Bijvoorbeeld wellicht 20 VM's die worden uitgevoerd met dezelfde toepassing geladen.</span><span class="sxs-lookup"><span data-stu-id="efac7-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="efac7-226">Verwerkt u elke instantie afzonderlijk?</span><span class="sxs-lookup"><span data-stu-id="efac7-226">Do you handle each instance separately?</span></span> <span data-ttu-id="efac7-227">Als één exemplaar begint problemen, wilt u het antwoord op slechts één exemplaar beperken of u proberen wilt om alle exemplaren reageren op dezelfde manier als één exemplaar een probleem heeft?</span><span class="sxs-lookup"><span data-stu-id="efac7-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="efac7-228">Afhandeling van de exemplaren afzonderlijk is veel eenvoudiger dan probeert te coördineren van het antwoord onder te brengen, maar hoe u dit doen is afhankelijk van de architectuur van uw toepassing.</span><span class="sxs-lookup"><span data-stu-id="efac7-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="efac7-229">Opties voor het controleren van de frequentie van de fout</span><span class="sxs-lookup"><span data-stu-id="efac7-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="efac7-230">Hebt u drie belangrijkste mogelijkheden voor het controleren van de frequentie van nieuwe pogingen in de primaire regio om te bepalen wanneer u overstapt op de secundaire regio en het wijzigen van de toepassing uit te voeren in de modus alleen-lezen.</span><span class="sxs-lookup"><span data-stu-id="efac7-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="efac7-231">Toevoegen van een handler voor de [ **opnieuw proberen** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) gebeurtenis op de [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object die u doorgeeft aan uw opslag aanvragen: dit is de methode weergegeven in dit artikel en gebruikt in de bijbehorende steekproef.</span><span class="sxs-lookup"><span data-stu-id="efac7-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="efac7-232">Deze gebeurtenis geactiveerd wanneer de client een aanvraag opnieuw, zodat u bijhouden hoe vaak de client er een herstelbare fout op een primaire eindpunt optreedt.</span><span class="sxs-lookup"><span data-stu-id="efac7-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="efac7-233">In de [ **Evaluate** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) methode in een beleid voor aangepaste opnieuw proberen, kunt u aangepaste code uitvoeren telkens wanneer een nieuwe poging plaatsvindt.</span><span class="sxs-lookup"><span data-stu-id="efac7-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="efac7-234">Naast de opnemen wanneer een nieuwe poging gebeurt, dit biedt u eveneens de mogelijkheid om uw gedrag voor opnieuw proberen te wijzigen.</span><span class="sxs-lookup"><span data-stu-id="efac7-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="efac7-235">De derde aanpak is het implementeren van een aangepaste bewakingsonderdeel in uw toepassing waarmee u uw eindpunt primaire opslag voortdurend met dummy schijfleesaanvragen pingt (zoals het lezen van een kleine blob) om de status te bepalen.</span><span class="sxs-lookup"><span data-stu-id="efac7-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="efac7-236">Deze zou resources, maar een aanzienlijke duren.</span><span class="sxs-lookup"><span data-stu-id="efac7-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="efac7-237">Wanneer er een probleem is gedetecteerd dat de drempel bereikt, voert u vervolgens het overschakelen naar **SecondaryOnly** en alleen-lezen-modus.</span><span class="sxs-lookup"><span data-stu-id="efac7-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="efac7-238">U wilt overschakelen naar het primaire eindpunt gebruikt en het toestaan van updates op een bepaald moment.</span><span class="sxs-lookup"><span data-stu-id="efac7-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="efac7-239">Als u een van de eerste twee methoden die hierboven worden genoemd, kan u gewoon Ga terug naar de primaire eindpunt en de updatemodus inschakelen nadat een willekeurig geselecteerde hoeveelheid tijd of het aantal bewerkingen is uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="efac7-240">Vervolgens kunt u deze opnieuw de Pogingslogica doorlopen.</span><span class="sxs-lookup"><span data-stu-id="efac7-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="efac7-241">Als het probleem is verholpen, blijft het primaire eindpunt gebruikt en dat de updates.</span><span class="sxs-lookup"><span data-stu-id="efac7-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="efac7-242">Als er nog steeds een probleem is, zal deze één keer terug naar de secundaire eindpunt en de modus alleen-lezen overschakelen lukt de criteria die u hebt ingesteld.</span><span class="sxs-lookup"><span data-stu-id="efac7-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="efac7-243">Voor het derde scenario wanneer het eindpunt van de primaire opslag pingen weer mislukt, kunt u activeren de switch terug naar **PrimaryOnly** en doorgaan updates toestaan.</span><span class="sxs-lookup"><span data-stu-id="efac7-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="efac7-244">Uiteindelijk consistente gegevens verwerken</span><span class="sxs-lookup"><span data-stu-id="efac7-244">Handling eventually consistent data</span></span>

<span data-ttu-id="efac7-245">RA-GRS werkt met het repliceren van transacties van de primaire naar de secundaire regio.</span><span class="sxs-lookup"><span data-stu-id="efac7-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="efac7-246">Dit replicatieproces zorgt ervoor dat de gegevens in de secundaire regio is *uiteindelijk consistent*.</span><span class="sxs-lookup"><span data-stu-id="efac7-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="efac7-247">Dit betekent dat alle transacties in de primaire regio uiteindelijk wordt weergegeven in de secundaire regio, maar dat er mogelijk een vertraging voordat ze worden weergegeven en of er is geen garantie de transacties in de secundaire regio in dezelfde volgorde als waarin ze oorspronkelijk zijn toegepast in de primaire regio binnenkomen.</span><span class="sxs-lookup"><span data-stu-id="efac7-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="efac7-248">Als uw transacties in de secundaire regio volgorde plaatsvinden, u *mogelijk* Houd rekening met uw gegevens in de secundaire regio niet in een inconsistente status totdat de service de resultaten.</span><span class="sxs-lookup"><span data-stu-id="efac7-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="efac7-249">De volgende tabel toont een voorbeeld van wat er gebeuren kan wanneer u de details van een werknemer haar een lid maken van bijwerken de *beheerders* rol.</span><span class="sxs-lookup"><span data-stu-id="efac7-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="efac7-250">In dit voorbeeld hiervoor moet u bijwerken de **werknemer** entiteit en update een **beheerdersrol** entiteit met een telling van het totale aantal beheerders.</span><span class="sxs-lookup"><span data-stu-id="efac7-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="efac7-251">U ziet hoe de updates volgorde in de secundaire regio worden toegepast.</span><span class="sxs-lookup"><span data-stu-id="efac7-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="efac7-252">**Tijd**</span><span class="sxs-lookup"><span data-stu-id="efac7-252">**Time**</span></span> | <span data-ttu-id="efac7-253">**Transactie**</span><span class="sxs-lookup"><span data-stu-id="efac7-253">**Transaction**</span></span>                                            | <span data-ttu-id="efac7-254">**Replicatie**</span><span class="sxs-lookup"><span data-stu-id="efac7-254">**Replication**</span></span>                       | <span data-ttu-id="efac7-255">**Tijd van laatste synchronisatie**</span><span class="sxs-lookup"><span data-stu-id="efac7-255">**Last Sync Time**</span></span> | <span data-ttu-id="efac7-256">**Resultaat**</span><span class="sxs-lookup"><span data-stu-id="efac7-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="efac7-257">T0</span><span class="sxs-lookup"><span data-stu-id="efac7-257">T0</span></span>       | <span data-ttu-id="efac7-258">Transactie A:</span><span class="sxs-lookup"><span data-stu-id="efac7-258">Transaction A:</span></span> <br> <span data-ttu-id="efac7-259">Werknemer invoegen</span><span class="sxs-lookup"><span data-stu-id="efac7-259">Insert employee</span></span> <br> <span data-ttu-id="efac7-260">entiteit in primaire</span><span class="sxs-lookup"><span data-stu-id="efac7-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="efac7-261">Transactie A ingevoegd op primaire,</span><span class="sxs-lookup"><span data-stu-id="efac7-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="efac7-262">nog niet gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-262">not replicated yet.</span></span> |
| <span data-ttu-id="efac7-263">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-263">T1</span></span>       |                                                            | <span data-ttu-id="efac7-264">Een transactie</span><span class="sxs-lookup"><span data-stu-id="efac7-264">Transaction A</span></span> <br> <span data-ttu-id="efac7-265">gerepliceerd naar</span><span class="sxs-lookup"><span data-stu-id="efac7-265">replicated to</span></span><br> <span data-ttu-id="efac7-266">secundaire</span><span class="sxs-lookup"><span data-stu-id="efac7-266">secondary</span></span> | <span data-ttu-id="efac7-267">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-267">T1</span></span> | <span data-ttu-id="efac7-268">Een transactie is gerepliceerd naar de secundaire.</span><span class="sxs-lookup"><span data-stu-id="efac7-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="efac7-269">Tijd van laatste synchronisatie is bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="efac7-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="efac7-270">T2</span><span class="sxs-lookup"><span data-stu-id="efac7-270">T2</span></span>       | <span data-ttu-id="efac7-271">Transactie B:</span><span class="sxs-lookup"><span data-stu-id="efac7-271">Transaction B:</span></span><br><span data-ttu-id="efac7-272">Update</span><span class="sxs-lookup"><span data-stu-id="efac7-272">Update</span></span><br> <span data-ttu-id="efac7-273">werknemer-entiteit</span><span class="sxs-lookup"><span data-stu-id="efac7-273">employee entity</span></span><br> <span data-ttu-id="efac7-274">in primaire</span><span class="sxs-lookup"><span data-stu-id="efac7-274">in primary</span></span>  |                                | <span data-ttu-id="efac7-275">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-275">T1</span></span>                 | <span data-ttu-id="efac7-276">Transactie geschreven naar de primaire B</span><span class="sxs-lookup"><span data-stu-id="efac7-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="efac7-277">nog niet gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-277">not replicated yet.</span></span>  |
| <span data-ttu-id="efac7-278">T3</span><span class="sxs-lookup"><span data-stu-id="efac7-278">T3</span></span>       | <span data-ttu-id="efac7-279">Transactie C:</span><span class="sxs-lookup"><span data-stu-id="efac7-279">Transaction C:</span></span><br> <span data-ttu-id="efac7-280">Update</span><span class="sxs-lookup"><span data-stu-id="efac7-280">Update</span></span> <br><span data-ttu-id="efac7-281">Beheerder</span><span class="sxs-lookup"><span data-stu-id="efac7-281">administrator</span></span><br><span data-ttu-id="efac7-282">de entiteit rol in</span><span class="sxs-lookup"><span data-stu-id="efac7-282">role entity in</span></span><br><span data-ttu-id="efac7-283">primaire</span><span class="sxs-lookup"><span data-stu-id="efac7-283">primary</span></span> |                    | <span data-ttu-id="efac7-284">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-284">T1</span></span>                 | <span data-ttu-id="efac7-285">Transactie geschreven naar de primaire, C</span><span class="sxs-lookup"><span data-stu-id="efac7-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="efac7-286">nog niet gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-286">not replicated yet.</span></span>  |
| <span data-ttu-id="efac7-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="efac7-287">*T4*</span></span>     |                                                       | <span data-ttu-id="efac7-288">Transactie C</span><span class="sxs-lookup"><span data-stu-id="efac7-288">Transaction C</span></span> <br><span data-ttu-id="efac7-289">gerepliceerd naar</span><span class="sxs-lookup"><span data-stu-id="efac7-289">replicated to</span></span><br> <span data-ttu-id="efac7-290">secundaire</span><span class="sxs-lookup"><span data-stu-id="efac7-290">secondary</span></span> | <span data-ttu-id="efac7-291">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-291">T1</span></span>         | <span data-ttu-id="efac7-292">Transactie C gerepliceerd naar de secundaire.</span><span class="sxs-lookup"><span data-stu-id="efac7-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="efac7-293">LastSyncTime niet bijgewerkt, omdat</span><span class="sxs-lookup"><span data-stu-id="efac7-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="efac7-294">transactie B is nog niet gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="efac7-295">*T 5*</span><span class="sxs-lookup"><span data-stu-id="efac7-295">*T5*</span></span>     | <span data-ttu-id="efac7-296">Entiteiten lezen</span><span class="sxs-lookup"><span data-stu-id="efac7-296">Read entities</span></span> <br><span data-ttu-id="efac7-297">secundaire</span><span class="sxs-lookup"><span data-stu-id="efac7-297">from secondary</span></span>                           |                                  | <span data-ttu-id="efac7-298">T1</span><span class="sxs-lookup"><span data-stu-id="efac7-298">T1</span></span>                 | <span data-ttu-id="efac7-299">Ophalen van de verouderde waarde voor de werknemer</span><span class="sxs-lookup"><span data-stu-id="efac7-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="efac7-300">entiteit omdat de transactie B nog niet</span><span class="sxs-lookup"><span data-stu-id="efac7-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="efac7-301">nog gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-301">replicated yet.</span></span> <span data-ttu-id="efac7-302">Ophalen van de nieuwe waarde voor</span><span class="sxs-lookup"><span data-stu-id="efac7-302">You get the new value for</span></span><br> <span data-ttu-id="efac7-303">Administrator-rol entiteit omdat C</span><span class="sxs-lookup"><span data-stu-id="efac7-303">administrator role entity because C has</span></span><br> <span data-ttu-id="efac7-304">gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-304">replicated.</span></span> <span data-ttu-id="efac7-305">Tijd van laatste synchronisatie is nog steeds niet</span><span class="sxs-lookup"><span data-stu-id="efac7-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="efac7-306">is bijgewerkt, omdat de transactie B</span><span class="sxs-lookup"><span data-stu-id="efac7-306">been updated because transaction B</span></span><br> <span data-ttu-id="efac7-307">nog niet gerepliceerd.</span><span class="sxs-lookup"><span data-stu-id="efac7-307">hasn't replicated.</span></span> <span data-ttu-id="efac7-308">U kunt zien de</span><span class="sxs-lookup"><span data-stu-id="efac7-308">You can tell the</span></span><br><span data-ttu-id="efac7-309">Administrator-rol entiteit komt niet overeen</span><span class="sxs-lookup"><span data-stu-id="efac7-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="efac7-310">omdat de entiteit datum/tijd na</span><span class="sxs-lookup"><span data-stu-id="efac7-310">because the entity date/time is after</span></span> <br><span data-ttu-id="efac7-311">de tijd van laatste synchronisatie.</span><span class="sxs-lookup"><span data-stu-id="efac7-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="efac7-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="efac7-312">*T6*</span></span>     |                                                      | <span data-ttu-id="efac7-313">Transactie B</span><span class="sxs-lookup"><span data-stu-id="efac7-313">Transaction B</span></span><br> <span data-ttu-id="efac7-314">gerepliceerd naar</span><span class="sxs-lookup"><span data-stu-id="efac7-314">replicated to</span></span><br> <span data-ttu-id="efac7-315">secundaire</span><span class="sxs-lookup"><span data-stu-id="efac7-315">secondary</span></span> | <span data-ttu-id="efac7-316">T6</span><span class="sxs-lookup"><span data-stu-id="efac7-316">T6</span></span>                 | <span data-ttu-id="efac7-317">*T6* – alle transacties via C hebben</span><span class="sxs-lookup"><span data-stu-id="efac7-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="efac7-318">zijn gerepliceerd, tijd van laatste synchronisatie</span><span class="sxs-lookup"><span data-stu-id="efac7-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="efac7-319">is bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="efac7-319">is updated.</span></span> |

<span data-ttu-id="efac7-320">In dit voorbeeld wordt ervan uitgegaan dat de client overschakelt naar het lezen van de secundaire regio op t 5.</span><span class="sxs-lookup"><span data-stu-id="efac7-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="efac7-321">Deze kan lezen de **beheerdersrol** entiteit op dit moment, maar de entiteit bevat een waarde op voor het aantal komt niet overeen met het aantal beheerders **werknemer** entiteiten die zijn gemarkeerd als beheerders in de secundaire regio op dit moment.</span><span class="sxs-lookup"><span data-stu-id="efac7-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="efac7-322">De client kan deze waarde, met het risico dat het inconsistente informatie is gewoon weergeven.</span><span class="sxs-lookup"><span data-stu-id="efac7-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="efac7-323">U kunt ook de client kan proberen om te bepalen die de **beheerdersrol** is een mogelijk inconsistente status omdat de updates is een ongeldige volgorde, en vervolgens de gebruiker van dit feit informeert.</span><span class="sxs-lookup"><span data-stu-id="efac7-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="efac7-324">Voor het herkennen van of deze heeft mogelijk inconsistente gegevens, de client gebruikt de waarde van de *tijd van laatste synchronisatie* dat u op elk gewenst moment ophalen kunt door het opvragen van een storage-service.</span><span class="sxs-lookup"><span data-stu-id="efac7-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="efac7-325">Weet u de tijd waarop de gegevens in de secundaire regio laatst consistent en wanneer de service alle transacties voorafgaand aan dat punt in tijd waren toegepast.</span><span class="sxs-lookup"><span data-stu-id="efac7-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="efac7-326">In het voorbeeld hierboven, nadat de service wordt ingevoegd de **werknemer** entiteit in de secundaire regio, de tijd van laatste synchronisatie is ingesteld op *T1*.</span><span class="sxs-lookup"><span data-stu-id="efac7-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="efac7-327">Blijft *T1* tot de service-updates de **werknemer** entiteit in de secundaire regio wanneer deze is ingesteld op *T6*.</span><span class="sxs-lookup"><span data-stu-id="efac7-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="efac7-328">Als de client worden opgehaald van de tijd van laatste synchronisatie het lezen van de entiteit op *t 5*, deze kan worden vergeleken met de tijdstempel op de entiteit.</span><span class="sxs-lookup"><span data-stu-id="efac7-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="efac7-329">Als de tijdstempel op de entiteit later dan de tijd van laatste synchronisatie is, klikt u vervolgens de entiteit is een mogelijk inconsistente status heeft en u kunt nemen wat is de juiste actie voor uw toepassing.</span><span class="sxs-lookup"><span data-stu-id="efac7-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="efac7-330">In dit veld is vereist dat u weet waarop het laatst is bijgewerkt naar de primaire is voltooid.</span><span class="sxs-lookup"><span data-stu-id="efac7-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="efac7-331">Testen</span><span class="sxs-lookup"><span data-stu-id="efac7-331">Testing</span></span>

<span data-ttu-id="efac7-332">Het is belangrijk om te testen dat uw toepassing werkt zoals verwacht wanneer herstelbare fouten worden aangetroffen.</span><span class="sxs-lookup"><span data-stu-id="efac7-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="efac7-333">Bijvoorbeeld, wilt u testen dat de toepassing aan de secundaire en in de modus alleen-lezen wanneer deze een probleem detecteert en verandert teruggeschakeld wanneer de primaire regio weer beschikbaar.</span><span class="sxs-lookup"><span data-stu-id="efac7-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="efac7-334">Om dit te doen, moet u een manier om te simuleren herstelbare fouten en beheer op hoe vaak ze voorkomen.</span><span class="sxs-lookup"><span data-stu-id="efac7-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="efac7-335">U kunt [Fiddler](http://www.telerik.com/fiddler) onderscheppen en HTTP-antwoorden in een script wijzigen.</span><span class="sxs-lookup"><span data-stu-id="efac7-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="efac7-336">Dit script kunt identificeren van reacties die afkomstig van uw primaire eindpunt zijn en de HTTP-statuscode wijzigen dat de Opslagclientbibliotheek wordt herkend als een herstelbare fout.</span><span class="sxs-lookup"><span data-stu-id="efac7-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="efac7-337">Dit codefragment toont een eenvoudig voorbeeld van een Fiddler-script waarmee antwoorden onderschept moeten worden gelezen aanvragen op basis van de **employeedata** tabel de status 502:</span><span class="sxs-lookup"><span data-stu-id="efac7-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="efac7-338">U kunt dit voorbeeld voor het onderscheppen van een breed scala aan aanvragen en alleen wijzigen uitbreiden de **responseCode** op sommige hiervan een Praktijkscenario beter te simuleren.</span><span class="sxs-lookup"><span data-stu-id="efac7-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="efac7-339">Zie voor meer informatie over het aanpassen van Fiddler scripts [wijzigen van een aanvraag of antwoord](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in de documentatie van Fiddler.</span><span class="sxs-lookup"><span data-stu-id="efac7-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="efac7-340">Als u de drempelwaarden voor het overschakelen van uw toepassing naar de alleen-lezen-modus worden geconfigureerd hebt aangebracht, worden deze eenvoudiger is om het gedrag met niet-productieve transactie volumes te testen.</span><span class="sxs-lookup"><span data-stu-id="efac7-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="efac7-341">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="efac7-341">Next Steps</span></span>

* <span data-ttu-id="efac7-342">Zie voor meer informatie over leestoegang geografische redundantie, met inbegrip van een ander voorbeeld van hoe de LastSyncTime is ingesteld, neem [Windows Azure-opslagopties redundantie en geografisch redundante opslag met leestoegang](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span><span class="sxs-lookup"><span data-stu-id="efac7-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="efac7-343">Zie voor een compleet codevoorbeeld waarin wordt getoond hoe u de schakeloptie heen en weer tussen de primaire en secundaire eindpunten, [Azure Samples – het Circuitonderbreker-patroon gebruiken met RA-GRS-storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span><span class="sxs-lookup"><span data-stu-id="efac7-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
