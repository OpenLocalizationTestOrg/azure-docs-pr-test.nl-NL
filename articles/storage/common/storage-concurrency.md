---
title: Gelijktijdigheid beheren in Microsoft Azure Storage
description: Gelijktijdigheid van taken voor de services Blob, Queue, Table en bestand beheren
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 937cca66a0af0674b868e6a87681adbea330e91c
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/29/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="bf93c-103">Gelijktijdigheid beheren in Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="bf93c-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="bf93c-104">Overzicht</span><span class="sxs-lookup"><span data-stu-id="bf93c-104">Overview</span></span>
<span data-ttu-id="bf93c-105">Moderne internetgebaseerde toepassingen hebben meestal meerdere gebruikers weergeven en gegevens tegelijkertijd bijwerken.</span><span class="sxs-lookup"><span data-stu-id="bf93c-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="bf93c-106">U moet hiervoor toepassingsontwikkelaars zorgvuldig bedenken hoe u een voorspelbare om ervaring te bieden aan hun eindgebruikers, met name voor scenario's waarin meerdere gebruikers dezelfde gegevens kunnen bijwerken.</span><span class="sxs-lookup"><span data-stu-id="bf93c-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="bf93c-107">Er zijn drie belangrijkste gegevens gelijktijdigheidsstrategieën die ontwikkelaars doorgaans overwegen:</span><span class="sxs-lookup"><span data-stu-id="bf93c-107">There are three main data concurrency strategies that developers typically consider:</span></span>  

1. <span data-ttu-id="bf93c-108">Optimistische gelijktijdigheid: een toepassing uitvoeren van die een update als onderdeel van de update controleert of de gegevens is gewijzigd sinds de toepassing die gegevens laatst gelezen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="bf93c-109">Bijvoorbeeld, als twee gebruikers een wiki-pagina een update op dezelfde pagina moeten vervolgens het wiki-platform moet ervoor zorgen dat de tweede update niet de eerste update – overschreven en dat de beide gebruikers begrijpen of de update is voltooid.</span><span class="sxs-lookup"><span data-stu-id="bf93c-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="bf93c-110">Deze strategie wordt meestal gebruikt in webtoepassingen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="bf93c-111">Volledige vergrendeling: een toepassing wilt uitvoeren van een update duurt een vergrendeling op een object te voorkomen dat andere gebruikers de gegevens worden bijgewerkt tot de vergrendeling is vrijgegeven.</span><span class="sxs-lookup"><span data-stu-id="bf93c-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="bf93c-112">Bijvoorbeeld in een master/slave gegevens replicatiescenario waarbij alleen de master updates wordt uitgevoerd wordt het model doorgaans houdt een exclusieve vergrendeling voor langere tijd op de gegevens zodat niemand anders kunt bijwerken.</span><span class="sxs-lookup"><span data-stu-id="bf93c-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="bf93c-113">Laatste schrijver wins – een methode waarmee de bijwerkbewerkingen om door te gaan zonder te controleren als een andere toepassing heeft bijgewerkt de gegevens sinds de toepassing eerst de gegevens niet lezen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="bf93c-114">Deze strategie (of het ontbreken van een strategie voor een formele) wordt meestal gebruikt waarbij de gegevens zijn gepartitioneerd zodanig dat er geen kans dat meerdere gebruikers toegang krijgen dezelfde gegevens tot is.</span><span class="sxs-lookup"><span data-stu-id="bf93c-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="bf93c-115">Dit kan ook nuttig zijn wanneer tijdelijke gegevensstromen wordt verwerkt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="bf93c-116">Dit artikel bevat een overzicht van hoe de Azure Storage-platform vereenvoudigt ook de ontwikkeling eerste-klas door ondersteuning te bieden voor alle drie deze strategieën gelijktijdigheid van taken.</span><span class="sxs-lookup"><span data-stu-id="bf93c-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="bf93c-117">Azure Storage: vereenvoudigt ook de ontwikkeling van de Cloud</span><span class="sxs-lookup"><span data-stu-id="bf93c-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="bf93c-118">De Azure storage-service ondersteunt alle drie strategieën, hoewel het onderscheidende in de mogelijkheid om aan te bieden volledige ondersteuning voor de optimistische en volledige gelijktijdigheid omdat deze is ontworpen om in te spelen van een model sterke consistentie wordt gegarandeerd dat wanneer de Storage-service een gegevens-insert voert of update-bewerking alle verdere toegang heeft tot aan gegevens ziet de nieuwste update van is.</span><span class="sxs-lookup"><span data-stu-id="bf93c-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="bf93c-119">Opslagplatforms die gebruikmaken van een model uiteindelijke consistentie hebben een vertraging tussen wanneer een schrijfbewerking wordt uitgevoerd door één gebruiker en wanneer de bijgewerkte gegevens zijn zichtbaar voor andere gebruikers dus complicerende ontwikkeling van clienttoepassingen om inconsistenties te voorkomen dat van invloed zijn op eindgebruikers.</span><span class="sxs-lookup"><span data-stu-id="bf93c-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="bf93c-120">Naast het selecteren van een gelijktijdigheidsstrategie voor een juiste moet ontwikkelaars ook rekening houden met hoe wijzigingen – met name wijzigingen aan hetzelfde object via transacties Hiermee isoleert u een opslag-platform.</span><span class="sxs-lookup"><span data-stu-id="bf93c-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="bf93c-121">De Azure storage-service gebruikt snapshot-isolatie om toe te staan leesbewerkingen gebeurt als schrijfbewerkingen binnen één partitie.</span><span class="sxs-lookup"><span data-stu-id="bf93c-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="bf93c-122">In tegenstelling tot andere isolatieniveaus snapshot-isolatie wordt gegarandeerd dat alle leesbewerkingen een consistente momentopname van de gegevens zien terwijl updates worden gegeven – in wezen door te retourneren van de laatste doorgevoerd waarden tijdens een update transactie verwerkt wordt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="bf93c-123">Gelijktijdigheid van taken in Blob storage beheren</span><span class="sxs-lookup"><span data-stu-id="bf93c-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="bf93c-124">U kunt ervoor kiezen voor het gebruik van beide modellen optimistische of volledige gelijktijdigheid van taken voor het beheren van toegang tot blobs en containers in de blob-service.</span><span class="sxs-lookup"><span data-stu-id="bf93c-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="bf93c-125">Als u een strategie voor laatste schrijfbewerkingen wins niet expliciet opgeeft is de standaardinstelling.</span><span class="sxs-lookup"><span data-stu-id="bf93c-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="bf93c-126">Optimistische gelijktijdigheid voor blobs en containers</span><span class="sxs-lookup"><span data-stu-id="bf93c-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="bf93c-127">De Storage-service wijst een id toe aan elk object dat is opgeslagen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="bf93c-128">Deze id wordt telkens bijgewerkt wanneer een updatebewerking wordt uitgevoerd op een object.</span><span class="sxs-lookup"><span data-stu-id="bf93c-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="bf93c-129">De id wordt geretourneerd naar de client als onderdeel van een HTTP GET-antwoord met de ETag-header voor (entiteitscode) die is gedefinieerd in het HTTP-protocol.</span><span class="sxs-lookup"><span data-stu-id="bf93c-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="bf93c-130">Een gebruiker een update uitvoeren op een dergelijk object kunt in de oorspronkelijke ETag samen met een voorwaardelijke kop verzenden om ervoor te zorgen dat een update vindt alleen plaats als een bepaalde voorwaarde is voldaan: in dit geval de voorwaarde is een header 'If-Match', waarvoor de Storage-Service-t o Zorg ervoor dat de waarde van de ETag die is opgegeven in de updateaanvraag is hetzelfde als die opgeslagen in de Storage-Service.</span><span class="sxs-lookup"><span data-stu-id="bf93c-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header, which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="bf93c-131">Het overzicht van dit proces is als volgt:</span><span class="sxs-lookup"><span data-stu-id="bf93c-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="bf93c-132">Een blob ophalen uit de storage-service, het antwoord bevat een HTTP-ETag-Header-waarde die aangeeft van de huidige versie van het object in de storage-service.</span><span class="sxs-lookup"><span data-stu-id="bf93c-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="bf93c-133">Wanneer u de blob bijwerkt, omvatten de ETag-waarde die u hebt ontvangen in stap 1 van de **If-Match** voorwaardelijke kop van de aanvraag die u naar de service verzendt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="bf93c-134">De service vergelijkt de ETag-waarde in de aanvraag met de huidige ETag-waarde van de blob.</span><span class="sxs-lookup"><span data-stu-id="bf93c-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="bf93c-135">Als de huidige ETag-waarde van de blob is een verschillende versie dan de ETag in de **If-Match** voorwaardelijke kop in de aanvraag kan de service een 412-fout geretourneerd op de client.</span><span class="sxs-lookup"><span data-stu-id="bf93c-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="bf93c-136">Hiermee geeft u aan de client of een ander proces de blob is bijgewerkt sinds deze de client opgehaald.</span><span class="sxs-lookup"><span data-stu-id="bf93c-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="bf93c-137">Als de huidige ETag-waarde van de blob is dezelfde versie als de ETag in de **If-Match** voorwaardelijke kop in de aanvraag kan de service de aangevraagde bewerking wordt uitgevoerd en updates van de huidige ETag-waarde van de blob om weer te geven dat deze een nieuwe versie gemaakt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="bf93c-138">De volgende C#-fragment (met behulp van de Storage-clientbibliotheek 4.2.0) toont een eenvoudig voorbeeld van het maken van een **If-Match AccessCondition** op basis van de ETag-waarde die toegankelijk is via de eigenschappen van een blob die is eerder opgehaald of ingevoegd.</span><span class="sxs-lookup"><span data-stu-id="bf93c-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="bf93c-139">Vervolgens wordt de **AccessCondition** tijdens het bijwerken van de blob-object: de **AccessCondition** object voegt de **If-Match** header met de aanvraag.</span><span class="sxs-lookup"><span data-stu-id="bf93c-139">It then uses the **AccessCondition** object when it updates the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="bf93c-140">Wanneer de blob is bijgewerkt naar een ander proces, retourneert de blob-service een statusbericht HTTP 412 (voorwaarde is mislukt).</span><span class="sxs-lookup"><span data-stu-id="bf93c-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="bf93c-141">U kunt het volledige voorbeeld hier downloaden: [beheren gelijktijdigheid van taken met behulp van Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="bf93c-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="bf93c-142">De Storage-Service biedt ook ondersteuning voor extra voorwaardelijke kopteksten, zoals **If-Modified-Since**, **If-Unmodified-Since** en **If-None-Match** evenals combinaties daarvan.</span><span class="sxs-lookup"><span data-stu-id="bf93c-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="bf93c-143">Zie voor meer informatie [voorwaardelijke Headers opgeven voor Blob-servicebewerkingen](http://msdn.microsoft.com/library/azure/dd179371.aspx) op MSDN.</span><span class="sxs-lookup"><span data-stu-id="bf93c-143">For more information, see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="bf93c-144">De volgende tabel geeft een overzicht van de container-bewerkingen die voorwaardelijke kop, zoals accepteren **If-Match** in de aanvraag en die een ETag-waarde in het antwoord retourneren.</span><span class="sxs-lookup"><span data-stu-id="bf93c-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="bf93c-145">Bewerking</span><span class="sxs-lookup"><span data-stu-id="bf93c-145">Operation</span></span> | <span data-ttu-id="bf93c-146">Container ETag-waarde retourneert</span><span class="sxs-lookup"><span data-stu-id="bf93c-146">Returns Container ETag value</span></span> | <span data-ttu-id="bf93c-147">Voorwaardelijke kop accepteert</span><span class="sxs-lookup"><span data-stu-id="bf93c-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="bf93c-148">Container maken</span><span class="sxs-lookup"><span data-stu-id="bf93c-148">Create Container</span></span> |<span data-ttu-id="bf93c-149">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-149">Yes</span></span> |<span data-ttu-id="bf93c-150">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-150">No</span></span> |
| <span data-ttu-id="bf93c-151">Eigenschappen van Container ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-151">Get Container Properties</span></span> |<span data-ttu-id="bf93c-152">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-152">Yes</span></span> |<span data-ttu-id="bf93c-153">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-153">No</span></span> |
| <span data-ttu-id="bf93c-154">Container metagegevens ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-154">Get Container Metadata</span></span> |<span data-ttu-id="bf93c-155">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-155">Yes</span></span> |<span data-ttu-id="bf93c-156">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-156">No</span></span> |
| <span data-ttu-id="bf93c-157">Metagegevens van de Container instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-157">Set Container Metadata</span></span> |<span data-ttu-id="bf93c-158">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-158">Yes</span></span> |<span data-ttu-id="bf93c-159">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-159">Yes</span></span> |
| <span data-ttu-id="bf93c-160">Container-ACL ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-160">Get Container ACL</span></span> |<span data-ttu-id="bf93c-161">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-161">Yes</span></span> |<span data-ttu-id="bf93c-162">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-162">No</span></span> |
| <span data-ttu-id="bf93c-163">Container-ACL instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-163">Set Container ACL</span></span> |<span data-ttu-id="bf93c-164">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-164">Yes</span></span> |<span data-ttu-id="bf93c-165">Ja (*)</span><span class="sxs-lookup"><span data-stu-id="bf93c-165">Yes (*)</span></span> |
| <span data-ttu-id="bf93c-166">Verwijderen van Container</span><span class="sxs-lookup"><span data-stu-id="bf93c-166">Delete Container</span></span> |<span data-ttu-id="bf93c-167">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-167">No</span></span> |<span data-ttu-id="bf93c-168">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-168">Yes</span></span> |
| <span data-ttu-id="bf93c-169">Lease-Container</span><span class="sxs-lookup"><span data-stu-id="bf93c-169">Lease Container</span></span> |<span data-ttu-id="bf93c-170">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-170">Yes</span></span> |<span data-ttu-id="bf93c-171">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-171">Yes</span></span> |
| <span data-ttu-id="bf93c-172">Lijst met BLOB 's</span><span class="sxs-lookup"><span data-stu-id="bf93c-172">List Blobs</span></span> |<span data-ttu-id="bf93c-173">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-173">No</span></span> |<span data-ttu-id="bf93c-174">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-174">No</span></span> |

<span data-ttu-id="bf93c-175">(*) De machtigingen die zijn gedefinieerd door SetContainerACL in de cache zijn opgeslagen en updates voor deze machtigingen 30 seconden duren doorgegeven tijdens de periode waarin updates zijn niet gegarandeerd consistent zijn.</span><span class="sxs-lookup"><span data-stu-id="bf93c-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="bf93c-176">De volgende tabel geeft een overzicht van de blob-bewerkingen die voorwaardelijke kop, zoals accepteren **If-Match** in de aanvraag en die een ETag-waarde in het antwoord retourneren.</span><span class="sxs-lookup"><span data-stu-id="bf93c-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="bf93c-177">Bewerking</span><span class="sxs-lookup"><span data-stu-id="bf93c-177">Operation</span></span> | <span data-ttu-id="bf93c-178">ETag-waarde retourneert</span><span class="sxs-lookup"><span data-stu-id="bf93c-178">Returns ETag value</span></span> | <span data-ttu-id="bf93c-179">Voorwaardelijke kop accepteert</span><span class="sxs-lookup"><span data-stu-id="bf93c-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="bf93c-180">Blob plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-180">Put Blob</span></span> |<span data-ttu-id="bf93c-181">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-181">Yes</span></span> |<span data-ttu-id="bf93c-182">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-182">Yes</span></span> |
| <span data-ttu-id="bf93c-183">Ophalen van Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-183">Get Blob</span></span> |<span data-ttu-id="bf93c-184">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-184">Yes</span></span> |<span data-ttu-id="bf93c-185">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-185">Yes</span></span> |
| <span data-ttu-id="bf93c-186">Blob-eigenschappen ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-186">Get Blob Properties</span></span> |<span data-ttu-id="bf93c-187">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-187">Yes</span></span> |<span data-ttu-id="bf93c-188">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-188">Yes</span></span> |
| <span data-ttu-id="bf93c-189">Blob-eigenschappen instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-189">Set Blob Properties</span></span> |<span data-ttu-id="bf93c-190">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-190">Yes</span></span> |<span data-ttu-id="bf93c-191">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-191">Yes</span></span> |
| <span data-ttu-id="bf93c-192">Blobmetagegevens ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-192">Get Blob Metadata</span></span> |<span data-ttu-id="bf93c-193">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-193">Yes</span></span> |<span data-ttu-id="bf93c-194">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-194">Yes</span></span> |
| <span data-ttu-id="bf93c-195">Blobmetagegevens instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-195">Set Blob Metadata</span></span> |<span data-ttu-id="bf93c-196">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-196">Yes</span></span> |<span data-ttu-id="bf93c-197">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-197">Yes</span></span> |
| <span data-ttu-id="bf93c-198">Lease-Blob (*)</span><span class="sxs-lookup"><span data-stu-id="bf93c-198">Lease Blob (*)</span></span> |<span data-ttu-id="bf93c-199">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-199">Yes</span></span> |<span data-ttu-id="bf93c-200">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-200">Yes</span></span> |
| <span data-ttu-id="bf93c-201">Momentopname Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-201">Snapshot Blob</span></span> |<span data-ttu-id="bf93c-202">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-202">Yes</span></span> |<span data-ttu-id="bf93c-203">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-203">Yes</span></span> |
| <span data-ttu-id="bf93c-204">Blob kopiëren</span><span class="sxs-lookup"><span data-stu-id="bf93c-204">Copy Blob</span></span> |<span data-ttu-id="bf93c-205">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-205">Yes</span></span> |<span data-ttu-id="bf93c-206">Ja (voor een bron- en doelserver blob)</span><span class="sxs-lookup"><span data-stu-id="bf93c-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="bf93c-207">Blob kopiëren afbreken</span><span class="sxs-lookup"><span data-stu-id="bf93c-207">Abort Copy Blob</span></span> |<span data-ttu-id="bf93c-208">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-208">No</span></span> |<span data-ttu-id="bf93c-209">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-209">No</span></span> |
| <span data-ttu-id="bf93c-210">Verwijderen van Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-210">Delete Blob</span></span> |<span data-ttu-id="bf93c-211">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-211">No</span></span> |<span data-ttu-id="bf93c-212">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-212">Yes</span></span> |
| <span data-ttu-id="bf93c-213">Blok plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-213">Put Block</span></span> |<span data-ttu-id="bf93c-214">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-214">No</span></span> |<span data-ttu-id="bf93c-215">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-215">No</span></span> |
| <span data-ttu-id="bf93c-216">Lijst met geblokkeerde websites plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-216">Put Block List</span></span> |<span data-ttu-id="bf93c-217">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-217">Yes</span></span> |<span data-ttu-id="bf93c-218">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-218">Yes</span></span> |
| <span data-ttu-id="bf93c-219">Lijst met geblokkeerde websites ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-219">Get Block List</span></span> |<span data-ttu-id="bf93c-220">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-220">Yes</span></span> |<span data-ttu-id="bf93c-221">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-221">No</span></span> |
| <span data-ttu-id="bf93c-222">Pagina plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-222">Put Page</span></span> |<span data-ttu-id="bf93c-223">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-223">Yes</span></span> |<span data-ttu-id="bf93c-224">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-224">Yes</span></span> |
| <span data-ttu-id="bf93c-225">Get-paginabereiken</span><span class="sxs-lookup"><span data-stu-id="bf93c-225">Get Page Ranges</span></span> |<span data-ttu-id="bf93c-226">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-226">Yes</span></span> |<span data-ttu-id="bf93c-227">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-227">Yes</span></span> |

<span data-ttu-id="bf93c-228">(*) De ETag op een blob lease Blob niet gewijzigd.</span><span class="sxs-lookup"><span data-stu-id="bf93c-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="bf93c-229">Volledige vergrendeling voor blobs</span><span class="sxs-lookup"><span data-stu-id="bf93c-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="bf93c-230">Als u wilt vergrendelen van een blob voor exclusief gebruik, kunt u aanschaffen een [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) erop.</span><span class="sxs-lookup"><span data-stu-id="bf93c-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="bf93c-231">Wanneer u een lease aanschaft, u opgeven hoe lang moet u de lease: dit kan zijn voor tussen 15 tot 60 seconden of oneindig die naar een exclusieve vergrendeling bedragen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite, which amounts to an exclusive lock.</span></span> <span data-ttu-id="bf93c-232">U kunt een eindige lease te laten verlengen en u kunt een lease vrijgeven wanneer u klaar met het bent.</span><span class="sxs-lookup"><span data-stu-id="bf93c-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="bf93c-233">De blob-service wordt automatisch eindig leases versies wanneer ze zijn verlopen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="bf93c-234">Leases schakelen verschillende synchronisatie strategieën om te worden ondersteund, met inbegrip van exclusieve schrijven / lezen, exclusieve schrijven gedeeld / exclusief lezen en schrijven gedeeld / exclusief lezen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="bf93c-235">Wanneer een lease bestaat de storage-service wordt afgedwongen exclusief schrijfbewerkingen (plaatsen, instellen en verwijderbewerkingen) exclusiviteit voor leesbewerkingen gezorgd moet echter de ontwikkelaar om ervoor te zorgen dat alle clienttoepassingen een lease-ID en die slechts één client tegelijk gebruiken heeft een geldige lease-ID.</span><span class="sxs-lookup"><span data-stu-id="bf93c-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="bf93c-236">Leesbewerkingen die een lease-ID-resultaat niet in gedeelde leest opnemen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="bf93c-237">De volgende C#-fragment toont een voorbeeld van een exclusieve lease verkrijgen gedurende 30 seconden op een blob en vervolgens de lease los te laten bijwerken van de inhoud van de blob.</span><span class="sxs-lookup"><span data-stu-id="bf93c-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="bf93c-238">Als er al een geldige lease op de blob wanneer u probeert een nieuwe lease te verkrijgen, retourneert de blob-service een resultaat van de status 'Conflict HTTP (409)'.</span><span class="sxs-lookup"><span data-stu-id="bf93c-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="bf93c-239">Het volgende fragment maakt gebruik van een **AccessCondition** -object op voor de leasegegevens inkapselen wanneer een aanvraag voor het bijwerken van de blob in de storage-service op deze manier.</span><span class="sxs-lookup"><span data-stu-id="bf93c-239">The following snippet uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="bf93c-240">U kunt het volledige voorbeeld hier downloaden: [beheren gelijktijdigheid van taken met behulp van Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="bf93c-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="bf93c-241">Als u een schrijfbewerking voor een geleaste blob probeert zonder het doorgeven van de lease-ID, mislukt de aanvraag met een 412 fout.</span><span class="sxs-lookup"><span data-stu-id="bf93c-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="bf93c-242">Houd er rekening mee dat als de lease is verlopen voordat de **UploadText** methode, maar u nog steeds doorgeven van de lease-ID, de aanvraag is ook mislukt met een **412** fout.</span><span class="sxs-lookup"><span data-stu-id="bf93c-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="bf93c-243">Zie voor meer informatie over het beheren van verlopen leaseduur en lease id's, de [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST-documentatie.</span><span class="sxs-lookup"><span data-stu-id="bf93c-243">For more information about managing lease expiry times and lease IDs, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="bf93c-244">De volgende bewerkingen uit blob kunnen leases gebruiken voor het beheren van volledige vergrendeling:</span><span class="sxs-lookup"><span data-stu-id="bf93c-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="bf93c-245">Blob plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-245">Put Blob</span></span>
* <span data-ttu-id="bf93c-246">Ophalen van Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-246">Get Blob</span></span>
* <span data-ttu-id="bf93c-247">Blob-eigenschappen ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-247">Get Blob Properties</span></span>
* <span data-ttu-id="bf93c-248">Blob-eigenschappen instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-248">Set Blob Properties</span></span>
* <span data-ttu-id="bf93c-249">Blobmetagegevens ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-249">Get Blob Metadata</span></span>
* <span data-ttu-id="bf93c-250">Blobmetagegevens instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-250">Set Blob Metadata</span></span>
* <span data-ttu-id="bf93c-251">Verwijderen van Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-251">Delete Blob</span></span>
* <span data-ttu-id="bf93c-252">Blok plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-252">Put Block</span></span>
* <span data-ttu-id="bf93c-253">Lijst met geblokkeerde websites plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-253">Put Block List</span></span>
* <span data-ttu-id="bf93c-254">Lijst met geblokkeerde websites ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-254">Get Block List</span></span>
* <span data-ttu-id="bf93c-255">Pagina plaatsen</span><span class="sxs-lookup"><span data-stu-id="bf93c-255">Put Page</span></span>
* <span data-ttu-id="bf93c-256">Get-paginabereiken</span><span class="sxs-lookup"><span data-stu-id="bf93c-256">Get Page Ranges</span></span>
* <span data-ttu-id="bf93c-257">Momentopname Blob - lease-ID is optioneel als er een lease bestaat</span><span class="sxs-lookup"><span data-stu-id="bf93c-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="bf93c-258">Blob - lease ID is vereist als een lease op de bestemmings-blob bestaat kopiëren</span><span class="sxs-lookup"><span data-stu-id="bf93c-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="bf93c-259">Afbreken kopie Blob - ID van de lease is vereist als er een oneindige lease op de bestemmings-blob bestaat</span><span class="sxs-lookup"><span data-stu-id="bf93c-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="bf93c-260">Lease Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="bf93c-261">Volledige vergrendeling voor containers</span><span class="sxs-lookup"><span data-stu-id="bf93c-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="bf93c-262">Leases voor containers dezelfde strategieën synchronisatie wordt alleen ondersteund als op blobs inschakelen (exclusief voor schrijven / lezen, exclusieve schrijven gedeeld / exclusief lezen en schrijven gedeeld / lezen exclusief) maar in tegenstelling tot de blobs de storage-service alleen wordt afgedwongen exclusiviteit op delete-bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="bf93c-263">Als u wilt verwijderen van een container met een actieve reservering geldt, moet een client de actieve lease-ID en de delete-aanvraag bevatten.</span><span class="sxs-lookup"><span data-stu-id="bf93c-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="bf93c-264">Alle andere container bewerkingen slaagt in een container geleaste met inbegrip van de ID van de lease bewerkingen in dat geval ze worden gedeeld.</span><span class="sxs-lookup"><span data-stu-id="bf93c-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="bf93c-265">Als exclusiviteit van update (put of set) of leesbewerkingen vereist vervolgens moet ontwikkelaars dat alle clients gebruiken een lease-ID en die alleen één client tegelijk een geldige lease-ID. heeft</span><span class="sxs-lookup"><span data-stu-id="bf93c-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="bf93c-266">De volgende container bewerkingen kunnen leases gebruiken voor het beheren van volledige vergrendeling:</span><span class="sxs-lookup"><span data-stu-id="bf93c-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="bf93c-267">Verwijderen van Container</span><span class="sxs-lookup"><span data-stu-id="bf93c-267">Delete Container</span></span>
* <span data-ttu-id="bf93c-268">Eigenschappen van Container ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-268">Get Container Properties</span></span>
* <span data-ttu-id="bf93c-269">Container metagegevens ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-269">Get Container Metadata</span></span>
* <span data-ttu-id="bf93c-270">Metagegevens van de Container instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-270">Set Container Metadata</span></span>
* <span data-ttu-id="bf93c-271">Container-ACL ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-271">Get Container ACL</span></span>
* <span data-ttu-id="bf93c-272">Container-ACL instellen</span><span class="sxs-lookup"><span data-stu-id="bf93c-272">Set Container ACL</span></span>
* <span data-ttu-id="bf93c-273">Lease-Container</span><span class="sxs-lookup"><span data-stu-id="bf93c-273">Lease Container</span></span>  

<span data-ttu-id="bf93c-274">Zie voor meer informatie:</span><span class="sxs-lookup"><span data-stu-id="bf93c-274">For more information, see:</span></span>  

* [<span data-ttu-id="bf93c-275">Voorwaardelijke kop opgeven voor bewerkingen van de Blob-Service</span><span class="sxs-lookup"><span data-stu-id="bf93c-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="bf93c-276">Lease-Container</span><span class="sxs-lookup"><span data-stu-id="bf93c-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="bf93c-277">Lease Blob</span><span class="sxs-lookup"><span data-stu-id="bf93c-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="bf93c-278">Het beheren van gelijktijdigheid van taken in de Tabelservice</span><span class="sxs-lookup"><span data-stu-id="bf93c-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="bf93c-279">De tabelservice gebruikt optimistische gelijktijdigheid controleert als standaardgedrag wanneer u werkt met entiteiten, in tegenstelling tot de blob-service waarbij u expliciet kiezen moet optimistische gelijktijdigheid controles uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="bf93c-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="bf93c-280">De andere verschil tussen de tabel en de blob-services is dat u alleen het gelijktijdigheid gedrag van entiteiten beheren kunt dat met de blob-service kunt u de gelijktijdigheid van zowel containers en blobs beheren.</span><span class="sxs-lookup"><span data-stu-id="bf93c-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="bf93c-281">Moet worden gebruikt optimistische gelijktijdigheid, en om te controleren of een ander proces een entiteit gewijzigd, omdat u deze uit de tabel storage-service opgehaald, kunt u de ETag-waarde die u ontvangt als de tabelservice een entiteit retourneert.</span><span class="sxs-lookup"><span data-stu-id="bf93c-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="bf93c-282">Het overzicht van dit proces is als volgt:</span><span class="sxs-lookup"><span data-stu-id="bf93c-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="bf93c-283">Een entiteit ophalen uit de tabel storage-service, het antwoord bevat een ETag-waarde die aangeeft van de huidige id die is gekoppeld aan deze entiteit in de storage-service.</span><span class="sxs-lookup"><span data-stu-id="bf93c-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="bf93c-284">Wanneer u de entiteit bijwerkt, omvatten de ETag-waarde die u hebt ontvangen in stap 1 van de vereiste **If-Match** koptekst van de aanvraag die u naar de service verzendt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="bf93c-285">De service worden vergeleken met de huidige ETag-waarde van de entiteit de ETag-waarde in de aanvraag.</span><span class="sxs-lookup"><span data-stu-id="bf93c-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="bf93c-286">Als de huidige ETag-waarde van de entiteit anders dan de ETag in het verplichte is **If-Match** -header in de aanvraag kan de service een 412-fout geretourneerd op de client.</span><span class="sxs-lookup"><span data-stu-id="bf93c-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="bf93c-287">Hiermee geeft u aan de client of een ander proces de entiteit is bijgewerkt sinds deze de client opgehaald.</span><span class="sxs-lookup"><span data-stu-id="bf93c-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="bf93c-288">Als de huidige ETag-waarde van de entiteit hetzelfde als de ETag in het verplichte is **If-Match** header in de aanvraag of de **If-Match** header bevat het jokerteken (*), de service de aangevraagde bewerking wordt uitgevoerd en updates van de huidige ETag-waarde van de entiteit om weer te geven dat deze is bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="bf93c-289">Opmerking dat in tegenstelling tot de blob-service de tabelservice vereist dat de client wilt opnemen een **If-Match** header in updateaanvragen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="bf93c-290">Het is echter mogelijk om af te dwingen een onvoorwaardelijke bijwerken (laatste schrijver strategie voor wins) en gelijktijdigheid controles overslaan als de client stelt de **If-Match** header aan het jokerteken (*) in de aanvraag.</span><span class="sxs-lookup"><span data-stu-id="bf93c-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="bf93c-291">De volgende C#-fragment toont klantentiteit die eerder gemaakt of opgehaald met hun e-mailadres dat is bijgewerkt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="bf93c-292">De eerste plaats of bewerking slaat de ETag-waarde in het object van de klant ophalen en omdat het voorbeeld wordt hetzelfde objectexemplaar gebruikt bij het uitvoeren van de vervangingsbewerking, het verzendt automatisch de ETag-waarde terug naar de tabelservice, het inschakelen van de service om te controleren op schendingen van gelijktijdigheid.</span><span class="sxs-lookup"><span data-stu-id="bf93c-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="bf93c-293">Wanneer de entiteit in de table storage is bijgewerkt naar een ander proces, stuurt de service een statusbericht HTTP 412 (voorwaarde is mislukt).</span><span class="sxs-lookup"><span data-stu-id="bf93c-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="bf93c-294">U kunt het volledige voorbeeld hier downloaden: [beheren gelijktijdigheid van taken met behulp van Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="bf93c-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="bf93c-295">Als u wilt de gelijktijdigheidscontrole expliciet uitschakelen, moet u instellen de **ETag** eigenschap van de **werknemer** object naar ' * ' voordat u de vervangingsbewerking uitvoert.</span><span class="sxs-lookup"><span data-stu-id="bf93c-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="bf93c-296">De volgende tabel ziet u hoe de entiteit tabelbewerkingen ETag waarden gebruiken:</span><span class="sxs-lookup"><span data-stu-id="bf93c-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="bf93c-297">Bewerking</span><span class="sxs-lookup"><span data-stu-id="bf93c-297">Operation</span></span> | <span data-ttu-id="bf93c-298">ETag-waarde retourneert</span><span class="sxs-lookup"><span data-stu-id="bf93c-298">Returns ETag value</span></span> | <span data-ttu-id="bf93c-299">Aanvraag-header If-Match vereist</span><span class="sxs-lookup"><span data-stu-id="bf93c-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="bf93c-300">Query-entiteiten</span><span class="sxs-lookup"><span data-stu-id="bf93c-300">Query Entities</span></span> |<span data-ttu-id="bf93c-301">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-301">Yes</span></span> |<span data-ttu-id="bf93c-302">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-302">No</span></span> |
| <span data-ttu-id="bf93c-303">Entiteit invoegen</span><span class="sxs-lookup"><span data-stu-id="bf93c-303">Insert Entity</span></span> |<span data-ttu-id="bf93c-304">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-304">Yes</span></span> |<span data-ttu-id="bf93c-305">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-305">No</span></span> |
| <span data-ttu-id="bf93c-306">Bijwerken van entiteit</span><span class="sxs-lookup"><span data-stu-id="bf93c-306">Update Entity</span></span> |<span data-ttu-id="bf93c-307">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-307">Yes</span></span> |<span data-ttu-id="bf93c-308">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-308">Yes</span></span> |
| <span data-ttu-id="bf93c-309">Samenvoegen van entiteit</span><span class="sxs-lookup"><span data-stu-id="bf93c-309">Merge Entity</span></span> |<span data-ttu-id="bf93c-310">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-310">Yes</span></span> |<span data-ttu-id="bf93c-311">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-311">Yes</span></span> |
| <span data-ttu-id="bf93c-312">Entiteit verwijderen</span><span class="sxs-lookup"><span data-stu-id="bf93c-312">Delete Entity</span></span> |<span data-ttu-id="bf93c-313">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-313">No</span></span> |<span data-ttu-id="bf93c-314">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-314">Yes</span></span> |
| <span data-ttu-id="bf93c-315">Invoegen of vervangen van entiteit</span><span class="sxs-lookup"><span data-stu-id="bf93c-315">Insert or Replace Entity</span></span> |<span data-ttu-id="bf93c-316">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-316">Yes</span></span> |<span data-ttu-id="bf93c-317">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-317">No</span></span> |
| <span data-ttu-id="bf93c-318">Invoegen of samenvoegen van entiteit</span><span class="sxs-lookup"><span data-stu-id="bf93c-318">Insert or Merge Entity</span></span> |<span data-ttu-id="bf93c-319">Ja</span><span class="sxs-lookup"><span data-stu-id="bf93c-319">Yes</span></span> |<span data-ttu-id="bf93c-320">Nee</span><span class="sxs-lookup"><span data-stu-id="bf93c-320">No</span></span> |

<span data-ttu-id="bf93c-321">Houd er rekening mee dat de **invoegen of vervangen entiteit** en **invoegen of samenvoegen entiteit** bewerkingen uitvoeren *niet* gelijktijdigheid controles uitvoeren, omdat ze een ETag-waarde niet aan de tabelservice verzendt.</span><span class="sxs-lookup"><span data-stu-id="bf93c-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="bf93c-322">In het algemeen verstandig ontwikkelaars met tabellen optimistische gelijktijdigheid van taken bij het ontwikkelen van schaalbare toepassingen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="bf93c-323">Als volledige vergrendeling is vereist, kunnen een aanpak ontwikkelaars duren wanneer de toegang tot tabellen wordt Wijs een aangewezen blob voor elke tabel en probeer het een lease op het blob moet uitvoeren voordat het besturingssysteem op de tabel.</span><span class="sxs-lookup"><span data-stu-id="bf93c-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="bf93c-324">Deze benadering is de toepassing om te controleren of alle gegevenspaden toegang verkrijgen van de lease voordat het besturingssysteem op de tabel vereist.</span><span class="sxs-lookup"><span data-stu-id="bf93c-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="bf93c-325">Vergeet niet dat de minimale leasetijd 15 seconden dat moet zorgvuldig gebeuren voor schaalbaarheid is.</span><span class="sxs-lookup"><span data-stu-id="bf93c-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="bf93c-326">Zie voor meer informatie:</span><span class="sxs-lookup"><span data-stu-id="bf93c-326">For more information, see:</span></span>  

* [<span data-ttu-id="bf93c-327">Bewerkingen op entiteiten</span><span class="sxs-lookup"><span data-stu-id="bf93c-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="bf93c-328">Het beheren van gelijktijdigheid van taken in de Queue-Service</span><span class="sxs-lookup"><span data-stu-id="bf93c-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="bf93c-329">Een scenario die in welke gelijktijdigheid van taken een probleem in de wachtrij-service is is waar meerdere clients zijn bij het ophalen van berichten uit een wachtrij.</span><span class="sxs-lookup"><span data-stu-id="bf93c-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="bf93c-330">Wanneer een bericht wordt opgehaald uit de wachtrij, wordt het antwoord bevat het bericht en een ontvangstwaarde pop, dit is vereist voor het verwijderen van het bericht.</span><span class="sxs-lookup"><span data-stu-id="bf93c-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="bf93c-331">Het bericht wordt niet automatisch verwijderd uit de wachtrij, maar nadat zijn opgehaald, het is niet zichtbaar voor andere clients voor de tijdsinterval die is opgegeven door de parameter visibilitytimeout.</span><span class="sxs-lookup"><span data-stu-id="bf93c-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="bf93c-332">De client die het bericht haalt wordt het bericht wilt verwijderen nadat deze is verwerkt en vóór de tijd die is opgegeven door de TimeNextVisible element van het antwoord, die wordt berekend op basis van de waarde van de parameter visibilitytimeout verwacht.</span><span class="sxs-lookup"><span data-stu-id="bf93c-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="bf93c-333">De waarde van visibilitytimeout is toegevoegd aan de tijd waarop het bericht om te bepalen van de waarde van TimeNextVisible wordt opgehaald.</span><span class="sxs-lookup"><span data-stu-id="bf93c-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="bf93c-334">De queue-service heeft geen ondersteuning voor volledige noch optimistische gelijktijdigheid, en voor deze berichten worden verwerkt op een manier idempotent van reden clients verwerken van berichten die zijn opgehaald uit een wachtrij moet.</span><span class="sxs-lookup"><span data-stu-id="bf93c-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="bf93c-335">Een strategie voor wins van laatste schrijver wordt gebruikt voor de update-bewerkingen zoals SetQueueServiceProperties, SetQueueMetaData, SetQueueACL en UpdateMessage.</span><span class="sxs-lookup"><span data-stu-id="bf93c-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="bf93c-336">Zie voor meer informatie:</span><span class="sxs-lookup"><span data-stu-id="bf93c-336">For more information, see:</span></span>  

* [<span data-ttu-id="bf93c-337">REST-API van wachtrij</span><span class="sxs-lookup"><span data-stu-id="bf93c-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="bf93c-338">Berichten ophalen</span><span class="sxs-lookup"><span data-stu-id="bf93c-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="bf93c-339">Het beheren van gelijktijdigheid van taken in de File-Service</span><span class="sxs-lookup"><span data-stu-id="bf93c-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="bf93c-340">De file-service zijn toegankelijk via twee verschillende protocoleindpunten – SMB en REST.</span><span class="sxs-lookup"><span data-stu-id="bf93c-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="bf93c-341">De REST-service biedt geen ondersteuning voor beperkte vergrendeling of volledige vergrendeling en alle updates moeten een strategie voor wins van laatste schrijver volgen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="bf93c-342">Bestand systeem vergrendelen mechanismen voor het beheren van toegang tot gedeelde bestanden, inclusief de mogelijkheid om uit te voeren volledige vergrendeling kunnen gebruikmaken van SMB-clients die bestandsshares koppelen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="bf93c-343">Wanneer een SMB-client een bestand opent, wordt Hiermee wordt de toegang tot het bestand en de share modus.</span><span class="sxs-lookup"><span data-stu-id="bf93c-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="bf93c-344">Een optie voor toegang tot het bestand 'Schrijven' of ' Lezen/schrijven' samen met een bestandsshare-modus, 'None' leidt tot het bestand wordt vergrendeld door een SMB-client tot het bestand wordt gesloten.</span><span class="sxs-lookup"><span data-stu-id="bf93c-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="bf93c-345">Als REST-bewerking wordt uitgevoerd voor een bestand waarin een SMB-client het bestand vergrendeld heeft wordt in de REST-service statuscode 409 (Conflict) met foutcode SharingViolation geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="bf93c-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="bf93c-346">Wanneer een bestand om te verwijderen van een SMB-client wordt geopend, wordt het bestand gemarkeerd als in behandeling verwijderen tot de SMB-client open ingangen in dat bestand gesloten.</span><span class="sxs-lookup"><span data-stu-id="bf93c-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="bf93c-347">Wanneer een bestand is gemarkeerd als in behandeling verwijderen, wordt een REST-bewerking op dat bestand statuscode 409 (Conflict) met foutcode SMBDeletePending geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="bf93c-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="bf93c-348">Statuscode 404 (niet gevonden) wordt niet geretourneerd omdat het is mogelijk dat de SMB-client om de vlag in afwachting van verwijdering vóór het sluiten van het bestand te verwijderen.</span><span class="sxs-lookup"><span data-stu-id="bf93c-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="bf93c-349">Met andere woorden, worden statuscode 404 (niet gevonden) alleen verwacht wanneer het bestand is verwijderd.</span><span class="sxs-lookup"><span data-stu-id="bf93c-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="bf93c-350">Houd er rekening mee dat wanneer een bestand in een SMB verwijderen status in behandeling is, deze niet in de lijst met bestanden resultaten opgenomen worden.</span><span class="sxs-lookup"><span data-stu-id="bf93c-350">Note that while a file is in an SMB pending delete state, it will not be included in the List Files results.</span></span> <span data-ttu-id="bf93c-351">Merk ook op dat de REST-bestand verwijderen en REST verwijderen Directory bewerkingen moment toegepast zijn en niet in een status in afwachting van verwijdering resulteren.</span><span class="sxs-lookup"><span data-stu-id="bf93c-351">Also, note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in a pending delete state.</span></span>  

<span data-ttu-id="bf93c-352">Zie voor meer informatie:</span><span class="sxs-lookup"><span data-stu-id="bf93c-352">For more information, see:</span></span>  

* [<span data-ttu-id="bf93c-353">Hiermee vergrendelt u het beheer van bestand</span><span class="sxs-lookup"><span data-stu-id="bf93c-353">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="bf93c-354">Samenvatting en de volgende stappen</span><span class="sxs-lookup"><span data-stu-id="bf93c-354">Summary and Next Steps</span></span>
<span data-ttu-id="bf93c-355">De Microsoft Azure Storage-service is ontworpen om te voldoen aan de behoeften van de meest complexe on line toepassingen zonder ontwikkelaars aangetast of denken over belangrijke ontwerp veronderstellingen zoals consistentie gelijktijdigheid van taken en gegevens die ze afkomstig zijn moet worden ondernomen bij verleend.</span><span class="sxs-lookup"><span data-stu-id="bf93c-355">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="bf93c-356">Voor de volledige voorbeeldtoepassing waarnaar wordt verwezen in deze blog:</span><span class="sxs-lookup"><span data-stu-id="bf93c-356">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="bf93c-357">Gelijktijdigheid van taken met behulp van Azure Storage - voorbeeldtoepassing beheren</span><span class="sxs-lookup"><span data-stu-id="bf93c-357">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="bf93c-358">Voor meer informatie over Azure Storage-Zie:</span><span class="sxs-lookup"><span data-stu-id="bf93c-358">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="bf93c-359">Startpagina van Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="bf93c-359">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="bf93c-360">Inleiding tot Azure Storage</span><span class="sxs-lookup"><span data-stu-id="bf93c-360">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="bf93c-361">Opslag aan de slag voor [Blob](../blobs/storage-dotnet-how-to-use-blobs.md), [tabel](../../cosmos-db/table-storage-how-to-use-dotnet.md), [wachtrijen](../storage-dotnet-how-to-use-queues.md), en [bestanden](../storage-dotnet-how-to-use-files.md)</span><span class="sxs-lookup"><span data-stu-id="bf93c-361">Storage Getting Started for [Blob](../blobs/storage-dotnet-how-to-use-blobs.md), [Table](../../cosmos-db/table-storage-how-to-use-dotnet.md),  [Queues](../storage-dotnet-how-to-use-queues.md), and [Files](../storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="bf93c-362">Opslagarchitectuur – [Azure Storage: een maximaal beschikbare Cloudopslagservice met sterke consistentie](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="bf93c-362">Storage Architecture – [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

