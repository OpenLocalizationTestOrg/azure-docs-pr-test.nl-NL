---
title: aaaService Fabric betrouwbare actoren overzicht | Microsoft Docs
description: Inleiding toohello Service Fabric model voor Reliable Actors.
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="2d2b6-103">Inleiding tooService Fabric Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="2d2b6-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="2d2b6-104">Reliable Actors is een Service Fabric-toepassingsframework op basis van Hallo [virtuele Actor](http://research.microsoft.com/en-us/projects/orleans/) patroon.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="2d2b6-105">Hallo betrouwbare actoren API biedt een single thread-programmeermodel die gebouwd op Hallo schaalbaarheid en betrouwbaarheid garanties geleverd door de Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="2d2b6-106">Wat zijn Actors?</span><span class="sxs-lookup"><span data-stu-id="2d2b6-106">What are Actors?</span></span>
<span data-ttu-id="2d2b6-107">Een actor is een eenheid geïsoleerd, onafhankelijk van de berekenings- en staat met één thread worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="2d2b6-108">Hallo [actor patroon](https://en.wikipedia.org/wiki/Actor_model) is een rekenkundige model gelijktijdige of gedistribueerde systemen in die een groot aantal deze actoren kunt tegelijkertijd uitvoeren en onafhankelijk van elkaar.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="2d2b6-109">Actoren kunnen communiceren met elkaar en meer actoren te maken.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="2d2b6-110">Wanneer toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="2d2b6-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="2d2b6-111">Service Fabric Reliable Actors is een implementatie van Hallo actor ontwerppatroon.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="2d2b6-112">Net als bij een ontwerppatroon software past Hallo besluit of toouse een specifiek patroon wordt gemaakt op basis van het al dan niet de probleem voor het ontwerpen van een software Hallo-patroon.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="2d2b6-113">Hoewel Hallo actor ontwerppatroon een goede aanpassen tooa aantal gedistribueerde systemen problemen en scenario's, zorgvuldige overweging van Hallo beperkingen van Hallo patroon en implementeren van Hallo-framework die moet worden gemaakt is.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="2d2b6-114">Algemene richtlijnen, moet u overwegen Hallo actor patroon toomodel uw probleem of scenario als:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="2d2b6-115">De ruimte van uw probleem betrekking heeft op een groot aantal (duizendtallen of meer) van kleine, onafhankelijke en geïsoleerde eenheden van de status en logica.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="2d2b6-116">U toowork met één thread-objecten die geen aanzienlijke interactie met externe onderdelen, waaronder status opvragen van een set die vereist is.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="2d2b6-117">Uw actor-exemplaren niet aanroepfuncties met onvoorspelbare vertragingen worden geblokkeerd door uitgifte van i/o-bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="2d2b6-118">Actoren in Service Fabric</span><span class="sxs-lookup"><span data-stu-id="2d2b6-118">Actors in Service Fabric</span></span>
<span data-ttu-id="2d2b6-119">In Service Fabric actoren zijn geïmplementeerd in Hallo Reliable Actors framework: een toepassing op basis van actor-patroon framework gebouwd boven [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="2d2b6-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="2d2b6-120">Elke betrouwbare Actor-service die u schrijft is daadwerkelijk een gepartitioneerde, stateful betrouwbare Service.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="2d2b6-121">Elke actor is gedefinieerd als een exemplaar van een actortype, identieke toohello manier .NET-object is een exemplaar van een .NET-type.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="2d2b6-122">Bijvoorbeeld, kan er een actortype dat Hallo-functionaliteit van een rekenmachine implementeert en er zijn veel actoren van dat type die worden gedistribueerd op verschillende knooppunten in een cluster.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="2d2b6-123">Elke dergelijke actor wordt uniek geïdentificeerd door een actor-ID.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="2d2b6-124">Actor-levensduur</span><span class="sxs-lookup"><span data-stu-id="2d2b6-124">Actor Lifetime</span></span>
<span data-ttu-id="2d2b6-125">Service Fabric actoren zijn virtueel, wat betekent dat hun levensduur is niet gebonden tootheir in het geheugen weergave.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="2d2b6-126">Hierdoor kunnen hoeven ze niet toobe expliciet gemaakt of vernietigd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="2d2b6-127">Hallo Reliable Actors runtime activeert automatisch een Hallo actor eerst die een aanvraag voor die actor-ID ontvangt.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="2d2b6-128">Als een actor niet voor een bepaalde periode gebruikt wordt, Hallo Reliable Actors runtime garbagecollection-verzamelt Hallo in het geheugen-object.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="2d2b6-129">Ook blijven kennis van de Hallo actor bestaan mocht toobe geactiveerd later nodig.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="2d2b6-130">Zie voor meer informatie [Actor lifecycle en garbage collection](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="2d2b6-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="2d2b6-131">Deze virtuele actor levensduur abstractie voert enkele waarschuwingen als gevolg van Hallo virtuele actor model en in feite Hallo Reliable Actors uitvoering op tijdstippen afwijkt van dit model.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="2d2b6-132">Een actor wordt automatisch geactiveerd (waardoor een actor object toobe samengesteld) Hallo eerst een bericht verzonden tooits actor-ID.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="2d2b6-133">Hallo actor-object is na een bepaalde tijd, garbage collector zijn verzameld.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="2d2b6-134">In Hallo toekomst Hallo actor-ID opnieuw gebruiken, wordt een nieuwe actor object toobe samengesteld.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="2d2b6-135">Status van een actor outlives levensduur van het Hallo-object als opgeslagen in Hallo status manager.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="2d2b6-136">Een actormethode aanroepen voor een actor-ID activeert die actor.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="2d2b6-137">Om deze reden hebben acteur types hun constructor impliciet door Hallo runtime worden aangeroepen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="2d2b6-138">Daarom clientcode die parameters toohello actor constructor van het type, niet doorgeven, hoewel parameters mag van toohello actor-constructor worden doorgegeven door Hallo-service zelf.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="2d2b6-139">Hallo-resultaat is dat actoren kunnen worden geconstrueerd in een status gedeeltelijk geïnitialiseerd door Hallo tijd die andere methoden worden genoemd, als Hallo actor initialisatieparameters van Hallo-client vereist.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="2d2b6-140">Er is geen één toegangspunt voor de Hallo activering van een actor van Hallo-client.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="2d2b6-141">Hoewel Reliable Actors impliciet actor-objecten maken. u hebt Hallo mogelijkheid tooexplicitly een actor en de status verwijderd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="2d2b6-142">Distributie en failover</span><span class="sxs-lookup"><span data-stu-id="2d2b6-142">Distribution and failover</span></span>
<span data-ttu-id="2d2b6-143">tooprovide schaalbaarheid en betrouwbaarheid, Service Fabric actoren in Hallo-cluster en automatisch distribueert ze migreert van knooppunten toohealthy waarden zoals vereist.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="2d2b6-144">Dit is een abstractie via een [betrouwbare gepartitioneerde stateful Service](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="2d2b6-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="2d2b6-145">Distributie, schaalbaarheid, betrouwbaarheid en automatische failover zijn alle opgegeven grond Hallo feit die actoren worden uitgevoerd binnen een stateful betrouwbare Service met de naam van Hallo *Actor Service*.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="2d2b6-146">Actors zijn verdeeld over Hallo partities Hallo Actor-Service en deze partities zijn verdeeld over Hallo knooppunten in een Service Fabric-cluster.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="2d2b6-147">Elke partitie service bevat een set van actoren.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="2d2b6-148">Service Fabric beheert distributie en failover van Hallo-partities.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="2d2b6-149">Bijvoorbeeld, een actor-service met negen partities geïmplementeerd toothree knooppunten Hallo standaard actor partitie plaatsing gebruikt thusly zou worden gedistribueerd:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Betrouwbare actoren distributie][2]

<span data-ttu-id="2d2b6-151">Hallo Actor Framework beheert partitie schema en de sleutel bereik-instellingen voor u.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="2d2b6-152">Dit vereenvoudigt enkele mogelijkheden, maar ook een nadelige invloed sommige overweging:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="2d2b6-153">Reliable Services kunt u toochoose een partitieschema sleutel bereik (als u een bereik partitieschema) en partitie count.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="2d2b6-154">Reliable Actors beperkte toohello bereik partitieschema (Hallo uniform Int64 schema) is en u Hallo volledige Int64 sleutel bereik vereist.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="2d2b6-155">Standaard worden actoren willekeurig in partities, wat resulteert in een gelijkmatige verdeling geplaatst.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="2d2b6-156">Omdat actoren willekeurig worden geplaatst, moet worden verwacht dat actor-bewerkingen altijd netwerkcommunicatie moet, met inbegrip van serialisatie en deserialisatie van methode-aanroepgegevens, latentie en overhead aangaan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="2d2b6-157">In geavanceerde scenario's is het mogelijk toocontrol actor partitie plaatsing via Int64 actor-id's die toospecific partities worden toegewezen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="2d2b6-158">Echter, doen dus kan resulteren in een distributie onbalans van actoren meerdere partities.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="2d2b6-159">Voor meer informatie over hoe actorservices worden gepartitioneerd, Raadpleeg te[partitioneren concepten voor actoren](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="2d2b6-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="2d2b6-160">Actor-communicatie</span><span class="sxs-lookup"><span data-stu-id="2d2b6-160">Actor communication</span></span>
<span data-ttu-id="2d2b6-161">Actor-interacties worden gedefinieerd in een interface die wordt gedeeld door Hallo actor die Hallo-interface implementeert en Hallo-client die een proxy opgehaald tooan actor via Hallo dezelfde interface.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="2d2b6-162">Omdat deze interface asynchroon gebruikte tooinvoke actor-methoden is, moet u elke methode op Hallo-interface moet geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="2d2b6-163">Methode-aanroepen en hun antwoorden uiteindelijk resulteren in netwerkaanvragen via Hallo-cluster, geval Hallo argumenten en resultaattypen Hallo Hallo taken dat ze retourneren serializable door Hallo-platform moet.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="2d2b6-164">In het bijzonder, moeten ze [gegevenscontract serialiseerbaar](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="2d2b6-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="2d2b6-165">Hallo actor-proxy</span><span class="sxs-lookup"><span data-stu-id="2d2b6-165">hello actor proxy</span></span>
<span data-ttu-id="2d2b6-166">Hallo Reliable Actors client API biedt communicatie tussen een actor-exemplaar en een actor-client.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="2d2b6-167">toocommunicate met een actor een client maakt een actor proxy-object dat Hallo actor-interface implementeert.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="2d2b6-168">Hallo-client communiceert met de Hallo actor door aanroepen methoden op Hallo proxy-object.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="2d2b6-169">Hallo actor proxy kan worden gebruikt voor client-naar-actor en actor-actor-communicatie.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="2d2b6-170">Hallo twee soorten informatie gebruikt toocreate Hallo actor proxyobject zijn Hallo actor-ID en de naam van de toepassing hello.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="2d2b6-171">Hallo actor-ID is uniek voor Hallo acteur, terwijl de naam van de toepassing hello Hallo identificeert [Service Fabric-toepassing](service-fabric-reliable-actors-platform.md#application-model) waarop Hallo actor wordt geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="2d2b6-172">Hallo `ActorProxy`(C#) / `ActorProxyBase`klasse (Java) aan clientzijde Hallo voert Hallo nodig resolutie toolocate Hallo actor door-ID en een communicatiekanaal met het openen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="2d2b6-173">Het toolocate Hallo actor in geval van Hallo van communicatiefouten en failovers ook opnieuw probeert.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="2d2b6-174">Als gevolg hiervan heeft levering van berichten Hallo volgende kenmerken:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="2d2b6-175">Levering van berichten is zo goed mogelijke poging.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="2d2b6-176">Actoren mogelijk dubbele berichten van Hallo dezelfde client.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="2d2b6-177">Gelijktijdigheid</span><span class="sxs-lookup"><span data-stu-id="2d2b6-177">Concurrency</span></span>
<span data-ttu-id="2d2b6-178">Hallo Reliable Actors runtime biedt een eenvoudige inschakelen op basis van een toegangsmodel voor toegang tot actor-methoden.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="2d2b6-179">Dit betekent dat niet meer dan één thread actief binnen een actor-object-code op elk gewenst moment zijn kan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="2d2b6-180">Schakel gebaseerde toegang vereenvoudigt gelijktijdige systemen als er geen synchronisatiemechanismen voor toegang tot gegevens nodig is.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="2d2b6-181">Het betekent ook systemen moeten worden ontworpen met speciale overwegingen voor Hallo single thread toegang aard van elk actor-exemplaar.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="2d2b6-182">Een enkele actor-exemplaar kan niet meer dan één verzoek tegelijkertijd wordt verwerkt.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="2d2b6-183">Een actor-exemplaar kan een knelpunt doorvoer veroorzaken als het verwachte toohandle gelijktijdige aanvragen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="2d2b6-184">Actoren kunnen impasse op elkaar, als er een circulaire verzoek tussen twee actors tijdens een externe aanvraag wordt gedaan tooone van Hallo actoren tegelijkertijd.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="2d2b6-185">Hallo actor runtime wordt automatisch de tijd op actor aangeroepen en genereert een uitzondering toohello aanroeper toointerrupt impasse situaties.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Betrouwbare actoren communicatie][3]

#### <a name="turn-based-access"></a><span data-ttu-id="2d2b6-187">Schakel gebaseerde toegang</span><span class="sxs-lookup"><span data-stu-id="2d2b6-187">Turn-based access</span></span>
<span data-ttu-id="2d2b6-188">Een Schakel bestaat uit Hallo uitvoeren van een actormethode in antwoord tooa aanvraag uit andere actoren of clients of Hallo uitvoeren van een [timer/herinnering](service-fabric-reliable-actors-timers-reminders.md) retouraanroep.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="2d2b6-189">Hoewel deze methoden en retouraanroepen asynchrone,-Hallo actoren runtime ze komt niet interleave.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="2d2b6-190">Een Schakel moet volledig is voltooid voordat een nieuwe Schakel is toegestaan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="2d2b6-191">Met andere woorden, een actor-methode of timer/herinnering callback die momenteel wordt uitgevoerd moet volledig is voltooid voordat u een nieuwe aanroep tooa methode of retouraanroep is toegestaan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="2d2b6-192">Een methode of de retouraanroep wordt beschouwd als toohave is beëindigd als Hallo uitvoering heeft geretourneerd van Hallo-methode of retouraanroep en Hallo taak geretourneerd door het Hallo-methode of retouraanroep is voltooid.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="2d2b6-193">Wordt het bewerken van benadrukken dat die op basis van Schakel gelijktijdigheid zelfs in verschillende methoden en timers retouraanroepen is voldaan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="2d2b6-194">Hallo actoren runtime op basis van Schakel gelijktijdigheid door ophalen van een afzonderlijke actorvergrendeling aan begin van een beurt Hallo afgedwongen en Hallo vergrendeling achter Hallo Hallo inschakelen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="2d2b6-195">Schakel gebaseerde gelijktijdigheid van taken wordt dus afgedwongen op basis van per actor en niet via actoren.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="2d2b6-196">Actor-methoden en timer/herinnering retouraanroepen kunnen tegelijkertijd uitvoeren namens actoren.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="2d2b6-197">Hallo volgende voorbeeld illustreert Hallo hierboven concepten.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="2d2b6-198">Houd rekening met een actortype waarmee twee asynchrone methoden (bijvoorbeeld *Method1* en *Method2*), een timer en een herinnering.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="2d2b6-199">Hallo diagram hieronder toont een voorbeeld van een tijdlijn voor Hallo uitvoering van deze methoden en retouraanroepen namens twee actoren (*ActorId1* en *ActorId2*) die deel uitmaken van toothis actor-type.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Betrouwbare actoren runtime op basis van Schakel gelijktijdigheid van taken en -toegang][1]

<span data-ttu-id="2d2b6-201">Dit diagram volgt deze conventies:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="2d2b6-202">Elke verticale lijn bevat Hallo logische stroom van de uitvoering van een methode of een retouraanroep namens een bepaalde actor.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="2d2b6-203">Hallo gemarkeerd op elke verticale lijn gebeurtenissen in chronologische volgorde met nieuwere gebeurtenissen hieronder oudere.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="2d2b6-204">Verschillende kleuren worden gebruikt voor het bijbehorende toodifferent actoren tijdlijnen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="2d2b6-205">Markering is gebruikte tooindicate Hallo duur voor welke Hallo afzonderlijke actorvergrendeling wordt vastgehouden namens een methode of een retouraanroep.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="2d2b6-206">Sommige tooconsider belangrijke punten:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="2d2b6-207">Terwijl *Method1* wordt uitgevoerd namens *ActorId2* in antwoord tooclient aanvraag *xyz789*, een andere clientaanvraag (*abc123*) binnenkomt die vereist ook *Method1* toobe uitgevoerd door *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="2d2b6-208">Tweede uitvoering van echter Hallo *Method1* begint niet tot Hallo eerdere uitvoering is voltooid.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="2d2b6-209">Op deze manier is geregistreerd door een herinnering *ActorId2* wordt geactiveerd tijdens *Method1* wordt uitgevoerd in reactie tooclient aanvraag *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="2d2b6-210">Hallo wordt herinnering retouraanroep uitgevoerd alleen na beide uitvoeringen van *Method1* zijn voltooid.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="2d2b6-211">Dit alles is vanwege tooturn gebaseerde gelijktijdigheid van taken wordt afgedwongen voor *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="2d2b6-212">Op deze manier ook inschakelen op basis van een gelijktijdigheid van taken wordt afgedwongen voor *ActorId1*, zoals wordt weergegeven door de uitvoering van Hallo *Method1*, *Method2*, en Hallo timer-retouraanroep namens *ActorId1* gebeurt er in een seriële wijze.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="2d2b6-213">De uitvoering van *Method1* namens *ActorId1* overlapt met de uitvoering ervan namens *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="2d2b6-214">Dit is omdat op basis van Schakel gelijktijdigheid alleen binnen een actor en niet tussen actoren wordt afgedwongen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="2d2b6-215">In sommige Hallo methode/callback uitvoeringen Hallo `Task`(C#) / `CompletableFuture`(Java) geretourneerd door Hallo methode/retouraanroep is voltooid nadat het Hallo-methode retourneert.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="2d2b6-216">In sommige andere is Hallo asynchrone bewerking al voltooid door Hallo tijd Hallo methode/callback retourneert.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="2d2b6-217">In beide gevallen worden Hallo afzonderlijke actorvergrendeling wordt vrijgegeven nadat beide Hallo methode/callback retourneert en Hallo asynchrone bewerking is voltooid.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="2d2b6-218">Herintreding</span><span class="sxs-lookup"><span data-stu-id="2d2b6-218">Reentrancy</span></span>
<span data-ttu-id="2d2b6-219">Hallo actoren runtime kunt herintreding standaard.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="2d2b6-220">Dit betekent dat wanneer een actormethode van *Actor A* een methode wordt aangeroepen op *Actor B*, die op zijn beurt een andere methode aanroepen op *Actor A*, dat methode toorun is toegestaan.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="2d2b6-221">Dit is omdat deze deel uitmaakt van Hallo dezelfde logische aanroep-keten context.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="2d2b6-222">Alle timer en herinnering aanroepen beginnen met de nieuwe logische aanroepcontext Hallo.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="2d2b6-223">Zie Hallo [Reliable Actors herintreding](service-fabric-reliable-actors-reentrancy.md) voor meer informatie.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="2d2b6-224">Bereik van garanties gelijktijdigheid van taken</span><span class="sxs-lookup"><span data-stu-id="2d2b6-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="2d2b6-225">Hallo actoren runtime biedt deze garanties gelijktijdigheid van taken in situaties waar het Hallo-aanroep van deze methoden bepaalt.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="2d2b6-226">Bijvoorbeeld, biedt deze garanties voor Hallo methode aanroepen die worden uitgevoerd in reactie tooa clientaanvraag en voor de timer- en herinnering retouraanroepen.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="2d2b6-227">Echter als Hallo actor code rechtstreeks deze methoden buiten Hallo-mechanismen die zijn opgegeven door Hallo actoren runtime roept, kan niet Hallo runtime geeft garanties gelijktijdigheid van taken.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="2d2b6-228">Bijvoorbeeld, als Hallo-methode wordt aangeroepen in de context van een taak die is niet gekoppeld aan het Hallo-taak die wordt geretourneerd door Hallo actor methoden hello, vervolgens Hallo runtime kan niet gelijktijdigheid garanties bieden.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="2d2b6-229">Als het Hallo-methode is aangeroepen vanuit een thread die actor Hallo maakt op een eigen Hallo runtime ook kan niet en geef vervolgens garanties gelijktijdigheid van taken.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="2d2b6-230">Daarom tooperform bewerkingen op de achtergrond, actoren moeten gebruiken [actor timers en actor herinneringen](service-fabric-reliable-actors-timers-reminders.md) die op basis van Schakel gelijktijdigheid respecteren.</span><span class="sxs-lookup"><span data-stu-id="2d2b6-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="2d2b6-231">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="2d2b6-231">Next steps</span></span>
* <span data-ttu-id="2d2b6-232">Aan de slag met het bouwen van uw eerste Reliable Actors-service:</span><span class="sxs-lookup"><span data-stu-id="2d2b6-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="2d2b6-233">Aan de slag met Reliable Actors op .NET</span><span class="sxs-lookup"><span data-stu-id="2d2b6-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="2d2b6-234">Aan de slag met Reliable Actors op Java</span><span class="sxs-lookup"><span data-stu-id="2d2b6-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
