---
title: Azure Data Lake Store Storm prestaties afstemmen richtlijnen | Microsoft Docs
description: Azure Data Lake Store Storm prestaties afstemmen richtlijnen
services: data-lake-store
documentationcenter: 
author: stewu
manager: amitkul
editor: stewu
ms.assetid: ebde7b9f-2e51-4d43-b7ab-566417221335
ms.service: data-lake-store
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/19/2016
ms.author: stewu
ms.openlocfilehash: 1dfa93643f45a96ded3fd022aa8b1c71d487acb4
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 07/11/2017
---
# <a name="performance-tuning-guidance-for-storm-on-hdinsight-and-azure-data-lake-store"></a><span data-ttu-id="0c0c1-103">Prestaties afstemmen richtlijnen voor Storm op HDInsight en Azure Data Lake Store</span><span class="sxs-lookup"><span data-stu-id="0c0c1-103">Performance tuning guidance for Storm on HDInsight and Azure Data Lake Store</span></span>

<span data-ttu-id="0c0c1-104">Begrijpen factoren die u overwegen moeten bij het afstemmen van de prestaties van een Azure-Storm-topologie.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-104">Understand the factors that should be considered when you tune the performance of an Azure Storm topology.</span></span> <span data-ttu-id="0c0c1-105">Bijvoorbeeld, is het belangrijk om te begrijpen van de kenmerken van het werk dat door de spouts en de bolts (of het werk is voor i/o- of geheugenintensief).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-105">For example, it's important to understand the characteristics of the work done by the spouts and the bolts (whether the work is I/O or memory intensive).</span></span> <span data-ttu-id="0c0c1-106">In dit artikel bevat informatie over een reeks prestaties afstemmen richtlijnen over het oplossen van veelvoorkomende problemen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-106">This article covers a range of performance tuning guidelines, including troubleshooting common issues.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="0c0c1-107">Vereisten</span><span class="sxs-lookup"><span data-stu-id="0c0c1-107">Prerequisites</span></span>

* <span data-ttu-id="0c0c1-108">**Een Azure-abonnement**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-108">**An Azure subscription**.</span></span> <span data-ttu-id="0c0c1-109">Zie [Gratis proefversie van Azure ophalen](https://azure.microsoft.com/pricing/free-trial/).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-109">See [Get Azure free trial](https://azure.microsoft.com/pricing/free-trial/).</span></span>
* <span data-ttu-id="0c0c1-110">**Een Azure Data Lake Store-account**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-110">**An Azure Data Lake Store account**.</span></span> <span data-ttu-id="0c0c1-111">Zie voor instructies over het maken van een [aan de slag met Azure Data Lake Store](data-lake-store-get-started-portal.md).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-111">For instructions on how to create one, see [Get started with Azure Data Lake Store](data-lake-store-get-started-portal.md).</span></span>
* <span data-ttu-id="0c0c1-112">**Een Azure HDInsight-cluster** met toegang tot een Data Lake Store-account.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-112">**An Azure HDInsight cluster** with access to a Data Lake Store account.</span></span> <span data-ttu-id="0c0c1-113">Zie [een HDInsight-cluster maken met Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-113">See [Create an HDInsight cluster with Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span></span> <span data-ttu-id="0c0c1-114">Zorg ervoor dat u extern bureaublad inschakelen voor het cluster.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-114">Make sure you enable Remote Desktop for the cluster.</span></span>
* <span data-ttu-id="0c0c1-115">**Een Storm-cluster op Data Lake Store met**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-115">**Running a Storm cluster on Data Lake Store**.</span></span> <span data-ttu-id="0c0c1-116">Zie voor meer informatie [Storm op HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-116">For more information, see [Storm on HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span></span>
* <span data-ttu-id="0c0c1-117">**Prestaties afstemmen richtlijnen voor het Data Lake Store**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-117">**Performance tuning guidelines on Data Lake Store**.</span></span>  <span data-ttu-id="0c0c1-118">Raadpleeg voor algemene prestaties concepten, [Data Lake Store prestaties afstemmen richtlijnen](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-118">For general performance concepts, see [Data Lake Store Performance Tuning Guidance](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span></span>  

## <a name="tune-the-parallelism-of-the-topology"></a><span data-ttu-id="0c0c1-119">De parallelle uitvoering van de topologie afstemmen</span><span class="sxs-lookup"><span data-stu-id="0c0c1-119">Tune the parallelism of the topology</span></span>

<span data-ttu-id="0c0c1-120">U kunt mogelijk de prestaties verbeteren door het verhogen van de gelijktijdigheid van de i/o en naar Data Lake Store.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-120">You might be able to improve performance by increasing the concurrency of the I/O to and from Data Lake Store.</span></span> <span data-ttu-id="0c0c1-121">Een Storm-topologie bevat een set van configuraties om te bepalen van de parallelle uitvoering:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-121">A Storm topology has a set of configurations that determine the parallelism:</span></span>
* <span data-ttu-id="0c0c1-122">Het aantal werkprocessen (de werknemers worden evenredig verdeeld over de virtuele machines).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-122">Number of worker processes (the workers are evenly distributed across the VMs).</span></span>
* <span data-ttu-id="0c0c1-123">Aantal spout executor exemplaren.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-123">Number of spout executor instances.</span></span>
* <span data-ttu-id="0c0c1-124">Aantal bolt executor exemplaren.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-124">Number of bolt executor instances.</span></span>
* <span data-ttu-id="0c0c1-125">Aantal spout taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-125">Number of spout tasks.</span></span>
* <span data-ttu-id="0c0c1-126">Het aantal taken dat bolt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-126">Number of bolt tasks.</span></span>

<span data-ttu-id="0c0c1-127">Overweeg het volgende op een cluster met 4 VM's en 4 werkprocessen, 32 spout Executor en 32 spout-taken en 256 bolt Executor en 512 bolt taken:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-127">For example, on a cluster with 4 VMs and 4 worker processes, 32 spout executors and 32 spout tasks, and 256 bolt executors and 512 bolt tasks, consider the following:</span></span>

<span data-ttu-id="0c0c1-128">Elke supervisor, dat een werkrolknooppunt is, heeft één werknemer proces van de virtuele machine (JVM) Java.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-128">Each supervisor, which is a worker node, has a single worker Java virtual machine (JVM) process.</span></span> <span data-ttu-id="0c0c1-129">Dit proces JVM beheert 4 spout threads en 64 bolt threads.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-129">This JVM process manages 4 spout threads and 64 bolt threads.</span></span> <span data-ttu-id="0c0c1-130">Binnen elke thread worden taken worden opeenvolgend uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-130">Within each thread, tasks are run sequentially.</span></span> <span data-ttu-id="0c0c1-131">Elke thread spout heeft 1 taak met de bovenstaande configuratie, en elke thread bolt heeft 2 taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-131">With the preceding configuration, each spout thread has 1 task, and each bolt thread has 2 tasks.</span></span>

<span data-ttu-id="0c0c1-132">Hier worden de verschillende onderdelen die zijn betrokken in Storm, en hoe ze invloed hebben op het niveau van parallelle uitvoering die u hebt:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-132">In Storm, here are the various components involved, and how they affect the level of parallelism you have:</span></span>
* <span data-ttu-id="0c0c1-133">Het hoofdknooppunt (Nimbus in Storm genoemd) wordt gebruikt voor het verzenden en beheren van taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-133">The head node (called Nimbus in Storm) is used to submit and manage jobs.</span></span> <span data-ttu-id="0c0c1-134">Deze knooppunten hebben geen invloed op de mate van parallelle uitvoering.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-134">These nodes have no impact on the degree of parallelism.</span></span>
* <span data-ttu-id="0c0c1-135">De leidinggevende-knooppunten.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-135">The supervisor nodes.</span></span> <span data-ttu-id="0c0c1-136">In HDInsight, dit komt overeen met een werkrolknooppunt Azure VM.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-136">In HDInsight, this corresponds to a worker node Azure VM.</span></span>
* <span data-ttu-id="0c0c1-137">De worker-taken zijn Storm processen in de virtuele machines.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-137">The worker tasks are Storm processes running in the VMs.</span></span> <span data-ttu-id="0c0c1-138">Elke worker-taak komt overeen met een JVM-exemplaar.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-138">Each worker task corresponds to a JVM instance.</span></span> <span data-ttu-id="0c0c1-139">Storm distribueert het aantal werkprocessen dat u met de werkrolknooppunten zo gelijkmatig mogelijk opgeeft.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-139">Storm distributes the number of worker processes you specify to the worker nodes as evenly as possible.</span></span>
* <span data-ttu-id="0c0c1-140">Spout en Bolts executor-exemplaren.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-140">Spout and bolt executor instances.</span></span> <span data-ttu-id="0c0c1-141">Elk exemplaar executor overeenkomt met een thread die binnen de werknemers (JVMs) worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-141">Each executor instance corresponds to a thread running within the workers (JVMs).</span></span>
* <span data-ttu-id="0c0c1-142">Storm-taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-142">Storm tasks.</span></span> <span data-ttu-id="0c0c1-143">Dit zijn logische taken dat elk van deze threads uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-143">These are logical tasks that each of these threads run.</span></span> <span data-ttu-id="0c0c1-144">Dit verandert niet het niveau van parallelle uitvoering, zodat u evalueren moet als u meerdere taken per executor of niet nodig.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-144">This does not change the level of parallelism, so you should evaluate if you need multiple tasks per executor or not.</span></span>

### <a name="get-the-best-performance-from-data-lake-store"></a><span data-ttu-id="0c0c1-145">De beste prestaties ophalen uit Data Lake Store</span><span class="sxs-lookup"><span data-stu-id="0c0c1-145">Get the best performance from Data Lake Store</span></span>

<span data-ttu-id="0c0c1-146">Als u werkt met Data Lake Store, krijgt u de beste prestaties als u het volgende doen:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-146">When working with Data Lake Store, you get the best performance if you do the following:</span></span>
* <span data-ttu-id="0c0c1-147">Coalesce uw kleine voegt in grotere (bij voorkeur 4 MB).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-147">Coalesce your small appends into larger sizes (ideally 4 MB).</span></span>
* <span data-ttu-id="0c0c1-148">Als veel gelijktijdige aanvragen, zoals u kunt doen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-148">Do as many concurrent requests as you can.</span></span> <span data-ttu-id="0c0c1-149">Omdat elke thread bolt blokkerende leest doet, die u wilt hebben ergens in het bereik van 8-12-threads per core.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-149">Because each bolt thread is doing blocking reads, you want to have somewhere in the range of 8-12 threads per core.</span></span> <span data-ttu-id="0c0c1-150">Hierdoor blijft de NIC en de CPU goed worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-150">This keeps the NIC and the CPU well utilized.</span></span> <span data-ttu-id="0c0c1-151">Een grotere virtuele machine kunt meer gelijktijdige aanvragen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-151">A larger VM enables more concurrent requests.</span></span>  

### <a name="example-topology"></a><span data-ttu-id="0c0c1-152">Voorbeeldtopologie</span><span class="sxs-lookup"><span data-stu-id="0c0c1-152">Example topology</span></span>

<span data-ttu-id="0c0c1-153">Stel dat u hebt een 8 worker-knooppunten met een D13v2 Azure VM.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-153">Let’s assume you have an 8 worker node cluster with a D13v2 Azure VM.</span></span> <span data-ttu-id="0c0c1-154">Deze VM is 8 cores zodat tussen de 8 worker-knooppunten die u 64 totaal aantal kernen hebt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-154">This VM has 8 cores, so among the 8 worker nodes, you have 64 total cores.</span></span>

<span data-ttu-id="0c0c1-155">Stel, dat we 8 bolt threads per core doen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-155">Let’s say we do 8 bolt threads per core.</span></span> <span data-ttu-id="0c0c1-156">Gegeven 64 kernen betekent dit dat we willen 512 totale bolt executor exemplaren (dat wil zeggen, threads).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-156">Given 64 cores, that means we want 512 total bolt executor instances (that is, threads).</span></span> <span data-ttu-id="0c0c1-157">Stel dat in dit geval we beginnen met een JVM per VM en hoofdzakelijk gelijktijdigheid van de thread binnen de JVM gebruiken als u de gelijktijdigheid van taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-157">In this case, let’s say we start with one JVM per VM, and mainly use the thread concurrency within the JVM to achieve concurrency.</span></span> <span data-ttu-id="0c0c1-158">Dit betekent dat moet 8 worker-taken (één per virtuele machine van Azure) en 512 bolt Executor.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-158">That means we need 8 worker tasks (one per Azure VM), and 512 bolt executors.</span></span> <span data-ttu-id="0c0c1-159">In deze configuratie Storm probeert voor het distribueren van de werknemers gelijkmatig over worker-knooppunten (ook wel bekend als supervisor knooppunten), zodat elk werkrolknooppunt 1 JVM.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-159">Given this configuration, Storm tries to distribute the workers evenly across worker nodes (also known as supervisor nodes), giving each worker node 1 JVM.</span></span> <span data-ttu-id="0c0c1-160">Nu binnen de toezicht-houders wil Storm de Executor tussen toezichthouders gelijkmatig distribueren, threads zodat elke supervisor (dat wil zeggen, JVM) 8 elk.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-160">Now within the supervisors, Storm tries to distribute the executors evenly between supervisors, giving each supervisor (that is, JVM) 8 threads each.</span></span>

## <a name="tune-additional-parameters"></a><span data-ttu-id="0c0c1-161">Extra parameters optimaliseren</span><span class="sxs-lookup"><span data-stu-id="0c0c1-161">Tune additional parameters</span></span>
<span data-ttu-id="0c0c1-162">Nadat u de eenvoudige topologie hebt, kunt u overwegen of u wilt aanpassen op een van de parameters:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-162">After you have the basic topology, you can consider whether you want to tweak any of the parameters:</span></span>
* <span data-ttu-id="0c0c1-163">**Aantal JVMs per werkrolknooppunt.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-163">**Number of JVMs per worker node.**</span></span> <span data-ttu-id="0c0c1-164">Als er een grote hoeveelheden gegevensstructuur (bijvoorbeeld een opzoektabel) is een afzonderlijk exemplaar in die u als host fungeren in elke JVM-geheugen vereist.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-164">If you have a large data structure (for example, a lookup table) that you host in memory, each JVM requires a separate copy.</span></span> <span data-ttu-id="0c0c1-165">U kunt ook kunt u de gegevensstructuur in veel threads hebt u minder JVMs.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-165">Alternatively, you can use the data structure across many threads if you have fewer JVMs.</span></span> <span data-ttu-id="0c0c1-166">Voor de bolt i/o maakt het aantal JVMs geen zoveel mogelijk van een verschil als het aantal threads dat via deze JVMs toegevoegd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-166">For the bolt’s I/O, the number of JVMs does not make as much of a difference as the number of threads added across those JVMs.</span></span> <span data-ttu-id="0c0c1-167">Voor het gemak is het een goed idee om één JVM per worker.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-167">For simplicity, it's a good idea to have one JVM per worker.</span></span> <span data-ttu-id="0c0c1-168">Afhankelijk van wat uw bolt doet of welke toepassingen u verwerking vereist, maar mogelijk moet u dit nummer wijzigen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-168">Depending on what your bolt is doing or what application processing you require, though, you may need to change this number.</span></span>
* <span data-ttu-id="0c0c1-169">**Het aantal spout Executor.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-169">**Number of spout executors.**</span></span> <span data-ttu-id="0c0c1-170">Omdat het voorgaande voorbeeld bolts gebruikt voor het schrijven naar Data Lake Store, is het aantal spouts niet direct relevant zijn voor de prestaties bolt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-170">Because the preceding example uses bolts for writing to Data Lake Store, the number of spouts is not directly relevant to the bolt performance.</span></span> <span data-ttu-id="0c0c1-171">Afhankelijk van de hoeveelheid verwerking of i/o-gebeurt er in de spout, is het echter een goed idee om af te stemmen de spouts voor de beste prestaties.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-171">However, depending on the amount of processing or I/O happening in the spout, it's a good idea to tune the spouts for best performance.</span></span> <span data-ttu-id="0c0c1-172">Zorg ervoor dat er voldoende spouts kunnen de bolts bezet houden.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-172">Ensure that you have enough spouts to be able to keep the bolts busy.</span></span> <span data-ttu-id="0c0c1-173">De frequenties van de uitvoer van de spouts moeten overeenkomen met de doorvoer van de bolts.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-173">The output rates of the spouts should match the throughput of the bolts.</span></span> <span data-ttu-id="0c0c1-174">De configuratie van de werkelijke is afhankelijk van de spout.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-174">The actual configuration depends on the spout.</span></span>
* <span data-ttu-id="0c0c1-175">**Het aantal taken.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-175">**Number of tasks.**</span></span> <span data-ttu-id="0c0c1-176">Elke bolt wordt uitgevoerd met één thread.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-176">Each bolt runs as a single thread.</span></span> <span data-ttu-id="0c0c1-177">Extra taken per bolt bieden niet extra gelijktijdigheid van taken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-177">Additional tasks per bolt don't provide any additional concurrency.</span></span> <span data-ttu-id="0c0c1-178">De enige keer dat ze van het voordeel zijn is als het proces van de tuple zijn bevestigd dat een groot deel van uw uitvoeringstijd bolt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-178">The only time they are of benefit is if your process of acknowledging the tuple takes a large proportion of your bolt execution time.</span></span> <span data-ttu-id="0c0c1-179">Het is een goed idee om groep dat veel tuples in een grotere toevoegen voordat u een bevestiging vanuit de bolt verzenden.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-179">It's a good idea to group many tuples into a larger append before you send an acknowledgement from the bolt.</span></span> <span data-ttu-id="0c0c1-180">In de meeste gevallen dus bieden meerdere taken geen extra voordelen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-180">So, in most cases, multiple tasks provide no additional benefit.</span></span>
* <span data-ttu-id="0c0c1-181">**Lokaal of groepering in willekeurige volgorde.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-181">**Local or shuffle grouping.**</span></span> <span data-ttu-id="0c0c1-182">Wanneer deze instelling is ingeschakeld, worden tuples worden verzonden naar bolts binnen hetzelfde werkproces.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-182">When this setting is enabled, tuples are sent to bolts within the same worker process.</span></span> <span data-ttu-id="0c0c1-183">Dit vermindert tussen processen aanroepen voor communicatie en netwerken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-183">This reduces inter-process communication and network calls.</span></span> <span data-ttu-id="0c0c1-184">Dit wordt aanbevolen voor de meeste topologieën.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-184">This is recommended for most topologies.</span></span>

<span data-ttu-id="0c0c1-185">Dit eenvoudige scenario is een goed uitgangspunt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-185">This basic scenario is a good starting point.</span></span> <span data-ttu-id="0c0c1-186">Testen met uw eigen gegevens aanpassen van de voorgaande parameters voor optimale prestaties.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-186">Test with your own data to tweak the preceding parameters to achieve optimal performance.</span></span>

## <a name="tune-the-spout"></a><span data-ttu-id="0c0c1-187">De spout afstemmen</span><span class="sxs-lookup"><span data-stu-id="0c0c1-187">Tune the spout</span></span>

<span data-ttu-id="0c0c1-188">U kunt de volgende instellingen voor het afstemmen van de spout wijzigen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-188">You can modify the following settings to tune the spout.</span></span>

- <span data-ttu-id="0c0c1-189">**Tuple time-out: topology.message.timeout.secs**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-189">**Tuple timeout: topology.message.timeout.secs**.</span></span> <span data-ttu-id="0c0c1-190">Deze instelling bepaalt de hoeveelheid tijd nodig is voltooid en bevestiging, ontvangen een bericht voordat wordt beschouwd als mislukt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-190">This setting determines the amount of time a message takes to complete, and receive acknowledgement, before it is considered failed.</span></span>

- <span data-ttu-id="0c0c1-191">**Maximaal geheugen per werkproces: worker.childopts**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-191">**Max memory per worker process: worker.childopts**.</span></span> <span data-ttu-id="0c0c1-192">Deze instelling kunt u aanvullende opdrachtregelparameters voor de Java-werknemers opgeven.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-192">This setting lets you specify additional command-line parameters to the Java workers.</span></span> <span data-ttu-id="0c0c1-193">De meest gebruikte instelling hier is XmX waarmee wordt bepaald van de maximale hoeveelheid geheugen toegewezen aan een JVM-heap.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-193">The most commonly used setting here is XmX, which determines the maximum memory allocated to a JVM’s heap.</span></span>

- <span data-ttu-id="0c0c1-194">**Maximum aantal spout in behandeling: topology.max.spout.pending**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-194">**Max spout pending: topology.max.spout.pending**.</span></span> <span data-ttu-id="0c0c1-195">Deze instelling bepaalt het aantal tuples die in vlucht (nog niet op alle knooppunten in de topologie bevestigd) per thread spout op elk gewenst moment.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-195">This setting determines the number of tuples that can in be flight (not yet acknowledged at all nodes in the topology) per spout thread at any time.</span></span>

 <span data-ttu-id="0c0c1-196">Een goede berekening te doen is het schatten van de grootte van elk van uw tuples.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-196">A good calculation to do is to estimate the size of each of your tuples.</span></span> <span data-ttu-id="0c0c1-197">Vervolgens bepalen hoeveel geheugen een spout thread heeft.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-197">Then figure out how much memory one spout thread has.</span></span> <span data-ttu-id="0c0c1-198">Het totale geheugen toegewezen aan een thread, gedeeld door deze waarde geeft de bovengrens voor de maximale spout in behandeling zijnde parameter.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-198">The total memory allocated to a thread, divided by this value, should give you the upper bound for the max spout pending parameter.</span></span>

## <a name="tune-the-bolt"></a><span data-ttu-id="0c0c1-199">De bolt afstemmen</span><span class="sxs-lookup"><span data-stu-id="0c0c1-199">Tune the bolt</span></span>
<span data-ttu-id="0c0c1-200">Wanneer u naar Data Lake Store schrijft, moet u een synchronisatiebeleid grootte (buffer aan de clientzijde) ingesteld op 4 MB.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-200">When you're writing to Data Lake Store, set a size sync policy (buffer on the client side) to 4 MB.</span></span> <span data-ttu-id="0c0c1-201">Een domeincontrollerlocaties leeg of hsync() wordt vervolgens alleen uitgevoerd wanneer de buffergrootte is de waarde.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-201">A flushing or hsync() is then performed only when the buffer size is the at this value.</span></span> <span data-ttu-id="0c0c1-202">Het Data Lake Store-stuurprogramma op de worker VM komt automatisch deze buffering, tenzij u expliciet een hsync() uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-202">The Data Lake Store driver on the worker VM automatically does this buffering, unless you explicitly perform an hsync().</span></span>

<span data-ttu-id="0c0c1-203">De standaard Data Lake Store Storm bolt heeft een grootte sync Beleidsparameter (fileBufferSize), die kan worden gebruikt om af te stemmen met deze parameter.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-203">The default Data Lake Store Storm bolt has a size sync policy parameter (fileBufferSize) that can be used to tune this parameter.</span></span>

<span data-ttu-id="0c0c1-204">In de I/O-intensieve topologieën is het een goed idee om elke bolt thread naar een eigen bestand te schrijven en het beleid in een bestand rotatie (fileRotationSize) instellen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-204">In I/O-intensive topologies, it's a good idea to have each bolt thread write to its own file, and to set a file rotation policy (fileRotationSize).</span></span> <span data-ttu-id="0c0c1-205">Wanneer het bestand een bepaalde grootte bereikt, wordt de stroom wordt automatisch gewist en een nieuw bestand wordt geschreven naar.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-205">When the file reaches a certain size, the stream is automatically flushed and a new file is written to.</span></span> <span data-ttu-id="0c0c1-206">De aanbevolen grootte voor rotatie is 1 GB.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-206">The recommended file size for rotation is 1 GB.</span></span>

### <a name="handle-tuple-data"></a><span data-ttu-id="0c0c1-207">Tuple gegevens verwerken</span><span class="sxs-lookup"><span data-stu-id="0c0c1-207">Handle tuple data</span></span>

<span data-ttu-id="0c0c1-208">In de Storm houdt een spout een tuple totdat deze expliciet wordt bevestigd door de bolt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-208">In Storm, a spout holds on to a tuple until it is explicitly acknowledged by the bolt.</span></span> <span data-ttu-id="0c0c1-209">Als een tuple is gelezen door de bolt maar is niet zijn bevestigd, kan de spout niet hebben gehandhaafd in de back-end van Data Lake Store.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-209">If a tuple has been read by the bolt but has not been acknowledged yet, the spout might not have persisted into Data Lake Store back end.</span></span> <span data-ttu-id="0c0c1-210">Nadat een tuple is bevestigd, wordt de spout persistentie kan worden gegarandeerd door de bolt en kunt vervolgens de brongegevens verwijderen uit welke bron is het lezen van.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-210">After a tuple is acknowledged, the spout can be guaranteed persistence by the bolt, and can then delete the source data from whatever source it is reading from.</span></span>  

<span data-ttu-id="0c0c1-211">Voor optimale prestaties op Data Lake Store, hebt u de bolt buffer is 4 MB aan gegevens van de tuple.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-211">For best performance on Data Lake Store, have the bolt buffer 4 MB of tuple data.</span></span> <span data-ttu-id="0c0c1-212">Vervolgens terug te schrijven naar het Data Lake Store einde als één 4 MB geheugen schrijven.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-212">Then write to the Data Lake Store back end as one 4-MB write.</span></span> <span data-ttu-id="0c0c1-213">Nadat de gegevens is geschreven naar de store (door de aanroepende hflush()) de bolt kunt erkent de gegevens terug naar de spout.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-213">After the data has been successfully written to the store (by calling hflush()), the bolt can acknowledge the data back to the spout.</span></span> <span data-ttu-id="0c0c1-214">Dit is wat de voorbeeld-bolt hier opgegeven doet.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-214">This is what the example bolt supplied here does.</span></span> <span data-ttu-id="0c0c1-215">Het is ook aanvaardbaar is voor een groter aantal tuples voordat de aanroep hflush() is uitgevoerd en de tuples bevestigd bevatten.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-215">It is also acceptable to hold a larger number of tuples before the hflush() call is made and the tuples acknowledged.</span></span> <span data-ttu-id="0c0c1-216">Dit verhoogt echter het aantal tuples in vlucht dat de spout moet bevatten en daarom verhoogt de hoeveelheid geheugen vereist is per JVM.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-216">However, this increases the number of tuples in flight that the spout needs to hold, and therefore increases the amount of memory required per JVM.</span></span>

> [!NOTE]
<span data-ttu-id="0c0c1-217">Toepassingen hebben een vereiste voor het bevestigen van tuples vaker (op gegevensgroottes minder dan 4 MB) om andere redenen voor slechte prestaties.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-217">Applications might have a requirement to acknowledge tuples more frequently (at data sizes less than 4 MB) for other non-performance reasons.</span></span> <span data-ttu-id="0c0c1-218">Echter, die invloed kunnen zijn op de i/o-doorvoer naar de back-end voor opslag.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-218">However, that might affect the I/O throughput to the storage back end.</span></span> <span data-ttu-id="0c0c1-219">Weeg zorgvuldig deze afweging tegen de bolt i/o-prestaties.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-219">Carefully weigh this tradeoff against the bolt’s I/O performance.</span></span>

<span data-ttu-id="0c0c1-220">De frequentie van binnenkomst van tuples niet hoog is, zodat de buffer die is 4 MB lang duurt om op te vullen, dan kunt u dit door beperkende:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-220">If the incoming rate of tuples is not high, so the 4-MB buffer takes a long time to fill, consider mitigating this by:</span></span>
* <span data-ttu-id="0c0c1-221">Het aantal bolts te verminderen, dus er zijn minder buffers te vullen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-221">Reducing the number of bolts, so there are fewer buffers to fill.</span></span>
* <span data-ttu-id="0c0c1-222">Elke x leegmaakacties of elk y milliseconden met een beleid op basis van tijd of het aantal is gebaseerd, waarbij een hflush() is geactiveerd en de tot nu toe geteld tuples back zijn bevestigd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-222">Having a time-based or count-based policy, where an hflush() is triggered every x flushes or every y milliseconds, and the tuples accumulated so far are acknowledged back.</span></span>

<span data-ttu-id="0c0c1-223">Houd er rekening mee dat de doorvoer in dit geval lager is, maar met een langzame snelheid van gebeurtenissen, maximale doorvoer niet de doelstelling van het grootste toch is.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-223">Note that the throughput in this case is lower, but with a slow rate of events, maximum throughput is not the biggest objective anyway.</span></span> <span data-ttu-id="0c0c1-224">Deze oplossingen te beperken van de totale tijd die het duurt voordat een tuple doorstromen naar de store.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-224">These mitigations help you reduce the total time that it takes for a tuple to flow through to the store.</span></span> <span data-ttu-id="0c0c1-225">Dit kan van belang als u wilt dat een realtime pijplijn zelfs met een snelheid van de lage gebeurtenissen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-225">This might matter if you want a real-time pipeline even with a low event rate.</span></span> <span data-ttu-id="0c0c1-226">Let ook op dat als uw tuple frequentie van binnenkomst laag is, u met de parameter topology.message.timeout_secs aanpassen moet zodat de tuples geen time-out terwijl ze in de buffer opgeslagen of verwerkt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-226">Also note that if your incoming tuple rate is low, you should adjust the topology.message.timeout_secs parameter, so the tuples don’t time out while they are getting buffered or processed.</span></span>

## <a name="monitor-your-topology-in-storm"></a><span data-ttu-id="0c0c1-227">Uw Storm-topologie bewaken</span><span class="sxs-lookup"><span data-stu-id="0c0c1-227">Monitor your topology in Storm</span></span>  
<span data-ttu-id="0c0c1-228">Terwijl uw topologie wordt uitgevoerd, kunt u het bewaken in de gebruikersinterface van Storm.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-228">While your topology is running, you can monitor it in the Storm user interface.</span></span> <span data-ttu-id="0c0c1-229">Hier volgen de belangrijkste parameters om te kijken naar:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-229">Here are the main parameters to look at:</span></span>

* <span data-ttu-id="0c0c1-230">**Latentie van totale proces worden uitgevoerd.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-230">**Total process execution latency.**</span></span> <span data-ttu-id="0c0c1-231">Dit is de gemiddelde tijd die nodig is een tuple moet worden verzonden door de spout, verwerkt door de bolt en bevestigd.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-231">This is the average time one tuple takes to be emitted by the spout, processed by the bolt, and acknowledged.</span></span>

* <span data-ttu-id="0c0c1-232">**Totaal aantal bolt proces latentie.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-232">**Total bolt process latency.**</span></span> <span data-ttu-id="0c0c1-233">Dit is de gemiddelde tijd besteed aan de tuple van de bolt totdat het ontvangt een bevestiging.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-233">This is the average time spent by the tuple at the bolt until it receives an acknowledgement.</span></span>

* <span data-ttu-id="0c0c1-234">**Totaal aantal bolt uitvoeren latentie.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-234">**Total bolt execute latency.**</span></span> <span data-ttu-id="0c0c1-235">Dit is de gemiddelde tijd besteed door de bolt in de execute-methode.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-235">This is the average time spent by the bolt in the execute method.</span></span>

* <span data-ttu-id="0c0c1-236">**Aantal fouten.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-236">**Number of failures.**</span></span> <span data-ttu-id="0c0c1-237">Dit verwijst naar het aantal tuples die niet volledig moeten worden verwerkt voordat ze een time-out opgetreden.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-237">This refers to the number of tuples that failed to be fully processed before they timed out.</span></span>

* <span data-ttu-id="0c0c1-238">**De capaciteit.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-238">**Capacity.**</span></span> <span data-ttu-id="0c0c1-239">Dit is een meting van hoeveel van uw systeem is.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-239">This is a measure of how busy your system is.</span></span> <span data-ttu-id="0c0c1-240">Als dit nummer 1 is, worden uw bolts snel ze kunnen werken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-240">If this number is 1, your bolts are working as fast as they can.</span></span> <span data-ttu-id="0c0c1-241">Als deze kleiner dan 1 is, verhoogt u de parallelle uitvoering.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-241">If it is less than 1, increase the parallelism.</span></span> <span data-ttu-id="0c0c1-242">Als deze groter dan 1 is, verlaagt u de parallelle uitvoering.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-242">If it is greater than 1, reduce the parallelism.</span></span>

## <a name="troubleshoot-common-problems"></a><span data-ttu-id="0c0c1-243">Algemene problemen</span><span class="sxs-lookup"><span data-stu-id="0c0c1-243">Troubleshoot common problems</span></span>
<span data-ttu-id="0c0c1-244">Hier volgen enkele algemene probleemoplossing-scenario's.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-244">Here are a few common troubleshooting scenarios.</span></span>
* <span data-ttu-id="0c0c1-245">**Er zijn veel tuples time-out opgetreden.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-245">**Many tuples are timing out.**</span></span> <span data-ttu-id="0c0c1-246">Bekijk elk knooppunt in de topologie om te bepalen waar de knelpunt is.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-246">Look at each node in the topology to determine where the bottleneck is.</span></span> <span data-ttu-id="0c0c1-247">De meest voorkomende reden hiervoor is dat de bolts zich niet bij de spouts te houden.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-247">The most common reason for this is that the bolts are not able to keep up with the spouts.</span></span> <span data-ttu-id="0c0c1-248">Dit leidt tot tuples vertraging van de interne buffers tijdens het wachten op worden verwerkt.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-248">This leads to tuples clogging the internal buffers while waiting to be processed.</span></span> <span data-ttu-id="0c0c1-249">Houd rekening met de time-outwaarde vergroten of verkleinen van de maximale spout in behandeling.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-249">Consider increasing the timeout value or decreasing the max spout pending.</span></span>

* <span data-ttu-id="0c0c1-250">**Er is een latentie van hoge totale proces worden uitgevoerd, maar een proces bolt lage latentie.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-250">**There is a high total process execution latency, but a low bolt process latency.**</span></span> <span data-ttu-id="0c0c1-251">In dit geval is het mogelijk dat de tuples worden niet wordt bevestigd snel genoeg.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-251">In this case, it is possible that the tuples are not being acknowledged fast enough.</span></span> <span data-ttu-id="0c0c1-252">Controleer of er een voldoende aantal acknowledgers zijn.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-252">Check that there are a sufficient number of acknowledgers.</span></span> <span data-ttu-id="0c0c1-253">Een andere mogelijkheid is dat ze nog in de wachtrij te lang voordat deze worden verwerkt de bolts.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-253">Another possibility is that they are waiting in the queue for too long before the bolts start processing them.</span></span> <span data-ttu-id="0c0c1-254">De maximale spout in behandeling zijnde afnemen.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-254">Decrease the max spout pending.</span></span>

* <span data-ttu-id="0c0c1-255">**Er is een bolt hoge latentie uitvoeren.**</span><span class="sxs-lookup"><span data-stu-id="0c0c1-255">**There is a high bolt execute latency.**</span></span> <span data-ttu-id="0c0c1-256">Dit betekent dat de methode execute() van uw bolt duurt te lang is.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-256">This means that the execute() method of your bolt is taking too long.</span></span> <span data-ttu-id="0c0c1-257">De code optimaliseren of kijken schrijven grootten en gedrag leegmaken.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-257">Optimize the code, or look at write sizes and flush behavior.</span></span>

### <a name="data-lake-store-throttling"></a><span data-ttu-id="0c0c1-258">Beperking van Data Lake Store</span><span class="sxs-lookup"><span data-stu-id="0c0c1-258">Data Lake Store throttling</span></span>
<span data-ttu-id="0c0c1-259">Als u op de ondergrenzen van de bandbreedte die worden geleverd door de Data Lake Store, kunt u taakfouten ziet.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-259">If you hit the limits of bandwidth provided by Data Lake Store, you might see task failures.</span></span> <span data-ttu-id="0c0c1-260">Controleer de logboeken van de taak voor de beperking van fouten.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-260">Check task logs for throttling errors.</span></span> <span data-ttu-id="0c0c1-261">U kunt de parallelle uitvoering verlagen door het vergroten van de container.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-261">You can decrease the parallelism by increasing container size.</span></span>    

<span data-ttu-id="0c0c1-262">Om te zien als u zijn ophalen beperkt, schakelt u de logboekregistratie aan de clientzijde voor foutopsporing:</span><span class="sxs-lookup"><span data-stu-id="0c0c1-262">To check if you are getting throttled, enable the debug logging on the client side:</span></span>

1. <span data-ttu-id="0c0c1-263">In **Ambari** > **Storm** > **Config** > **geavanceerde storm-worker-log4j**, wijzigen  **&lt;root niveau = 'info'&gt;**  naar  **&lt;root niveau = 'debug'&gt;**.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-263">In **Ambari** > **Storm** > **Config** > **Advanced storm-worker-log4j**, change **&lt;root level="info"&gt;** to **&lt;root level=”debug”&gt;**.</span></span> <span data-ttu-id="0c0c1-264">Alle knooppunten/start de service opnieuw voor de configuratie van kracht te laten worden.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-264">Restart all the nodes/service for the configuration to take effect.</span></span>
2. <span data-ttu-id="0c0c1-265">Monitor voor de Storm-topologie op de worker-knooppunten Logboeken (onder /var/log/storm/worker-artifacts /&lt;TopologyName&gt;/&lt;poort&gt;/worker.log) voor Data Lake Store uitzonderingen beperking.</span><span class="sxs-lookup"><span data-stu-id="0c0c1-265">Monitor the Storm topology logs on worker nodes (under /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log) for Data Lake Store throttling exceptions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="0c0c1-266">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="0c0c1-266">Next steps</span></span>
<span data-ttu-id="0c0c1-267">Aanvullende prestaties afstemmen voor Storm in kan worden verwezen [deze blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-267">Additional performance tuning for Storm can be referenced in [this blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span></span>

<span data-ttu-id="0c0c1-268">Zie voor een extra voorbeeld wilt uitvoeren, [zo'n op GitHub](https://github.com/hdinsight/storm-performance-automation).</span><span class="sxs-lookup"><span data-stu-id="0c0c1-268">For an additional example to run, see [this one on GitHub](https://github.com/hdinsight/storm-performance-automation).</span></span>
